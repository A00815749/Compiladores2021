Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    OR
    SAME
    NOTSAME
    DOT
    QUOT
    CTE_CHAR
    nl
    END
    FROM
    MODA
    VARIANZA
    REGRESIONSIMPLE
    PLOTXY

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMICOLON program1
Rule 2     program1 -> VARS functions principal
Rule 3     program1 -> VARS functions
Rule 4     program1 -> program2
Rule 5     program2 -> principal
Rule 6     principal -> PRINCIPAL LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR
Rule 7     statutes -> assign SEMICOLON statutes
Rule 8     statutes -> callFunction SEMICOLON statutes
Rule 9     statutes -> reading statutes SEMICOLON statutes
Rule 10    statutes -> writing statutes SEMICOLON statutes
Rule 11    statutes -> if statutes
Rule 12    statutes -> while statutes
Rule 13    statutes -> for statutes
Rule 14    statutes -> return statutes
Rule 15    statutes -> empty
Rule 16    assign -> ID EQUAL exp
Rule 17    assign -> ID LEFTSQR exp RIGHTSQR EQUAL exp
Rule 18    callFunction -> ID LEFTPAR exp RIGHTPAR
Rule 19    reading -> READ LEFTPAR reading1 RIGHTPAR
Rule 20    reading1 -> ID reading2
Rule 21    reading2 -> COMMA reading1
Rule 22    reading2 -> empty
Rule 23    media -> MEDIA LEFTPAR array RIGHTPAR SEMICOLON
Rule 24    writing -> WRITE LEFTPAR writing1 RIGHTPAR
Rule 25    writing1 -> writing2 COMMA writing2
Rule 26    writing1 -> writing2
Rule 27    writing2 -> CTE_STRING
Rule 28    writing2 -> CTE_INT
Rule 29    writing2 -> CTE_FLOT
Rule 30    writing2 -> exp
Rule 31    if -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else
Rule 32    else -> ELSE LEFTBR statutes RIGHTBR
Rule 33    else -> empty
Rule 34    for -> FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR
Rule 35    while -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
Rule 36    exp -> ID expression exp
Rule 37    exp -> array expression exp
Rule 38    exp -> constants expression exp
Rule 39    exp -> ID
Rule 40    exp -> callFunction
Rule 41    exp -> ID LEFTSQR exp RIGHTSQR
Rule 42    exp -> constants
Rule 43    constants -> CTE_INT
Rule 44    constants -> CTE_FLOT
Rule 45    expression -> PLUS
Rule 46    expression -> REST
Rule 47    expression -> TIMES
Rule 48    expression -> DIVIDE
Rule 49    expression -> GREATER
Rule 50    expression -> GREATERAND
Rule 51    expression -> LESSER
Rule 52    expression -> LESSERAND
Rule 53    vars -> VARS vars1
Rule 54    vars -> empty
Rule 55    vars1 -> typing COLON ID variables SEMICOLON vars2
Rule 56    vars2 -> vars1
Rule 57    vars2 -> empty
Rule 58    variables -> COMMA ID variables
Rule 59    variables -> COMMA ID LEFTSQR CTE_INT RIGHTSQR variables
Rule 60    variables -> empty
Rule 61    typing -> INT
Rule 62    typing -> FLOT
Rule 63    typing -> CHAR
Rule 64    array -> LEFTSQR exp RIGHTSQR
Rule 65    array -> LEFTSQR CTE_INT RIGHTSQR
Rule 66    functions -> FUNCTION VOID voidfunction functions
Rule 67    functions -> FUNCTION typing typefunction functions
Rule 68    functions -> empty
Rule 69    voidfunction -> ID LEFTPAR args RIGHTPAR vars LEFTBR statutes RIGHTBR
Rule 70    typefunction -> ID LEFTPAR args RIGHTPAR vars LEFTBR statutes return SEMICOLON RIGHTBR
Rule 71    args -> typing COLON ID argsplural
Rule 72    args -> empty
Rule 73    argsplural -> COMMA args
Rule 74    argsplural -> empty
Rule 75    return -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON
Rule 76    return -> RETURN LEFTPAR exp RIGHTPAR
Rule 77    empty -> <empty>

Terminals, with rules where they appear

AND                  : 
CHAR                 : 63
COLON                : 55 71
COMMA                : 21 25 58 59 73
CTE_CHAR             : 
CTE_FLOT             : 29 44
CTE_INT              : 28 34 43 59 65
CTE_STRING           : 27
DIVIDE               : 48
DO                   : 34 35
DOT                  : 
ELSE                 : 32
END                  : 
EQUAL                : 16 17
FLOT                 : 62
FOR                  : 34
FROM                 : 
FUNCTION             : 66 67
GREATER              : 49
GREATERAND           : 50
ID                   : 1 16 17 18 20 36 39 41 55 58 59 69 70 71
IF                   : 31
INT                  : 61
LEFTBR               : 6 31 32 34 35 69 70
LEFTPAR              : 6 18 19 23 24 31 35 69 70 75 76
LEFTSQR              : 17 41 59 64 65
LESSER               : 51
LESSERAND            : 52
MEDIA                : 23
MODA                 : 
NOTSAME              : 
OR                   : 
PLOTXY               : 
PLUS                 : 45
PRINCIPAL            : 6
PROGRAM              : 1
QUOT                 : 
READ                 : 19
REGRESIONSIMPLE      : 
REST                 : 46
RETURN               : 75 76
RIGHTBR              : 6 31 32 34 35 69 70
RIGHTPAR             : 6 18 19 23 24 31 35 69 70 75 76
RIGHTSQR             : 17 41 59 64 65
SAME                 : 
SEMICOLON            : 1 7 8 9 10 23 55 70 75
THEN                 : 31
TIMES                : 47
TO                   : 34
VARIANZA             : 
VARS                 : 2 3 53
VOID                 : 66
WHILE                : 35
WRITE                : 24
error                : 
nl                   : 

Nonterminals, with rules where they appear

args                 : 69 70 73
argsplural           : 71
array                : 23 37
assign               : 7 34
callFunction         : 8 40
constants            : 38 42
else                 : 31
empty                : 15 22 33 54 57 60 68 72 74
exp                  : 16 17 17 18 30 31 35 36 37 38 41 64 75 76
expression           : 36 37 38
for                  : 13
functions            : 2 3 66 67
if                   : 11
media                : 
principal            : 2 5
program              : 0
program1             : 1
program2             : 4
reading              : 9
reading1             : 19 21
reading2             : 20
return               : 14 70
statutes             : 6 7 8 9 9 10 10 11 12 13 14 31 32 34 35 69 70
typefunction         : 67
typing               : 55 67 71
variables            : 55 58 59
vars                 : 69 70
vars1                : 53 56
vars2                : 55
voidfunction         : 66
while                : 12
writing              : 10
writing1             : 24
writing2             : 25 25 26

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMICOLON program1

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMICOLON program1

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMICOLON program1

    SEMICOLON       shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMICOLON . program1
    (2) program1 -> . VARS functions principal
    (3) program1 -> . VARS functions
    (4) program1 -> . program2
    (5) program2 -> . principal
    (6) principal -> . PRINCIPAL LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR

    VARS            shift and go to state 6
    PRINCIPAL       shift and go to state 9

    program1                       shift and go to state 5
    principal                      shift and go to state 7
    program2                       shift and go to state 8

state 5

    (1) program -> PROGRAM ID SEMICOLON program1 .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMICOLON program1 .)


state 6

    (2) program1 -> VARS . functions principal
    (3) program1 -> VARS . functions
    (66) functions -> . FUNCTION VOID voidfunction functions
    (67) functions -> . FUNCTION typing typefunction functions
    (68) functions -> . empty
    (77) empty -> .

    FUNCTION        shift and go to state 11
    PRINCIPAL       reduce using rule 77 (empty -> .)
    $end            reduce using rule 77 (empty -> .)

    functions                      shift and go to state 10
    empty                          shift and go to state 12

state 7

    (5) program2 -> principal .

    $end            reduce using rule 5 (program2 -> principal .)


state 8

    (4) program1 -> program2 .

    $end            reduce using rule 4 (program1 -> program2 .)


state 9

    (6) principal -> PRINCIPAL . LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR

    LEFTPAR         shift and go to state 13


state 10

    (2) program1 -> VARS functions . principal
    (3) program1 -> VARS functions .
    (6) principal -> . PRINCIPAL LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR

    $end            reduce using rule 3 (program1 -> VARS functions .)
    PRINCIPAL       shift and go to state 9

    principal                      shift and go to state 14

state 11

    (66) functions -> FUNCTION . VOID voidfunction functions
    (67) functions -> FUNCTION . typing typefunction functions
    (61) typing -> . INT
    (62) typing -> . FLOT
    (63) typing -> . CHAR

    VOID            shift and go to state 15
    INT             shift and go to state 17
    FLOT            shift and go to state 18
    CHAR            shift and go to state 19

    typing                         shift and go to state 16

state 12

    (68) functions -> empty .

    PRINCIPAL       reduce using rule 68 (functions -> empty .)
    $end            reduce using rule 68 (functions -> empty .)


state 13

    (6) principal -> PRINCIPAL LEFTPAR . RIGHTPAR LEFTBR statutes RIGHTBR

    RIGHTPAR        shift and go to state 20


state 14

    (2) program1 -> VARS functions principal .

    $end            reduce using rule 2 (program1 -> VARS functions principal .)


state 15

    (66) functions -> FUNCTION VOID . voidfunction functions
    (69) voidfunction -> . ID LEFTPAR args RIGHTPAR vars LEFTBR statutes RIGHTBR

    ID              shift and go to state 22

    voidfunction                   shift and go to state 21

state 16

    (67) functions -> FUNCTION typing . typefunction functions
    (70) typefunction -> . ID LEFTPAR args RIGHTPAR vars LEFTBR statutes return SEMICOLON RIGHTBR

    ID              shift and go to state 24

    typefunction                   shift and go to state 23

state 17

    (61) typing -> INT .

    ID              reduce using rule 61 (typing -> INT .)
    COLON           reduce using rule 61 (typing -> INT .)


state 18

    (62) typing -> FLOT .

    ID              reduce using rule 62 (typing -> FLOT .)
    COLON           reduce using rule 62 (typing -> FLOT .)


state 19

    (63) typing -> CHAR .

    ID              reduce using rule 63 (typing -> CHAR .)
    COLON           reduce using rule 63 (typing -> CHAR .)


state 20

    (6) principal -> PRINCIPAL LEFTPAR RIGHTPAR . LEFTBR statutes RIGHTBR

    LEFTBR          shift and go to state 25


state 21

    (66) functions -> FUNCTION VOID voidfunction . functions
    (66) functions -> . FUNCTION VOID voidfunction functions
    (67) functions -> . FUNCTION typing typefunction functions
    (68) functions -> . empty
    (77) empty -> .

    FUNCTION        shift and go to state 11
    PRINCIPAL       reduce using rule 77 (empty -> .)
    $end            reduce using rule 77 (empty -> .)

    functions                      shift and go to state 26
    empty                          shift and go to state 12

state 22

    (69) voidfunction -> ID . LEFTPAR args RIGHTPAR vars LEFTBR statutes RIGHTBR

    LEFTPAR         shift and go to state 27


state 23

    (67) functions -> FUNCTION typing typefunction . functions
    (66) functions -> . FUNCTION VOID voidfunction functions
    (67) functions -> . FUNCTION typing typefunction functions
    (68) functions -> . empty
    (77) empty -> .

    FUNCTION        shift and go to state 11
    PRINCIPAL       reduce using rule 77 (empty -> .)
    $end            reduce using rule 77 (empty -> .)

    functions                      shift and go to state 28
    empty                          shift and go to state 12

state 24

    (70) typefunction -> ID . LEFTPAR args RIGHTPAR vars LEFTBR statutes return SEMICOLON RIGHTBR

    LEFTPAR         shift and go to state 29


state 25

    (6) principal -> PRINCIPAL LEFTPAR RIGHTPAR LEFTBR . statutes RIGHTBR
    (7) statutes -> . assign SEMICOLON statutes
    (8) statutes -> . callFunction SEMICOLON statutes
    (9) statutes -> . reading statutes SEMICOLON statutes
    (10) statutes -> . writing statutes SEMICOLON statutes
    (11) statutes -> . if statutes
    (12) statutes -> . while statutes
    (13) statutes -> . for statutes
    (14) statutes -> . return statutes
    (15) statutes -> . empty
    (16) assign -> . ID EQUAL exp
    (17) assign -> . ID LEFTSQR exp RIGHTSQR EQUAL exp
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR
    (19) reading -> . READ LEFTPAR reading1 RIGHTPAR
    (24) writing -> . WRITE LEFTPAR writing1 RIGHTPAR
    (31) if -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else
    (35) while -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (34) for -> . FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR
    (75) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (76) return -> . RETURN LEFTPAR exp RIGHTPAR
    (77) empty -> .

    ID              shift and go to state 40
    READ            shift and go to state 41
    WRITE           shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    FOR             shift and go to state 45
    RETURN          shift and go to state 46
    RIGHTBR         reduce using rule 77 (empty -> .)

    statutes                       shift and go to state 30
    assign                         shift and go to state 31
    callFunction                   shift and go to state 32
    reading                        shift and go to state 33
    writing                        shift and go to state 34
    if                             shift and go to state 35
    while                          shift and go to state 36
    for                            shift and go to state 37
    return                         shift and go to state 38
    empty                          shift and go to state 39

state 26

    (66) functions -> FUNCTION VOID voidfunction functions .

    PRINCIPAL       reduce using rule 66 (functions -> FUNCTION VOID voidfunction functions .)
    $end            reduce using rule 66 (functions -> FUNCTION VOID voidfunction functions .)


state 27

    (69) voidfunction -> ID LEFTPAR . args RIGHTPAR vars LEFTBR statutes RIGHTBR
    (71) args -> . typing COLON ID argsplural
    (72) args -> . empty
    (61) typing -> . INT
    (62) typing -> . FLOT
    (63) typing -> . CHAR
    (77) empty -> .

    INT             shift and go to state 17
    FLOT            shift and go to state 18
    CHAR            shift and go to state 19
    RIGHTPAR        reduce using rule 77 (empty -> .)

    args                           shift and go to state 47
    typing                         shift and go to state 48
    empty                          shift and go to state 49

state 28

    (67) functions -> FUNCTION typing typefunction functions .

    PRINCIPAL       reduce using rule 67 (functions -> FUNCTION typing typefunction functions .)
    $end            reduce using rule 67 (functions -> FUNCTION typing typefunction functions .)


state 29

    (70) typefunction -> ID LEFTPAR . args RIGHTPAR vars LEFTBR statutes return SEMICOLON RIGHTBR
    (71) args -> . typing COLON ID argsplural
    (72) args -> . empty
    (61) typing -> . INT
    (62) typing -> . FLOT
    (63) typing -> . CHAR
    (77) empty -> .

    INT             shift and go to state 17
    FLOT            shift and go to state 18
    CHAR            shift and go to state 19
    RIGHTPAR        reduce using rule 77 (empty -> .)

    args                           shift and go to state 50
    typing                         shift and go to state 48
    empty                          shift and go to state 49

state 30

    (6) principal -> PRINCIPAL LEFTPAR RIGHTPAR LEFTBR statutes . RIGHTBR

    RIGHTBR         shift and go to state 51


state 31

    (7) statutes -> assign . SEMICOLON statutes

    SEMICOLON       shift and go to state 52


state 32

    (8) statutes -> callFunction . SEMICOLON statutes

    SEMICOLON       shift and go to state 53


state 33

    (9) statutes -> reading . statutes SEMICOLON statutes
    (7) statutes -> . assign SEMICOLON statutes
    (8) statutes -> . callFunction SEMICOLON statutes
    (9) statutes -> . reading statutes SEMICOLON statutes
    (10) statutes -> . writing statutes SEMICOLON statutes
    (11) statutes -> . if statutes
    (12) statutes -> . while statutes
    (13) statutes -> . for statutes
    (14) statutes -> . return statutes
    (15) statutes -> . empty
    (16) assign -> . ID EQUAL exp
    (17) assign -> . ID LEFTSQR exp RIGHTSQR EQUAL exp
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR
    (19) reading -> . READ LEFTPAR reading1 RIGHTPAR
    (24) writing -> . WRITE LEFTPAR writing1 RIGHTPAR
    (31) if -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else
    (35) while -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (34) for -> . FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR
    (75) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (76) return -> . RETURN LEFTPAR exp RIGHTPAR
    (77) empty -> .

    ID              shift and go to state 40
    READ            shift and go to state 41
    WRITE           shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    FOR             shift and go to state 45
    RETURN          shift and go to state 46
    SEMICOLON       reduce using rule 77 (empty -> .)

    reading                        shift and go to state 33
    statutes                       shift and go to state 54
    assign                         shift and go to state 31
    callFunction                   shift and go to state 32
    writing                        shift and go to state 34
    if                             shift and go to state 35
    while                          shift and go to state 36
    for                            shift and go to state 37
    return                         shift and go to state 38
    empty                          shift and go to state 39

state 34

    (10) statutes -> writing . statutes SEMICOLON statutes
    (7) statutes -> . assign SEMICOLON statutes
    (8) statutes -> . callFunction SEMICOLON statutes
    (9) statutes -> . reading statutes SEMICOLON statutes
    (10) statutes -> . writing statutes SEMICOLON statutes
    (11) statutes -> . if statutes
    (12) statutes -> . while statutes
    (13) statutes -> . for statutes
    (14) statutes -> . return statutes
    (15) statutes -> . empty
    (16) assign -> . ID EQUAL exp
    (17) assign -> . ID LEFTSQR exp RIGHTSQR EQUAL exp
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR
    (19) reading -> . READ LEFTPAR reading1 RIGHTPAR
    (24) writing -> . WRITE LEFTPAR writing1 RIGHTPAR
    (31) if -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else
    (35) while -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (34) for -> . FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR
    (75) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (76) return -> . RETURN LEFTPAR exp RIGHTPAR
    (77) empty -> .

    ID              shift and go to state 40
    READ            shift and go to state 41
    WRITE           shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    FOR             shift and go to state 45
    RETURN          shift and go to state 46
    SEMICOLON       reduce using rule 77 (empty -> .)

    writing                        shift and go to state 34
    statutes                       shift and go to state 55
    assign                         shift and go to state 31
    callFunction                   shift and go to state 32
    reading                        shift and go to state 33
    if                             shift and go to state 35
    while                          shift and go to state 36
    for                            shift and go to state 37
    return                         shift and go to state 38
    empty                          shift and go to state 39

state 35

    (11) statutes -> if . statutes
    (7) statutes -> . assign SEMICOLON statutes
    (8) statutes -> . callFunction SEMICOLON statutes
    (9) statutes -> . reading statutes SEMICOLON statutes
    (10) statutes -> . writing statutes SEMICOLON statutes
    (11) statutes -> . if statutes
    (12) statutes -> . while statutes
    (13) statutes -> . for statutes
    (14) statutes -> . return statutes
    (15) statutes -> . empty
    (16) assign -> . ID EQUAL exp
    (17) assign -> . ID LEFTSQR exp RIGHTSQR EQUAL exp
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR
    (19) reading -> . READ LEFTPAR reading1 RIGHTPAR
    (24) writing -> . WRITE LEFTPAR writing1 RIGHTPAR
    (31) if -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else
    (35) while -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (34) for -> . FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR
    (75) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (76) return -> . RETURN LEFTPAR exp RIGHTPAR
    (77) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 40
    READ            shift and go to state 41
    WRITE           shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    FOR             shift and go to state 45
    RETURN          shift and go to state 46
    RIGHTBR         reduce using rule 77 (empty -> .)
    SEMICOLON       reduce using rule 77 (empty -> .)

  ! RETURN          [ reduce using rule 77 (empty -> .) ]

    if                             shift and go to state 35
    statutes                       shift and go to state 56
    assign                         shift and go to state 31
    callFunction                   shift and go to state 32
    reading                        shift and go to state 33
    writing                        shift and go to state 34
    while                          shift and go to state 36
    for                            shift and go to state 37
    return                         shift and go to state 38
    empty                          shift and go to state 39

state 36

    (12) statutes -> while . statutes
    (7) statutes -> . assign SEMICOLON statutes
    (8) statutes -> . callFunction SEMICOLON statutes
    (9) statutes -> . reading statutes SEMICOLON statutes
    (10) statutes -> . writing statutes SEMICOLON statutes
    (11) statutes -> . if statutes
    (12) statutes -> . while statutes
    (13) statutes -> . for statutes
    (14) statutes -> . return statutes
    (15) statutes -> . empty
    (16) assign -> . ID EQUAL exp
    (17) assign -> . ID LEFTSQR exp RIGHTSQR EQUAL exp
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR
    (19) reading -> . READ LEFTPAR reading1 RIGHTPAR
    (24) writing -> . WRITE LEFTPAR writing1 RIGHTPAR
    (31) if -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else
    (35) while -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (34) for -> . FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR
    (75) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (76) return -> . RETURN LEFTPAR exp RIGHTPAR
    (77) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 40
    READ            shift and go to state 41
    WRITE           shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    FOR             shift and go to state 45
    RETURN          shift and go to state 46
    RIGHTBR         reduce using rule 77 (empty -> .)
    SEMICOLON       reduce using rule 77 (empty -> .)

  ! RETURN          [ reduce using rule 77 (empty -> .) ]

    while                          shift and go to state 36
    statutes                       shift and go to state 57
    assign                         shift and go to state 31
    callFunction                   shift and go to state 32
    reading                        shift and go to state 33
    writing                        shift and go to state 34
    if                             shift and go to state 35
    for                            shift and go to state 37
    return                         shift and go to state 38
    empty                          shift and go to state 39

state 37

    (13) statutes -> for . statutes
    (7) statutes -> . assign SEMICOLON statutes
    (8) statutes -> . callFunction SEMICOLON statutes
    (9) statutes -> . reading statutes SEMICOLON statutes
    (10) statutes -> . writing statutes SEMICOLON statutes
    (11) statutes -> . if statutes
    (12) statutes -> . while statutes
    (13) statutes -> . for statutes
    (14) statutes -> . return statutes
    (15) statutes -> . empty
    (16) assign -> . ID EQUAL exp
    (17) assign -> . ID LEFTSQR exp RIGHTSQR EQUAL exp
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR
    (19) reading -> . READ LEFTPAR reading1 RIGHTPAR
    (24) writing -> . WRITE LEFTPAR writing1 RIGHTPAR
    (31) if -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else
    (35) while -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (34) for -> . FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR
    (75) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (76) return -> . RETURN LEFTPAR exp RIGHTPAR
    (77) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 40
    READ            shift and go to state 41
    WRITE           shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    FOR             shift and go to state 45
    RETURN          shift and go to state 46
    RIGHTBR         reduce using rule 77 (empty -> .)
    SEMICOLON       reduce using rule 77 (empty -> .)

  ! RETURN          [ reduce using rule 77 (empty -> .) ]

    for                            shift and go to state 37
    statutes                       shift and go to state 58
    assign                         shift and go to state 31
    callFunction                   shift and go to state 32
    reading                        shift and go to state 33
    writing                        shift and go to state 34
    if                             shift and go to state 35
    while                          shift and go to state 36
    return                         shift and go to state 38
    empty                          shift and go to state 39

state 38

    (14) statutes -> return . statutes
    (7) statutes -> . assign SEMICOLON statutes
    (8) statutes -> . callFunction SEMICOLON statutes
    (9) statutes -> . reading statutes SEMICOLON statutes
    (10) statutes -> . writing statutes SEMICOLON statutes
    (11) statutes -> . if statutes
    (12) statutes -> . while statutes
    (13) statutes -> . for statutes
    (14) statutes -> . return statutes
    (15) statutes -> . empty
    (16) assign -> . ID EQUAL exp
    (17) assign -> . ID LEFTSQR exp RIGHTSQR EQUAL exp
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR
    (19) reading -> . READ LEFTPAR reading1 RIGHTPAR
    (24) writing -> . WRITE LEFTPAR writing1 RIGHTPAR
    (31) if -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else
    (35) while -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (34) for -> . FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR
    (75) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (76) return -> . RETURN LEFTPAR exp RIGHTPAR
    (77) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 40
    READ            shift and go to state 41
    WRITE           shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    FOR             shift and go to state 45
    RETURN          shift and go to state 46
    RIGHTBR         reduce using rule 77 (empty -> .)
    SEMICOLON       reduce using rule 77 (empty -> .)

  ! RETURN          [ reduce using rule 77 (empty -> .) ]

    return                         shift and go to state 38
    statutes                       shift and go to state 59
    assign                         shift and go to state 31
    callFunction                   shift and go to state 32
    reading                        shift and go to state 33
    writing                        shift and go to state 34
    if                             shift and go to state 35
    while                          shift and go to state 36
    for                            shift and go to state 37
    empty                          shift and go to state 39

state 39

    (15) statutes -> empty .

    RIGHTBR         reduce using rule 15 (statutes -> empty .)
    SEMICOLON       reduce using rule 15 (statutes -> empty .)
    RETURN          reduce using rule 15 (statutes -> empty .)


state 40

    (16) assign -> ID . EQUAL exp
    (17) assign -> ID . LEFTSQR exp RIGHTSQR EQUAL exp
    (18) callFunction -> ID . LEFTPAR exp RIGHTPAR

    EQUAL           shift and go to state 60
    LEFTSQR         shift and go to state 61
    LEFTPAR         shift and go to state 62


state 41

    (19) reading -> READ . LEFTPAR reading1 RIGHTPAR

    LEFTPAR         shift and go to state 63


state 42

    (24) writing -> WRITE . LEFTPAR writing1 RIGHTPAR

    LEFTPAR         shift and go to state 64


state 43

    (31) if -> IF . LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else

    LEFTPAR         shift and go to state 65


state 44

    (35) while -> WHILE . LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR

    LEFTPAR         shift and go to state 66


state 45

    (34) for -> FOR . assign TO CTE_INT DO LEFTBR statutes RIGHTBR
    (16) assign -> . ID EQUAL exp
    (17) assign -> . ID LEFTSQR exp RIGHTSQR EQUAL exp

    ID              shift and go to state 68

    assign                         shift and go to state 67

state 46

    (75) return -> RETURN . LEFTPAR exp RIGHTPAR SEMICOLON
    (76) return -> RETURN . LEFTPAR exp RIGHTPAR

    LEFTPAR         shift and go to state 69


state 47

    (69) voidfunction -> ID LEFTPAR args . RIGHTPAR vars LEFTBR statutes RIGHTBR

    RIGHTPAR        shift and go to state 70


state 48

    (71) args -> typing . COLON ID argsplural

    COLON           shift and go to state 71


state 49

    (72) args -> empty .

    RIGHTPAR        reduce using rule 72 (args -> empty .)


state 50

    (70) typefunction -> ID LEFTPAR args . RIGHTPAR vars LEFTBR statutes return SEMICOLON RIGHTBR

    RIGHTPAR        shift and go to state 72


state 51

    (6) principal -> PRINCIPAL LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR .

    $end            reduce using rule 6 (principal -> PRINCIPAL LEFTPAR RIGHTPAR LEFTBR statutes RIGHTBR .)


state 52

    (7) statutes -> assign SEMICOLON . statutes
    (7) statutes -> . assign SEMICOLON statutes
    (8) statutes -> . callFunction SEMICOLON statutes
    (9) statutes -> . reading statutes SEMICOLON statutes
    (10) statutes -> . writing statutes SEMICOLON statutes
    (11) statutes -> . if statutes
    (12) statutes -> . while statutes
    (13) statutes -> . for statutes
    (14) statutes -> . return statutes
    (15) statutes -> . empty
    (16) assign -> . ID EQUAL exp
    (17) assign -> . ID LEFTSQR exp RIGHTSQR EQUAL exp
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR
    (19) reading -> . READ LEFTPAR reading1 RIGHTPAR
    (24) writing -> . WRITE LEFTPAR writing1 RIGHTPAR
    (31) if -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else
    (35) while -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (34) for -> . FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR
    (75) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (76) return -> . RETURN LEFTPAR exp RIGHTPAR
    (77) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 40
    READ            shift and go to state 41
    WRITE           shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    FOR             shift and go to state 45
    RETURN          shift and go to state 46
    RIGHTBR         reduce using rule 77 (empty -> .)
    SEMICOLON       reduce using rule 77 (empty -> .)

  ! RETURN          [ reduce using rule 77 (empty -> .) ]

    assign                         shift and go to state 31
    statutes                       shift and go to state 73
    callFunction                   shift and go to state 32
    reading                        shift and go to state 33
    writing                        shift and go to state 34
    if                             shift and go to state 35
    while                          shift and go to state 36
    for                            shift and go to state 37
    return                         shift and go to state 38
    empty                          shift and go to state 39

state 53

    (8) statutes -> callFunction SEMICOLON . statutes
    (7) statutes -> . assign SEMICOLON statutes
    (8) statutes -> . callFunction SEMICOLON statutes
    (9) statutes -> . reading statutes SEMICOLON statutes
    (10) statutes -> . writing statutes SEMICOLON statutes
    (11) statutes -> . if statutes
    (12) statutes -> . while statutes
    (13) statutes -> . for statutes
    (14) statutes -> . return statutes
    (15) statutes -> . empty
    (16) assign -> . ID EQUAL exp
    (17) assign -> . ID LEFTSQR exp RIGHTSQR EQUAL exp
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR
    (19) reading -> . READ LEFTPAR reading1 RIGHTPAR
    (24) writing -> . WRITE LEFTPAR writing1 RIGHTPAR
    (31) if -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else
    (35) while -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (34) for -> . FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR
    (75) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (76) return -> . RETURN LEFTPAR exp RIGHTPAR
    (77) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 40
    READ            shift and go to state 41
    WRITE           shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    FOR             shift and go to state 45
    RETURN          shift and go to state 46
    RIGHTBR         reduce using rule 77 (empty -> .)
    SEMICOLON       reduce using rule 77 (empty -> .)

  ! RETURN          [ reduce using rule 77 (empty -> .) ]

    callFunction                   shift and go to state 32
    statutes                       shift and go to state 74
    assign                         shift and go to state 31
    reading                        shift and go to state 33
    writing                        shift and go to state 34
    if                             shift and go to state 35
    while                          shift and go to state 36
    for                            shift and go to state 37
    return                         shift and go to state 38
    empty                          shift and go to state 39

state 54

    (9) statutes -> reading statutes . SEMICOLON statutes

    SEMICOLON       shift and go to state 75


state 55

    (10) statutes -> writing statutes . SEMICOLON statutes

    SEMICOLON       shift and go to state 76


state 56

    (11) statutes -> if statutes .

    RIGHTBR         reduce using rule 11 (statutes -> if statutes .)
    SEMICOLON       reduce using rule 11 (statutes -> if statutes .)
    RETURN          reduce using rule 11 (statutes -> if statutes .)


state 57

    (12) statutes -> while statutes .

    RIGHTBR         reduce using rule 12 (statutes -> while statutes .)
    SEMICOLON       reduce using rule 12 (statutes -> while statutes .)
    RETURN          reduce using rule 12 (statutes -> while statutes .)


state 58

    (13) statutes -> for statutes .

    RIGHTBR         reduce using rule 13 (statutes -> for statutes .)
    SEMICOLON       reduce using rule 13 (statutes -> for statutes .)
    RETURN          reduce using rule 13 (statutes -> for statutes .)


state 59

    (14) statutes -> return statutes .

    RIGHTBR         reduce using rule 14 (statutes -> return statutes .)
    SEMICOLON       reduce using rule 14 (statutes -> return statutes .)
    RETURN          reduce using rule 14 (statutes -> return statutes .)


state 60

    (16) assign -> ID EQUAL . exp
    (36) exp -> . ID expression exp
    (37) exp -> . array expression exp
    (38) exp -> . constants expression exp
    (39) exp -> . ID
    (40) exp -> . callFunction
    (41) exp -> . ID LEFTSQR exp RIGHTSQR
    (42) exp -> . constants
    (64) array -> . LEFTSQR exp RIGHTSQR
    (65) array -> . LEFTSQR CTE_INT RIGHTSQR
    (43) constants -> . CTE_INT
    (44) constants -> . CTE_FLOT
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR

    ID              shift and go to state 77
    LEFTSQR         shift and go to state 82
    CTE_INT         shift and go to state 83
    CTE_FLOT        shift and go to state 84

    exp                            shift and go to state 78
    array                          shift and go to state 79
    constants                      shift and go to state 80
    callFunction                   shift and go to state 81

state 61

    (17) assign -> ID LEFTSQR . exp RIGHTSQR EQUAL exp
    (36) exp -> . ID expression exp
    (37) exp -> . array expression exp
    (38) exp -> . constants expression exp
    (39) exp -> . ID
    (40) exp -> . callFunction
    (41) exp -> . ID LEFTSQR exp RIGHTSQR
    (42) exp -> . constants
    (64) array -> . LEFTSQR exp RIGHTSQR
    (65) array -> . LEFTSQR CTE_INT RIGHTSQR
    (43) constants -> . CTE_INT
    (44) constants -> . CTE_FLOT
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR

    ID              shift and go to state 77
    LEFTSQR         shift and go to state 82
    CTE_INT         shift and go to state 83
    CTE_FLOT        shift and go to state 84

    exp                            shift and go to state 85
    array                          shift and go to state 79
    constants                      shift and go to state 80
    callFunction                   shift and go to state 81

state 62

    (18) callFunction -> ID LEFTPAR . exp RIGHTPAR
    (36) exp -> . ID expression exp
    (37) exp -> . array expression exp
    (38) exp -> . constants expression exp
    (39) exp -> . ID
    (40) exp -> . callFunction
    (41) exp -> . ID LEFTSQR exp RIGHTSQR
    (42) exp -> . constants
    (64) array -> . LEFTSQR exp RIGHTSQR
    (65) array -> . LEFTSQR CTE_INT RIGHTSQR
    (43) constants -> . CTE_INT
    (44) constants -> . CTE_FLOT
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR

    ID              shift and go to state 77
    LEFTSQR         shift and go to state 82
    CTE_INT         shift and go to state 83
    CTE_FLOT        shift and go to state 84

    exp                            shift and go to state 86
    array                          shift and go to state 79
    constants                      shift and go to state 80
    callFunction                   shift and go to state 81

state 63

    (19) reading -> READ LEFTPAR . reading1 RIGHTPAR
    (20) reading1 -> . ID reading2

    ID              shift and go to state 88

    reading1                       shift and go to state 87

state 64

    (24) writing -> WRITE LEFTPAR . writing1 RIGHTPAR
    (25) writing1 -> . writing2 COMMA writing2
    (26) writing1 -> . writing2
    (27) writing2 -> . CTE_STRING
    (28) writing2 -> . CTE_INT
    (29) writing2 -> . CTE_FLOT
    (30) writing2 -> . exp
    (36) exp -> . ID expression exp
    (37) exp -> . array expression exp
    (38) exp -> . constants expression exp
    (39) exp -> . ID
    (40) exp -> . callFunction
    (41) exp -> . ID LEFTSQR exp RIGHTSQR
    (42) exp -> . constants
    (64) array -> . LEFTSQR exp RIGHTSQR
    (65) array -> . LEFTSQR CTE_INT RIGHTSQR
    (43) constants -> . CTE_INT
    (44) constants -> . CTE_FLOT
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR

    CTE_STRING      shift and go to state 91
    CTE_INT         shift and go to state 92
    CTE_FLOT        shift and go to state 93
    ID              shift and go to state 77
    LEFTSQR         shift and go to state 82

    writing1                       shift and go to state 89
    writing2                       shift and go to state 90
    exp                            shift and go to state 94
    array                          shift and go to state 79
    constants                      shift and go to state 80
    callFunction                   shift and go to state 81

state 65

    (31) if -> IF LEFTPAR . exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else
    (36) exp -> . ID expression exp
    (37) exp -> . array expression exp
    (38) exp -> . constants expression exp
    (39) exp -> . ID
    (40) exp -> . callFunction
    (41) exp -> . ID LEFTSQR exp RIGHTSQR
    (42) exp -> . constants
    (64) array -> . LEFTSQR exp RIGHTSQR
    (65) array -> . LEFTSQR CTE_INT RIGHTSQR
    (43) constants -> . CTE_INT
    (44) constants -> . CTE_FLOT
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR

    ID              shift and go to state 77
    LEFTSQR         shift and go to state 82
    CTE_INT         shift and go to state 83
    CTE_FLOT        shift and go to state 84

    exp                            shift and go to state 95
    array                          shift and go to state 79
    constants                      shift and go to state 80
    callFunction                   shift and go to state 81

state 66

    (35) while -> WHILE LEFTPAR . exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (36) exp -> . ID expression exp
    (37) exp -> . array expression exp
    (38) exp -> . constants expression exp
    (39) exp -> . ID
    (40) exp -> . callFunction
    (41) exp -> . ID LEFTSQR exp RIGHTSQR
    (42) exp -> . constants
    (64) array -> . LEFTSQR exp RIGHTSQR
    (65) array -> . LEFTSQR CTE_INT RIGHTSQR
    (43) constants -> . CTE_INT
    (44) constants -> . CTE_FLOT
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR

    ID              shift and go to state 77
    LEFTSQR         shift and go to state 82
    CTE_INT         shift and go to state 83
    CTE_FLOT        shift and go to state 84

    exp                            shift and go to state 96
    array                          shift and go to state 79
    constants                      shift and go to state 80
    callFunction                   shift and go to state 81

state 67

    (34) for -> FOR assign . TO CTE_INT DO LEFTBR statutes RIGHTBR

    TO              shift and go to state 97


state 68

    (16) assign -> ID . EQUAL exp
    (17) assign -> ID . LEFTSQR exp RIGHTSQR EQUAL exp

    EQUAL           shift and go to state 60
    LEFTSQR         shift and go to state 61


state 69

    (75) return -> RETURN LEFTPAR . exp RIGHTPAR SEMICOLON
    (76) return -> RETURN LEFTPAR . exp RIGHTPAR
    (36) exp -> . ID expression exp
    (37) exp -> . array expression exp
    (38) exp -> . constants expression exp
    (39) exp -> . ID
    (40) exp -> . callFunction
    (41) exp -> . ID LEFTSQR exp RIGHTSQR
    (42) exp -> . constants
    (64) array -> . LEFTSQR exp RIGHTSQR
    (65) array -> . LEFTSQR CTE_INT RIGHTSQR
    (43) constants -> . CTE_INT
    (44) constants -> . CTE_FLOT
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR

    ID              shift and go to state 77
    LEFTSQR         shift and go to state 82
    CTE_INT         shift and go to state 83
    CTE_FLOT        shift and go to state 84

    exp                            shift and go to state 98
    array                          shift and go to state 79
    constants                      shift and go to state 80
    callFunction                   shift and go to state 81

state 70

    (69) voidfunction -> ID LEFTPAR args RIGHTPAR . vars LEFTBR statutes RIGHTBR
    (53) vars -> . VARS vars1
    (54) vars -> . empty
    (77) empty -> .

    VARS            shift and go to state 100
    LEFTBR          reduce using rule 77 (empty -> .)

    vars                           shift and go to state 99
    empty                          shift and go to state 101

state 71

    (71) args -> typing COLON . ID argsplural

    ID              shift and go to state 102


state 72

    (70) typefunction -> ID LEFTPAR args RIGHTPAR . vars LEFTBR statutes return SEMICOLON RIGHTBR
    (53) vars -> . VARS vars1
    (54) vars -> . empty
    (77) empty -> .

    VARS            shift and go to state 100
    LEFTBR          reduce using rule 77 (empty -> .)

    vars                           shift and go to state 103
    empty                          shift and go to state 101

state 73

    (7) statutes -> assign SEMICOLON statutes .

    RIGHTBR         reduce using rule 7 (statutes -> assign SEMICOLON statutes .)
    SEMICOLON       reduce using rule 7 (statutes -> assign SEMICOLON statutes .)
    RETURN          reduce using rule 7 (statutes -> assign SEMICOLON statutes .)


state 74

    (8) statutes -> callFunction SEMICOLON statutes .

    RIGHTBR         reduce using rule 8 (statutes -> callFunction SEMICOLON statutes .)
    SEMICOLON       reduce using rule 8 (statutes -> callFunction SEMICOLON statutes .)
    RETURN          reduce using rule 8 (statutes -> callFunction SEMICOLON statutes .)


state 75

    (9) statutes -> reading statutes SEMICOLON . statutes
    (7) statutes -> . assign SEMICOLON statutes
    (8) statutes -> . callFunction SEMICOLON statutes
    (9) statutes -> . reading statutes SEMICOLON statutes
    (10) statutes -> . writing statutes SEMICOLON statutes
    (11) statutes -> . if statutes
    (12) statutes -> . while statutes
    (13) statutes -> . for statutes
    (14) statutes -> . return statutes
    (15) statutes -> . empty
    (16) assign -> . ID EQUAL exp
    (17) assign -> . ID LEFTSQR exp RIGHTSQR EQUAL exp
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR
    (19) reading -> . READ LEFTPAR reading1 RIGHTPAR
    (24) writing -> . WRITE LEFTPAR writing1 RIGHTPAR
    (31) if -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else
    (35) while -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (34) for -> . FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR
    (75) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (76) return -> . RETURN LEFTPAR exp RIGHTPAR
    (77) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 40
    READ            shift and go to state 41
    WRITE           shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    FOR             shift and go to state 45
    RETURN          shift and go to state 46
    RIGHTBR         reduce using rule 77 (empty -> .)
    SEMICOLON       reduce using rule 77 (empty -> .)

  ! RETURN          [ reduce using rule 77 (empty -> .) ]

    reading                        shift and go to state 33
    statutes                       shift and go to state 104
    assign                         shift and go to state 31
    callFunction                   shift and go to state 32
    writing                        shift and go to state 34
    if                             shift and go to state 35
    while                          shift and go to state 36
    for                            shift and go to state 37
    return                         shift and go to state 38
    empty                          shift and go to state 39

state 76

    (10) statutes -> writing statutes SEMICOLON . statutes
    (7) statutes -> . assign SEMICOLON statutes
    (8) statutes -> . callFunction SEMICOLON statutes
    (9) statutes -> . reading statutes SEMICOLON statutes
    (10) statutes -> . writing statutes SEMICOLON statutes
    (11) statutes -> . if statutes
    (12) statutes -> . while statutes
    (13) statutes -> . for statutes
    (14) statutes -> . return statutes
    (15) statutes -> . empty
    (16) assign -> . ID EQUAL exp
    (17) assign -> . ID LEFTSQR exp RIGHTSQR EQUAL exp
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR
    (19) reading -> . READ LEFTPAR reading1 RIGHTPAR
    (24) writing -> . WRITE LEFTPAR writing1 RIGHTPAR
    (31) if -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else
    (35) while -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (34) for -> . FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR
    (75) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (76) return -> . RETURN LEFTPAR exp RIGHTPAR
    (77) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 40
    READ            shift and go to state 41
    WRITE           shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    FOR             shift and go to state 45
    RETURN          shift and go to state 46
    RIGHTBR         reduce using rule 77 (empty -> .)
    SEMICOLON       reduce using rule 77 (empty -> .)

  ! RETURN          [ reduce using rule 77 (empty -> .) ]

    writing                        shift and go to state 34
    statutes                       shift and go to state 105
    assign                         shift and go to state 31
    callFunction                   shift and go to state 32
    reading                        shift and go to state 33
    if                             shift and go to state 35
    while                          shift and go to state 36
    for                            shift and go to state 37
    return                         shift and go to state 38
    empty                          shift and go to state 39

state 77

    (36) exp -> ID . expression exp
    (39) exp -> ID .
    (41) exp -> ID . LEFTSQR exp RIGHTSQR
    (18) callFunction -> ID . LEFTPAR exp RIGHTPAR
    (45) expression -> . PLUS
    (46) expression -> . REST
    (47) expression -> . TIMES
    (48) expression -> . DIVIDE
    (49) expression -> . GREATER
    (50) expression -> . GREATERAND
    (51) expression -> . LESSER
    (52) expression -> . LESSERAND

    SEMICOLON       reduce using rule 39 (exp -> ID .)
    TO              reduce using rule 39 (exp -> ID .)
    RIGHTSQR        reduce using rule 39 (exp -> ID .)
    RIGHTPAR        reduce using rule 39 (exp -> ID .)
    COMMA           reduce using rule 39 (exp -> ID .)
    LEFTSQR         shift and go to state 107
    LEFTPAR         shift and go to state 62
    PLUS            shift and go to state 108
    REST            shift and go to state 109
    TIMES           shift and go to state 110
    DIVIDE          shift and go to state 111
    GREATER         shift and go to state 112
    GREATERAND      shift and go to state 113
    LESSER          shift and go to state 114
    LESSERAND       shift and go to state 115

    expression                     shift and go to state 106

state 78

    (16) assign -> ID EQUAL exp .

    SEMICOLON       reduce using rule 16 (assign -> ID EQUAL exp .)
    TO              reduce using rule 16 (assign -> ID EQUAL exp .)


state 79

    (37) exp -> array . expression exp
    (45) expression -> . PLUS
    (46) expression -> . REST
    (47) expression -> . TIMES
    (48) expression -> . DIVIDE
    (49) expression -> . GREATER
    (50) expression -> . GREATERAND
    (51) expression -> . LESSER
    (52) expression -> . LESSERAND

    PLUS            shift and go to state 108
    REST            shift and go to state 109
    TIMES           shift and go to state 110
    DIVIDE          shift and go to state 111
    GREATER         shift and go to state 112
    GREATERAND      shift and go to state 113
    LESSER          shift and go to state 114
    LESSERAND       shift and go to state 115

    expression                     shift and go to state 116

state 80

    (38) exp -> constants . expression exp
    (42) exp -> constants .
    (45) expression -> . PLUS
    (46) expression -> . REST
    (47) expression -> . TIMES
    (48) expression -> . DIVIDE
    (49) expression -> . GREATER
    (50) expression -> . GREATERAND
    (51) expression -> . LESSER
    (52) expression -> . LESSERAND

    SEMICOLON       reduce using rule 42 (exp -> constants .)
    TO              reduce using rule 42 (exp -> constants .)
    RIGHTSQR        reduce using rule 42 (exp -> constants .)
    RIGHTPAR        reduce using rule 42 (exp -> constants .)
    COMMA           reduce using rule 42 (exp -> constants .)
    PLUS            shift and go to state 108
    REST            shift and go to state 109
    TIMES           shift and go to state 110
    DIVIDE          shift and go to state 111
    GREATER         shift and go to state 112
    GREATERAND      shift and go to state 113
    LESSER          shift and go to state 114
    LESSERAND       shift and go to state 115

    expression                     shift and go to state 117

state 81

    (40) exp -> callFunction .

    SEMICOLON       reduce using rule 40 (exp -> callFunction .)
    TO              reduce using rule 40 (exp -> callFunction .)
    RIGHTSQR        reduce using rule 40 (exp -> callFunction .)
    RIGHTPAR        reduce using rule 40 (exp -> callFunction .)
    COMMA           reduce using rule 40 (exp -> callFunction .)


state 82

    (64) array -> LEFTSQR . exp RIGHTSQR
    (65) array -> LEFTSQR . CTE_INT RIGHTSQR
    (36) exp -> . ID expression exp
    (37) exp -> . array expression exp
    (38) exp -> . constants expression exp
    (39) exp -> . ID
    (40) exp -> . callFunction
    (41) exp -> . ID LEFTSQR exp RIGHTSQR
    (42) exp -> . constants
    (64) array -> . LEFTSQR exp RIGHTSQR
    (65) array -> . LEFTSQR CTE_INT RIGHTSQR
    (43) constants -> . CTE_INT
    (44) constants -> . CTE_FLOT
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR

    CTE_INT         shift and go to state 119
    ID              shift and go to state 77
    LEFTSQR         shift and go to state 82
    CTE_FLOT        shift and go to state 84

    exp                            shift and go to state 118
    array                          shift and go to state 79
    constants                      shift and go to state 80
    callFunction                   shift and go to state 81

state 83

    (43) constants -> CTE_INT .

    PLUS            reduce using rule 43 (constants -> CTE_INT .)
    REST            reduce using rule 43 (constants -> CTE_INT .)
    TIMES           reduce using rule 43 (constants -> CTE_INT .)
    DIVIDE          reduce using rule 43 (constants -> CTE_INT .)
    GREATER         reduce using rule 43 (constants -> CTE_INT .)
    GREATERAND      reduce using rule 43 (constants -> CTE_INT .)
    LESSER          reduce using rule 43 (constants -> CTE_INT .)
    LESSERAND       reduce using rule 43 (constants -> CTE_INT .)
    SEMICOLON       reduce using rule 43 (constants -> CTE_INT .)
    TO              reduce using rule 43 (constants -> CTE_INT .)
    RIGHTSQR        reduce using rule 43 (constants -> CTE_INT .)
    RIGHTPAR        reduce using rule 43 (constants -> CTE_INT .)
    COMMA           reduce using rule 43 (constants -> CTE_INT .)


state 84

    (44) constants -> CTE_FLOT .

    PLUS            reduce using rule 44 (constants -> CTE_FLOT .)
    REST            reduce using rule 44 (constants -> CTE_FLOT .)
    TIMES           reduce using rule 44 (constants -> CTE_FLOT .)
    DIVIDE          reduce using rule 44 (constants -> CTE_FLOT .)
    GREATER         reduce using rule 44 (constants -> CTE_FLOT .)
    GREATERAND      reduce using rule 44 (constants -> CTE_FLOT .)
    LESSER          reduce using rule 44 (constants -> CTE_FLOT .)
    LESSERAND       reduce using rule 44 (constants -> CTE_FLOT .)
    SEMICOLON       reduce using rule 44 (constants -> CTE_FLOT .)
    TO              reduce using rule 44 (constants -> CTE_FLOT .)
    RIGHTSQR        reduce using rule 44 (constants -> CTE_FLOT .)
    RIGHTPAR        reduce using rule 44 (constants -> CTE_FLOT .)
    COMMA           reduce using rule 44 (constants -> CTE_FLOT .)


state 85

    (17) assign -> ID LEFTSQR exp . RIGHTSQR EQUAL exp

    RIGHTSQR        shift and go to state 120


state 86

    (18) callFunction -> ID LEFTPAR exp . RIGHTPAR

    RIGHTPAR        shift and go to state 121


state 87

    (19) reading -> READ LEFTPAR reading1 . RIGHTPAR

    RIGHTPAR        shift and go to state 122


state 88

    (20) reading1 -> ID . reading2
    (21) reading2 -> . COMMA reading1
    (22) reading2 -> . empty
    (77) empty -> .

    COMMA           shift and go to state 124
    RIGHTPAR        reduce using rule 77 (empty -> .)

    reading2                       shift and go to state 123
    empty                          shift and go to state 125

state 89

    (24) writing -> WRITE LEFTPAR writing1 . RIGHTPAR

    RIGHTPAR        shift and go to state 126


state 90

    (25) writing1 -> writing2 . COMMA writing2
    (26) writing1 -> writing2 .

    COMMA           shift and go to state 127
    RIGHTPAR        reduce using rule 26 (writing1 -> writing2 .)


state 91

    (27) writing2 -> CTE_STRING .

    COMMA           reduce using rule 27 (writing2 -> CTE_STRING .)
    RIGHTPAR        reduce using rule 27 (writing2 -> CTE_STRING .)


state 92

    (28) writing2 -> CTE_INT .
    (43) constants -> CTE_INT .

  ! reduce/reduce conflict for COMMA resolved using rule 28 (writing2 -> CTE_INT .)
  ! reduce/reduce conflict for RIGHTPAR resolved using rule 28 (writing2 -> CTE_INT .)
    COMMA           reduce using rule 28 (writing2 -> CTE_INT .)
    RIGHTPAR        reduce using rule 28 (writing2 -> CTE_INT .)
    PLUS            reduce using rule 43 (constants -> CTE_INT .)
    REST            reduce using rule 43 (constants -> CTE_INT .)
    TIMES           reduce using rule 43 (constants -> CTE_INT .)
    DIVIDE          reduce using rule 43 (constants -> CTE_INT .)
    GREATER         reduce using rule 43 (constants -> CTE_INT .)
    GREATERAND      reduce using rule 43 (constants -> CTE_INT .)
    LESSER          reduce using rule 43 (constants -> CTE_INT .)
    LESSERAND       reduce using rule 43 (constants -> CTE_INT .)

  ! COMMA           [ reduce using rule 43 (constants -> CTE_INT .) ]
  ! RIGHTPAR        [ reduce using rule 43 (constants -> CTE_INT .) ]


state 93

    (29) writing2 -> CTE_FLOT .
    (44) constants -> CTE_FLOT .

  ! reduce/reduce conflict for COMMA resolved using rule 29 (writing2 -> CTE_FLOT .)
  ! reduce/reduce conflict for RIGHTPAR resolved using rule 29 (writing2 -> CTE_FLOT .)
    COMMA           reduce using rule 29 (writing2 -> CTE_FLOT .)
    RIGHTPAR        reduce using rule 29 (writing2 -> CTE_FLOT .)
    PLUS            reduce using rule 44 (constants -> CTE_FLOT .)
    REST            reduce using rule 44 (constants -> CTE_FLOT .)
    TIMES           reduce using rule 44 (constants -> CTE_FLOT .)
    DIVIDE          reduce using rule 44 (constants -> CTE_FLOT .)
    GREATER         reduce using rule 44 (constants -> CTE_FLOT .)
    GREATERAND      reduce using rule 44 (constants -> CTE_FLOT .)
    LESSER          reduce using rule 44 (constants -> CTE_FLOT .)
    LESSERAND       reduce using rule 44 (constants -> CTE_FLOT .)

  ! COMMA           [ reduce using rule 44 (constants -> CTE_FLOT .) ]
  ! RIGHTPAR        [ reduce using rule 44 (constants -> CTE_FLOT .) ]


state 94

    (30) writing2 -> exp .

    COMMA           reduce using rule 30 (writing2 -> exp .)
    RIGHTPAR        reduce using rule 30 (writing2 -> exp .)


state 95

    (31) if -> IF LEFTPAR exp . RIGHTPAR THEN LEFTBR statutes RIGHTBR else

    RIGHTPAR        shift and go to state 128


state 96

    (35) while -> WHILE LEFTPAR exp . RIGHTPAR DO LEFTBR statutes RIGHTBR

    RIGHTPAR        shift and go to state 129


state 97

    (34) for -> FOR assign TO . CTE_INT DO LEFTBR statutes RIGHTBR

    CTE_INT         shift and go to state 130


state 98

    (75) return -> RETURN LEFTPAR exp . RIGHTPAR SEMICOLON
    (76) return -> RETURN LEFTPAR exp . RIGHTPAR

    RIGHTPAR        shift and go to state 131


state 99

    (69) voidfunction -> ID LEFTPAR args RIGHTPAR vars . LEFTBR statutes RIGHTBR

    LEFTBR          shift and go to state 132


state 100

    (53) vars -> VARS . vars1
    (55) vars1 -> . typing COLON ID variables SEMICOLON vars2
    (61) typing -> . INT
    (62) typing -> . FLOT
    (63) typing -> . CHAR

    INT             shift and go to state 17
    FLOT            shift and go to state 18
    CHAR            shift and go to state 19

    vars1                          shift and go to state 133
    typing                         shift and go to state 134

state 101

    (54) vars -> empty .

    LEFTBR          reduce using rule 54 (vars -> empty .)


state 102

    (71) args -> typing COLON ID . argsplural
    (73) argsplural -> . COMMA args
    (74) argsplural -> . empty
    (77) empty -> .

    COMMA           shift and go to state 136
    RIGHTPAR        reduce using rule 77 (empty -> .)

    argsplural                     shift and go to state 135
    empty                          shift and go to state 137

state 103

    (70) typefunction -> ID LEFTPAR args RIGHTPAR vars . LEFTBR statutes return SEMICOLON RIGHTBR

    LEFTBR          shift and go to state 138


state 104

    (9) statutes -> reading statutes SEMICOLON statutes .

    RIGHTBR         reduce using rule 9 (statutes -> reading statutes SEMICOLON statutes .)
    SEMICOLON       reduce using rule 9 (statutes -> reading statutes SEMICOLON statutes .)
    RETURN          reduce using rule 9 (statutes -> reading statutes SEMICOLON statutes .)


state 105

    (10) statutes -> writing statutes SEMICOLON statutes .

    RIGHTBR         reduce using rule 10 (statutes -> writing statutes SEMICOLON statutes .)
    SEMICOLON       reduce using rule 10 (statutes -> writing statutes SEMICOLON statutes .)
    RETURN          reduce using rule 10 (statutes -> writing statutes SEMICOLON statutes .)


state 106

    (36) exp -> ID expression . exp
    (36) exp -> . ID expression exp
    (37) exp -> . array expression exp
    (38) exp -> . constants expression exp
    (39) exp -> . ID
    (40) exp -> . callFunction
    (41) exp -> . ID LEFTSQR exp RIGHTSQR
    (42) exp -> . constants
    (64) array -> . LEFTSQR exp RIGHTSQR
    (65) array -> . LEFTSQR CTE_INT RIGHTSQR
    (43) constants -> . CTE_INT
    (44) constants -> . CTE_FLOT
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR

    ID              shift and go to state 77
    LEFTSQR         shift and go to state 82
    CTE_INT         shift and go to state 83
    CTE_FLOT        shift and go to state 84

    exp                            shift and go to state 139
    array                          shift and go to state 79
    constants                      shift and go to state 80
    callFunction                   shift and go to state 81

state 107

    (41) exp -> ID LEFTSQR . exp RIGHTSQR
    (36) exp -> . ID expression exp
    (37) exp -> . array expression exp
    (38) exp -> . constants expression exp
    (39) exp -> . ID
    (40) exp -> . callFunction
    (41) exp -> . ID LEFTSQR exp RIGHTSQR
    (42) exp -> . constants
    (64) array -> . LEFTSQR exp RIGHTSQR
    (65) array -> . LEFTSQR CTE_INT RIGHTSQR
    (43) constants -> . CTE_INT
    (44) constants -> . CTE_FLOT
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR

    ID              shift and go to state 77
    LEFTSQR         shift and go to state 82
    CTE_INT         shift and go to state 83
    CTE_FLOT        shift and go to state 84

    exp                            shift and go to state 140
    array                          shift and go to state 79
    constants                      shift and go to state 80
    callFunction                   shift and go to state 81

state 108

    (45) expression -> PLUS .

    ID              reduce using rule 45 (expression -> PLUS .)
    LEFTSQR         reduce using rule 45 (expression -> PLUS .)
    CTE_INT         reduce using rule 45 (expression -> PLUS .)
    CTE_FLOT        reduce using rule 45 (expression -> PLUS .)


state 109

    (46) expression -> REST .

    ID              reduce using rule 46 (expression -> REST .)
    LEFTSQR         reduce using rule 46 (expression -> REST .)
    CTE_INT         reduce using rule 46 (expression -> REST .)
    CTE_FLOT        reduce using rule 46 (expression -> REST .)


state 110

    (47) expression -> TIMES .

    ID              reduce using rule 47 (expression -> TIMES .)
    LEFTSQR         reduce using rule 47 (expression -> TIMES .)
    CTE_INT         reduce using rule 47 (expression -> TIMES .)
    CTE_FLOT        reduce using rule 47 (expression -> TIMES .)


state 111

    (48) expression -> DIVIDE .

    ID              reduce using rule 48 (expression -> DIVIDE .)
    LEFTSQR         reduce using rule 48 (expression -> DIVIDE .)
    CTE_INT         reduce using rule 48 (expression -> DIVIDE .)
    CTE_FLOT        reduce using rule 48 (expression -> DIVIDE .)


state 112

    (49) expression -> GREATER .

    ID              reduce using rule 49 (expression -> GREATER .)
    LEFTSQR         reduce using rule 49 (expression -> GREATER .)
    CTE_INT         reduce using rule 49 (expression -> GREATER .)
    CTE_FLOT        reduce using rule 49 (expression -> GREATER .)


state 113

    (50) expression -> GREATERAND .

    ID              reduce using rule 50 (expression -> GREATERAND .)
    LEFTSQR         reduce using rule 50 (expression -> GREATERAND .)
    CTE_INT         reduce using rule 50 (expression -> GREATERAND .)
    CTE_FLOT        reduce using rule 50 (expression -> GREATERAND .)


state 114

    (51) expression -> LESSER .

    ID              reduce using rule 51 (expression -> LESSER .)
    LEFTSQR         reduce using rule 51 (expression -> LESSER .)
    CTE_INT         reduce using rule 51 (expression -> LESSER .)
    CTE_FLOT        reduce using rule 51 (expression -> LESSER .)


state 115

    (52) expression -> LESSERAND .

    ID              reduce using rule 52 (expression -> LESSERAND .)
    LEFTSQR         reduce using rule 52 (expression -> LESSERAND .)
    CTE_INT         reduce using rule 52 (expression -> LESSERAND .)
    CTE_FLOT        reduce using rule 52 (expression -> LESSERAND .)


state 116

    (37) exp -> array expression . exp
    (36) exp -> . ID expression exp
    (37) exp -> . array expression exp
    (38) exp -> . constants expression exp
    (39) exp -> . ID
    (40) exp -> . callFunction
    (41) exp -> . ID LEFTSQR exp RIGHTSQR
    (42) exp -> . constants
    (64) array -> . LEFTSQR exp RIGHTSQR
    (65) array -> . LEFTSQR CTE_INT RIGHTSQR
    (43) constants -> . CTE_INT
    (44) constants -> . CTE_FLOT
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR

    ID              shift and go to state 77
    LEFTSQR         shift and go to state 82
    CTE_INT         shift and go to state 83
    CTE_FLOT        shift and go to state 84

    array                          shift and go to state 79
    exp                            shift and go to state 141
    constants                      shift and go to state 80
    callFunction                   shift and go to state 81

state 117

    (38) exp -> constants expression . exp
    (36) exp -> . ID expression exp
    (37) exp -> . array expression exp
    (38) exp -> . constants expression exp
    (39) exp -> . ID
    (40) exp -> . callFunction
    (41) exp -> . ID LEFTSQR exp RIGHTSQR
    (42) exp -> . constants
    (64) array -> . LEFTSQR exp RIGHTSQR
    (65) array -> . LEFTSQR CTE_INT RIGHTSQR
    (43) constants -> . CTE_INT
    (44) constants -> . CTE_FLOT
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR

    ID              shift and go to state 77
    LEFTSQR         shift and go to state 82
    CTE_INT         shift and go to state 83
    CTE_FLOT        shift and go to state 84

    constants                      shift and go to state 80
    exp                            shift and go to state 142
    array                          shift and go to state 79
    callFunction                   shift and go to state 81

state 118

    (64) array -> LEFTSQR exp . RIGHTSQR

    RIGHTSQR        shift and go to state 143


state 119

    (65) array -> LEFTSQR CTE_INT . RIGHTSQR
    (43) constants -> CTE_INT .

  ! shift/reduce conflict for RIGHTSQR resolved as shift
    RIGHTSQR        shift and go to state 144
    PLUS            reduce using rule 43 (constants -> CTE_INT .)
    REST            reduce using rule 43 (constants -> CTE_INT .)
    TIMES           reduce using rule 43 (constants -> CTE_INT .)
    DIVIDE          reduce using rule 43 (constants -> CTE_INT .)
    GREATER         reduce using rule 43 (constants -> CTE_INT .)
    GREATERAND      reduce using rule 43 (constants -> CTE_INT .)
    LESSER          reduce using rule 43 (constants -> CTE_INT .)
    LESSERAND       reduce using rule 43 (constants -> CTE_INT .)

  ! RIGHTSQR        [ reduce using rule 43 (constants -> CTE_INT .) ]


state 120

    (17) assign -> ID LEFTSQR exp RIGHTSQR . EQUAL exp

    EQUAL           shift and go to state 145


state 121

    (18) callFunction -> ID LEFTPAR exp RIGHTPAR .

    SEMICOLON       reduce using rule 18 (callFunction -> ID LEFTPAR exp RIGHTPAR .)
    TO              reduce using rule 18 (callFunction -> ID LEFTPAR exp RIGHTPAR .)
    RIGHTSQR        reduce using rule 18 (callFunction -> ID LEFTPAR exp RIGHTPAR .)
    RIGHTPAR        reduce using rule 18 (callFunction -> ID LEFTPAR exp RIGHTPAR .)
    COMMA           reduce using rule 18 (callFunction -> ID LEFTPAR exp RIGHTPAR .)


state 122

    (19) reading -> READ LEFTPAR reading1 RIGHTPAR .

    ID              reduce using rule 19 (reading -> READ LEFTPAR reading1 RIGHTPAR .)
    READ            reduce using rule 19 (reading -> READ LEFTPAR reading1 RIGHTPAR .)
    WRITE           reduce using rule 19 (reading -> READ LEFTPAR reading1 RIGHTPAR .)
    IF              reduce using rule 19 (reading -> READ LEFTPAR reading1 RIGHTPAR .)
    WHILE           reduce using rule 19 (reading -> READ LEFTPAR reading1 RIGHTPAR .)
    FOR             reduce using rule 19 (reading -> READ LEFTPAR reading1 RIGHTPAR .)
    RETURN          reduce using rule 19 (reading -> READ LEFTPAR reading1 RIGHTPAR .)
    SEMICOLON       reduce using rule 19 (reading -> READ LEFTPAR reading1 RIGHTPAR .)


state 123

    (20) reading1 -> ID reading2 .

    RIGHTPAR        reduce using rule 20 (reading1 -> ID reading2 .)


state 124

    (21) reading2 -> COMMA . reading1
    (20) reading1 -> . ID reading2

    ID              shift and go to state 88

    reading1                       shift and go to state 146

state 125

    (22) reading2 -> empty .

    RIGHTPAR        reduce using rule 22 (reading2 -> empty .)


state 126

    (24) writing -> WRITE LEFTPAR writing1 RIGHTPAR .

    ID              reduce using rule 24 (writing -> WRITE LEFTPAR writing1 RIGHTPAR .)
    READ            reduce using rule 24 (writing -> WRITE LEFTPAR writing1 RIGHTPAR .)
    WRITE           reduce using rule 24 (writing -> WRITE LEFTPAR writing1 RIGHTPAR .)
    IF              reduce using rule 24 (writing -> WRITE LEFTPAR writing1 RIGHTPAR .)
    WHILE           reduce using rule 24 (writing -> WRITE LEFTPAR writing1 RIGHTPAR .)
    FOR             reduce using rule 24 (writing -> WRITE LEFTPAR writing1 RIGHTPAR .)
    RETURN          reduce using rule 24 (writing -> WRITE LEFTPAR writing1 RIGHTPAR .)
    SEMICOLON       reduce using rule 24 (writing -> WRITE LEFTPAR writing1 RIGHTPAR .)


state 127

    (25) writing1 -> writing2 COMMA . writing2
    (27) writing2 -> . CTE_STRING
    (28) writing2 -> . CTE_INT
    (29) writing2 -> . CTE_FLOT
    (30) writing2 -> . exp
    (36) exp -> . ID expression exp
    (37) exp -> . array expression exp
    (38) exp -> . constants expression exp
    (39) exp -> . ID
    (40) exp -> . callFunction
    (41) exp -> . ID LEFTSQR exp RIGHTSQR
    (42) exp -> . constants
    (64) array -> . LEFTSQR exp RIGHTSQR
    (65) array -> . LEFTSQR CTE_INT RIGHTSQR
    (43) constants -> . CTE_INT
    (44) constants -> . CTE_FLOT
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR

    CTE_STRING      shift and go to state 91
    CTE_INT         shift and go to state 92
    CTE_FLOT        shift and go to state 93
    ID              shift and go to state 77
    LEFTSQR         shift and go to state 82

    writing2                       shift and go to state 147
    exp                            shift and go to state 94
    array                          shift and go to state 79
    constants                      shift and go to state 80
    callFunction                   shift and go to state 81

state 128

    (31) if -> IF LEFTPAR exp RIGHTPAR . THEN LEFTBR statutes RIGHTBR else

    THEN            shift and go to state 148


state 129

    (35) while -> WHILE LEFTPAR exp RIGHTPAR . DO LEFTBR statutes RIGHTBR

    DO              shift and go to state 149


state 130

    (34) for -> FOR assign TO CTE_INT . DO LEFTBR statutes RIGHTBR

    DO              shift and go to state 150


state 131

    (75) return -> RETURN LEFTPAR exp RIGHTPAR . SEMICOLON
    (76) return -> RETURN LEFTPAR exp RIGHTPAR .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 151
    ID              reduce using rule 76 (return -> RETURN LEFTPAR exp RIGHTPAR .)
    READ            reduce using rule 76 (return -> RETURN LEFTPAR exp RIGHTPAR .)
    WRITE           reduce using rule 76 (return -> RETURN LEFTPAR exp RIGHTPAR .)
    IF              reduce using rule 76 (return -> RETURN LEFTPAR exp RIGHTPAR .)
    WHILE           reduce using rule 76 (return -> RETURN LEFTPAR exp RIGHTPAR .)
    FOR             reduce using rule 76 (return -> RETURN LEFTPAR exp RIGHTPAR .)
    RETURN          reduce using rule 76 (return -> RETURN LEFTPAR exp RIGHTPAR .)
    RIGHTBR         reduce using rule 76 (return -> RETURN LEFTPAR exp RIGHTPAR .)

  ! SEMICOLON       [ reduce using rule 76 (return -> RETURN LEFTPAR exp RIGHTPAR .) ]


state 132

    (69) voidfunction -> ID LEFTPAR args RIGHTPAR vars LEFTBR . statutes RIGHTBR
    (7) statutes -> . assign SEMICOLON statutes
    (8) statutes -> . callFunction SEMICOLON statutes
    (9) statutes -> . reading statutes SEMICOLON statutes
    (10) statutes -> . writing statutes SEMICOLON statutes
    (11) statutes -> . if statutes
    (12) statutes -> . while statutes
    (13) statutes -> . for statutes
    (14) statutes -> . return statutes
    (15) statutes -> . empty
    (16) assign -> . ID EQUAL exp
    (17) assign -> . ID LEFTSQR exp RIGHTSQR EQUAL exp
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR
    (19) reading -> . READ LEFTPAR reading1 RIGHTPAR
    (24) writing -> . WRITE LEFTPAR writing1 RIGHTPAR
    (31) if -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else
    (35) while -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (34) for -> . FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR
    (75) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (76) return -> . RETURN LEFTPAR exp RIGHTPAR
    (77) empty -> .

    ID              shift and go to state 40
    READ            shift and go to state 41
    WRITE           shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    FOR             shift and go to state 45
    RETURN          shift and go to state 46
    RIGHTBR         reduce using rule 77 (empty -> .)

    statutes                       shift and go to state 152
    assign                         shift and go to state 31
    callFunction                   shift and go to state 32
    reading                        shift and go to state 33
    writing                        shift and go to state 34
    if                             shift and go to state 35
    while                          shift and go to state 36
    for                            shift and go to state 37
    return                         shift and go to state 38
    empty                          shift and go to state 39

state 133

    (53) vars -> VARS vars1 .

    LEFTBR          reduce using rule 53 (vars -> VARS vars1 .)


state 134

    (55) vars1 -> typing . COLON ID variables SEMICOLON vars2

    COLON           shift and go to state 153


state 135

    (71) args -> typing COLON ID argsplural .

    RIGHTPAR        reduce using rule 71 (args -> typing COLON ID argsplural .)


state 136

    (73) argsplural -> COMMA . args
    (71) args -> . typing COLON ID argsplural
    (72) args -> . empty
    (61) typing -> . INT
    (62) typing -> . FLOT
    (63) typing -> . CHAR
    (77) empty -> .

    INT             shift and go to state 17
    FLOT            shift and go to state 18
    CHAR            shift and go to state 19
    RIGHTPAR        reduce using rule 77 (empty -> .)

    args                           shift and go to state 154
    typing                         shift and go to state 48
    empty                          shift and go to state 49

state 137

    (74) argsplural -> empty .

    RIGHTPAR        reduce using rule 74 (argsplural -> empty .)


state 138

    (70) typefunction -> ID LEFTPAR args RIGHTPAR vars LEFTBR . statutes return SEMICOLON RIGHTBR
    (7) statutes -> . assign SEMICOLON statutes
    (8) statutes -> . callFunction SEMICOLON statutes
    (9) statutes -> . reading statutes SEMICOLON statutes
    (10) statutes -> . writing statutes SEMICOLON statutes
    (11) statutes -> . if statutes
    (12) statutes -> . while statutes
    (13) statutes -> . for statutes
    (14) statutes -> . return statutes
    (15) statutes -> . empty
    (16) assign -> . ID EQUAL exp
    (17) assign -> . ID LEFTSQR exp RIGHTSQR EQUAL exp
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR
    (19) reading -> . READ LEFTPAR reading1 RIGHTPAR
    (24) writing -> . WRITE LEFTPAR writing1 RIGHTPAR
    (31) if -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else
    (35) while -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (34) for -> . FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR
    (75) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (76) return -> . RETURN LEFTPAR exp RIGHTPAR
    (77) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 40
    READ            shift and go to state 41
    WRITE           shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    FOR             shift and go to state 45
    RETURN          shift and go to state 46

  ! RETURN          [ reduce using rule 77 (empty -> .) ]

    statutes                       shift and go to state 155
    return                         shift and go to state 38
    assign                         shift and go to state 31
    callFunction                   shift and go to state 32
    reading                        shift and go to state 33
    writing                        shift and go to state 34
    if                             shift and go to state 35
    while                          shift and go to state 36
    for                            shift and go to state 37
    empty                          shift and go to state 39

state 139

    (36) exp -> ID expression exp .

    SEMICOLON       reduce using rule 36 (exp -> ID expression exp .)
    TO              reduce using rule 36 (exp -> ID expression exp .)
    RIGHTSQR        reduce using rule 36 (exp -> ID expression exp .)
    RIGHTPAR        reduce using rule 36 (exp -> ID expression exp .)
    COMMA           reduce using rule 36 (exp -> ID expression exp .)


state 140

    (41) exp -> ID LEFTSQR exp . RIGHTSQR

    RIGHTSQR        shift and go to state 156


state 141

    (37) exp -> array expression exp .

    SEMICOLON       reduce using rule 37 (exp -> array expression exp .)
    TO              reduce using rule 37 (exp -> array expression exp .)
    RIGHTSQR        reduce using rule 37 (exp -> array expression exp .)
    RIGHTPAR        reduce using rule 37 (exp -> array expression exp .)
    COMMA           reduce using rule 37 (exp -> array expression exp .)


state 142

    (38) exp -> constants expression exp .

    SEMICOLON       reduce using rule 38 (exp -> constants expression exp .)
    TO              reduce using rule 38 (exp -> constants expression exp .)
    RIGHTSQR        reduce using rule 38 (exp -> constants expression exp .)
    RIGHTPAR        reduce using rule 38 (exp -> constants expression exp .)
    COMMA           reduce using rule 38 (exp -> constants expression exp .)


state 143

    (64) array -> LEFTSQR exp RIGHTSQR .

    PLUS            reduce using rule 64 (array -> LEFTSQR exp RIGHTSQR .)
    REST            reduce using rule 64 (array -> LEFTSQR exp RIGHTSQR .)
    TIMES           reduce using rule 64 (array -> LEFTSQR exp RIGHTSQR .)
    DIVIDE          reduce using rule 64 (array -> LEFTSQR exp RIGHTSQR .)
    GREATER         reduce using rule 64 (array -> LEFTSQR exp RIGHTSQR .)
    GREATERAND      reduce using rule 64 (array -> LEFTSQR exp RIGHTSQR .)
    LESSER          reduce using rule 64 (array -> LEFTSQR exp RIGHTSQR .)
    LESSERAND       reduce using rule 64 (array -> LEFTSQR exp RIGHTSQR .)


state 144

    (65) array -> LEFTSQR CTE_INT RIGHTSQR .

    PLUS            reduce using rule 65 (array -> LEFTSQR CTE_INT RIGHTSQR .)
    REST            reduce using rule 65 (array -> LEFTSQR CTE_INT RIGHTSQR .)
    TIMES           reduce using rule 65 (array -> LEFTSQR CTE_INT RIGHTSQR .)
    DIVIDE          reduce using rule 65 (array -> LEFTSQR CTE_INT RIGHTSQR .)
    GREATER         reduce using rule 65 (array -> LEFTSQR CTE_INT RIGHTSQR .)
    GREATERAND      reduce using rule 65 (array -> LEFTSQR CTE_INT RIGHTSQR .)
    LESSER          reduce using rule 65 (array -> LEFTSQR CTE_INT RIGHTSQR .)
    LESSERAND       reduce using rule 65 (array -> LEFTSQR CTE_INT RIGHTSQR .)


state 145

    (17) assign -> ID LEFTSQR exp RIGHTSQR EQUAL . exp
    (36) exp -> . ID expression exp
    (37) exp -> . array expression exp
    (38) exp -> . constants expression exp
    (39) exp -> . ID
    (40) exp -> . callFunction
    (41) exp -> . ID LEFTSQR exp RIGHTSQR
    (42) exp -> . constants
    (64) array -> . LEFTSQR exp RIGHTSQR
    (65) array -> . LEFTSQR CTE_INT RIGHTSQR
    (43) constants -> . CTE_INT
    (44) constants -> . CTE_FLOT
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR

    ID              shift and go to state 77
    LEFTSQR         shift and go to state 82
    CTE_INT         shift and go to state 83
    CTE_FLOT        shift and go to state 84

    exp                            shift and go to state 157
    array                          shift and go to state 79
    constants                      shift and go to state 80
    callFunction                   shift and go to state 81

state 146

    (21) reading2 -> COMMA reading1 .

    RIGHTPAR        reduce using rule 21 (reading2 -> COMMA reading1 .)


state 147

    (25) writing1 -> writing2 COMMA writing2 .

    RIGHTPAR        reduce using rule 25 (writing1 -> writing2 COMMA writing2 .)


state 148

    (31) if -> IF LEFTPAR exp RIGHTPAR THEN . LEFTBR statutes RIGHTBR else

    LEFTBR          shift and go to state 158


state 149

    (35) while -> WHILE LEFTPAR exp RIGHTPAR DO . LEFTBR statutes RIGHTBR

    LEFTBR          shift and go to state 159


state 150

    (34) for -> FOR assign TO CTE_INT DO . LEFTBR statutes RIGHTBR

    LEFTBR          shift and go to state 160


state 151

    (75) return -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .

    ID              reduce using rule 75 (return -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    READ            reduce using rule 75 (return -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    WRITE           reduce using rule 75 (return -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    IF              reduce using rule 75 (return -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    WHILE           reduce using rule 75 (return -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    FOR             reduce using rule 75 (return -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    RETURN          reduce using rule 75 (return -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    RIGHTBR         reduce using rule 75 (return -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    SEMICOLON       reduce using rule 75 (return -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)


state 152

    (69) voidfunction -> ID LEFTPAR args RIGHTPAR vars LEFTBR statutes . RIGHTBR

    RIGHTBR         shift and go to state 161


state 153

    (55) vars1 -> typing COLON . ID variables SEMICOLON vars2

    ID              shift and go to state 162


state 154

    (73) argsplural -> COMMA args .

    RIGHTPAR        reduce using rule 73 (argsplural -> COMMA args .)


state 155

    (70) typefunction -> ID LEFTPAR args RIGHTPAR vars LEFTBR statutes . return SEMICOLON RIGHTBR
    (75) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (76) return -> . RETURN LEFTPAR exp RIGHTPAR

    RETURN          shift and go to state 46

    return                         shift and go to state 163

state 156

    (41) exp -> ID LEFTSQR exp RIGHTSQR .

    SEMICOLON       reduce using rule 41 (exp -> ID LEFTSQR exp RIGHTSQR .)
    TO              reduce using rule 41 (exp -> ID LEFTSQR exp RIGHTSQR .)
    RIGHTSQR        reduce using rule 41 (exp -> ID LEFTSQR exp RIGHTSQR .)
    RIGHTPAR        reduce using rule 41 (exp -> ID LEFTSQR exp RIGHTSQR .)
    COMMA           reduce using rule 41 (exp -> ID LEFTSQR exp RIGHTSQR .)


state 157

    (17) assign -> ID LEFTSQR exp RIGHTSQR EQUAL exp .

    SEMICOLON       reduce using rule 17 (assign -> ID LEFTSQR exp RIGHTSQR EQUAL exp .)
    TO              reduce using rule 17 (assign -> ID LEFTSQR exp RIGHTSQR EQUAL exp .)


state 158

    (31) if -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR . statutes RIGHTBR else
    (7) statutes -> . assign SEMICOLON statutes
    (8) statutes -> . callFunction SEMICOLON statutes
    (9) statutes -> . reading statutes SEMICOLON statutes
    (10) statutes -> . writing statutes SEMICOLON statutes
    (11) statutes -> . if statutes
    (12) statutes -> . while statutes
    (13) statutes -> . for statutes
    (14) statutes -> . return statutes
    (15) statutes -> . empty
    (16) assign -> . ID EQUAL exp
    (17) assign -> . ID LEFTSQR exp RIGHTSQR EQUAL exp
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR
    (19) reading -> . READ LEFTPAR reading1 RIGHTPAR
    (24) writing -> . WRITE LEFTPAR writing1 RIGHTPAR
    (31) if -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else
    (35) while -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (34) for -> . FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR
    (75) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (76) return -> . RETURN LEFTPAR exp RIGHTPAR
    (77) empty -> .

    ID              shift and go to state 40
    READ            shift and go to state 41
    WRITE           shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    FOR             shift and go to state 45
    RETURN          shift and go to state 46
    RIGHTBR         reduce using rule 77 (empty -> .)

    statutes                       shift and go to state 164
    assign                         shift and go to state 31
    callFunction                   shift and go to state 32
    reading                        shift and go to state 33
    writing                        shift and go to state 34
    if                             shift and go to state 35
    while                          shift and go to state 36
    for                            shift and go to state 37
    return                         shift and go to state 38
    empty                          shift and go to state 39

state 159

    (35) while -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR . statutes RIGHTBR
    (7) statutes -> . assign SEMICOLON statutes
    (8) statutes -> . callFunction SEMICOLON statutes
    (9) statutes -> . reading statutes SEMICOLON statutes
    (10) statutes -> . writing statutes SEMICOLON statutes
    (11) statutes -> . if statutes
    (12) statutes -> . while statutes
    (13) statutes -> . for statutes
    (14) statutes -> . return statutes
    (15) statutes -> . empty
    (16) assign -> . ID EQUAL exp
    (17) assign -> . ID LEFTSQR exp RIGHTSQR EQUAL exp
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR
    (19) reading -> . READ LEFTPAR reading1 RIGHTPAR
    (24) writing -> . WRITE LEFTPAR writing1 RIGHTPAR
    (31) if -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else
    (35) while -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (34) for -> . FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR
    (75) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (76) return -> . RETURN LEFTPAR exp RIGHTPAR
    (77) empty -> .

    ID              shift and go to state 40
    READ            shift and go to state 41
    WRITE           shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    FOR             shift and go to state 45
    RETURN          shift and go to state 46
    RIGHTBR         reduce using rule 77 (empty -> .)

    statutes                       shift and go to state 165
    assign                         shift and go to state 31
    callFunction                   shift and go to state 32
    reading                        shift and go to state 33
    writing                        shift and go to state 34
    if                             shift and go to state 35
    while                          shift and go to state 36
    for                            shift and go to state 37
    return                         shift and go to state 38
    empty                          shift and go to state 39

state 160

    (34) for -> FOR assign TO CTE_INT DO LEFTBR . statutes RIGHTBR
    (7) statutes -> . assign SEMICOLON statutes
    (8) statutes -> . callFunction SEMICOLON statutes
    (9) statutes -> . reading statutes SEMICOLON statutes
    (10) statutes -> . writing statutes SEMICOLON statutes
    (11) statutes -> . if statutes
    (12) statutes -> . while statutes
    (13) statutes -> . for statutes
    (14) statutes -> . return statutes
    (15) statutes -> . empty
    (16) assign -> . ID EQUAL exp
    (17) assign -> . ID LEFTSQR exp RIGHTSQR EQUAL exp
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR
    (19) reading -> . READ LEFTPAR reading1 RIGHTPAR
    (24) writing -> . WRITE LEFTPAR writing1 RIGHTPAR
    (31) if -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else
    (35) while -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (34) for -> . FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR
    (75) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (76) return -> . RETURN LEFTPAR exp RIGHTPAR
    (77) empty -> .

    ID              shift and go to state 40
    READ            shift and go to state 41
    WRITE           shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    FOR             shift and go to state 45
    RETURN          shift and go to state 46
    RIGHTBR         reduce using rule 77 (empty -> .)

    assign                         shift and go to state 31
    statutes                       shift and go to state 166
    callFunction                   shift and go to state 32
    reading                        shift and go to state 33
    writing                        shift and go to state 34
    if                             shift and go to state 35
    while                          shift and go to state 36
    for                            shift and go to state 37
    return                         shift and go to state 38
    empty                          shift and go to state 39

state 161

    (69) voidfunction -> ID LEFTPAR args RIGHTPAR vars LEFTBR statutes RIGHTBR .

    FUNCTION        reduce using rule 69 (voidfunction -> ID LEFTPAR args RIGHTPAR vars LEFTBR statutes RIGHTBR .)
    PRINCIPAL       reduce using rule 69 (voidfunction -> ID LEFTPAR args RIGHTPAR vars LEFTBR statutes RIGHTBR .)
    $end            reduce using rule 69 (voidfunction -> ID LEFTPAR args RIGHTPAR vars LEFTBR statutes RIGHTBR .)


state 162

    (55) vars1 -> typing COLON ID . variables SEMICOLON vars2
    (58) variables -> . COMMA ID variables
    (59) variables -> . COMMA ID LEFTSQR CTE_INT RIGHTSQR variables
    (60) variables -> . empty
    (77) empty -> .

    COMMA           shift and go to state 168
    SEMICOLON       reduce using rule 77 (empty -> .)

    variables                      shift and go to state 167
    empty                          shift and go to state 169

state 163

    (70) typefunction -> ID LEFTPAR args RIGHTPAR vars LEFTBR statutes return . SEMICOLON RIGHTBR

    SEMICOLON       shift and go to state 170


state 164

    (31) if -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes . RIGHTBR else

    RIGHTBR         shift and go to state 171


state 165

    (35) while -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes . RIGHTBR

    RIGHTBR         shift and go to state 172


state 166

    (34) for -> FOR assign TO CTE_INT DO LEFTBR statutes . RIGHTBR

    RIGHTBR         shift and go to state 173


state 167

    (55) vars1 -> typing COLON ID variables . SEMICOLON vars2

    SEMICOLON       shift and go to state 174


state 168

    (58) variables -> COMMA . ID variables
    (59) variables -> COMMA . ID LEFTSQR CTE_INT RIGHTSQR variables

    ID              shift and go to state 175


state 169

    (60) variables -> empty .

    SEMICOLON       reduce using rule 60 (variables -> empty .)


state 170

    (70) typefunction -> ID LEFTPAR args RIGHTPAR vars LEFTBR statutes return SEMICOLON . RIGHTBR

    RIGHTBR         shift and go to state 176


state 171

    (31) if -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR . else
    (32) else -> . ELSE LEFTBR statutes RIGHTBR
    (33) else -> . empty
    (77) empty -> .

    ELSE            shift and go to state 178
    ID              reduce using rule 77 (empty -> .)
    READ            reduce using rule 77 (empty -> .)
    WRITE           reduce using rule 77 (empty -> .)
    IF              reduce using rule 77 (empty -> .)
    WHILE           reduce using rule 77 (empty -> .)
    FOR             reduce using rule 77 (empty -> .)
    RETURN          reduce using rule 77 (empty -> .)
    RIGHTBR         reduce using rule 77 (empty -> .)
    SEMICOLON       reduce using rule 77 (empty -> .)

    else                           shift and go to state 177
    empty                          shift and go to state 179

state 172

    (35) while -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR .

    ID              reduce using rule 35 (while -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR .)
    READ            reduce using rule 35 (while -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR .)
    WRITE           reduce using rule 35 (while -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR .)
    IF              reduce using rule 35 (while -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR .)
    WHILE           reduce using rule 35 (while -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR .)
    FOR             reduce using rule 35 (while -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR .)
    RETURN          reduce using rule 35 (while -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR .)
    RIGHTBR         reduce using rule 35 (while -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR .)
    SEMICOLON       reduce using rule 35 (while -> WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR .)


state 173

    (34) for -> FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR .

    ID              reduce using rule 34 (for -> FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR .)
    READ            reduce using rule 34 (for -> FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR .)
    WRITE           reduce using rule 34 (for -> FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR .)
    IF              reduce using rule 34 (for -> FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR .)
    WHILE           reduce using rule 34 (for -> FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR .)
    FOR             reduce using rule 34 (for -> FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR .)
    RETURN          reduce using rule 34 (for -> FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR .)
    RIGHTBR         reduce using rule 34 (for -> FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR .)
    SEMICOLON       reduce using rule 34 (for -> FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR .)


state 174

    (55) vars1 -> typing COLON ID variables SEMICOLON . vars2
    (56) vars2 -> . vars1
    (57) vars2 -> . empty
    (55) vars1 -> . typing COLON ID variables SEMICOLON vars2
    (77) empty -> .
    (61) typing -> . INT
    (62) typing -> . FLOT
    (63) typing -> . CHAR

    LEFTBR          reduce using rule 77 (empty -> .)
    INT             shift and go to state 17
    FLOT            shift and go to state 18
    CHAR            shift and go to state 19

    typing                         shift and go to state 134
    vars2                          shift and go to state 180
    vars1                          shift and go to state 181
    empty                          shift and go to state 182

state 175

    (58) variables -> COMMA ID . variables
    (59) variables -> COMMA ID . LEFTSQR CTE_INT RIGHTSQR variables
    (58) variables -> . COMMA ID variables
    (59) variables -> . COMMA ID LEFTSQR CTE_INT RIGHTSQR variables
    (60) variables -> . empty
    (77) empty -> .

    LEFTSQR         shift and go to state 184
    COMMA           shift and go to state 168
    SEMICOLON       reduce using rule 77 (empty -> .)

    variables                      shift and go to state 183
    empty                          shift and go to state 169

state 176

    (70) typefunction -> ID LEFTPAR args RIGHTPAR vars LEFTBR statutes return SEMICOLON RIGHTBR .

    FUNCTION        reduce using rule 70 (typefunction -> ID LEFTPAR args RIGHTPAR vars LEFTBR statutes return SEMICOLON RIGHTBR .)
    PRINCIPAL       reduce using rule 70 (typefunction -> ID LEFTPAR args RIGHTPAR vars LEFTBR statutes return SEMICOLON RIGHTBR .)
    $end            reduce using rule 70 (typefunction -> ID LEFTPAR args RIGHTPAR vars LEFTBR statutes return SEMICOLON RIGHTBR .)


state 177

    (31) if -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else .

    ID              reduce using rule 31 (if -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else .)
    READ            reduce using rule 31 (if -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else .)
    WRITE           reduce using rule 31 (if -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else .)
    IF              reduce using rule 31 (if -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else .)
    WHILE           reduce using rule 31 (if -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else .)
    FOR             reduce using rule 31 (if -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else .)
    RETURN          reduce using rule 31 (if -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else .)
    RIGHTBR         reduce using rule 31 (if -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else .)
    SEMICOLON       reduce using rule 31 (if -> IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else .)


state 178

    (32) else -> ELSE . LEFTBR statutes RIGHTBR

    LEFTBR          shift and go to state 185


state 179

    (33) else -> empty .

    ID              reduce using rule 33 (else -> empty .)
    READ            reduce using rule 33 (else -> empty .)
    WRITE           reduce using rule 33 (else -> empty .)
    IF              reduce using rule 33 (else -> empty .)
    WHILE           reduce using rule 33 (else -> empty .)
    FOR             reduce using rule 33 (else -> empty .)
    RETURN          reduce using rule 33 (else -> empty .)
    RIGHTBR         reduce using rule 33 (else -> empty .)
    SEMICOLON       reduce using rule 33 (else -> empty .)


state 180

    (55) vars1 -> typing COLON ID variables SEMICOLON vars2 .

    LEFTBR          reduce using rule 55 (vars1 -> typing COLON ID variables SEMICOLON vars2 .)


state 181

    (56) vars2 -> vars1 .

    LEFTBR          reduce using rule 56 (vars2 -> vars1 .)


state 182

    (57) vars2 -> empty .

    LEFTBR          reduce using rule 57 (vars2 -> empty .)


state 183

    (58) variables -> COMMA ID variables .

    SEMICOLON       reduce using rule 58 (variables -> COMMA ID variables .)


state 184

    (59) variables -> COMMA ID LEFTSQR . CTE_INT RIGHTSQR variables

    CTE_INT         shift and go to state 186


state 185

    (32) else -> ELSE LEFTBR . statutes RIGHTBR
    (7) statutes -> . assign SEMICOLON statutes
    (8) statutes -> . callFunction SEMICOLON statutes
    (9) statutes -> . reading statutes SEMICOLON statutes
    (10) statutes -> . writing statutes SEMICOLON statutes
    (11) statutes -> . if statutes
    (12) statutes -> . while statutes
    (13) statutes -> . for statutes
    (14) statutes -> . return statutes
    (15) statutes -> . empty
    (16) assign -> . ID EQUAL exp
    (17) assign -> . ID LEFTSQR exp RIGHTSQR EQUAL exp
    (18) callFunction -> . ID LEFTPAR exp RIGHTPAR
    (19) reading -> . READ LEFTPAR reading1 RIGHTPAR
    (24) writing -> . WRITE LEFTPAR writing1 RIGHTPAR
    (31) if -> . IF LEFTPAR exp RIGHTPAR THEN LEFTBR statutes RIGHTBR else
    (35) while -> . WHILE LEFTPAR exp RIGHTPAR DO LEFTBR statutes RIGHTBR
    (34) for -> . FOR assign TO CTE_INT DO LEFTBR statutes RIGHTBR
    (75) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (76) return -> . RETURN LEFTPAR exp RIGHTPAR
    (77) empty -> .

    ID              shift and go to state 40
    READ            shift and go to state 41
    WRITE           shift and go to state 42
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    FOR             shift and go to state 45
    RETURN          shift and go to state 46
    RIGHTBR         reduce using rule 77 (empty -> .)

    statutes                       shift and go to state 187
    assign                         shift and go to state 31
    callFunction                   shift and go to state 32
    reading                        shift and go to state 33
    writing                        shift and go to state 34
    if                             shift and go to state 35
    while                          shift and go to state 36
    for                            shift and go to state 37
    return                         shift and go to state 38
    empty                          shift and go to state 39

state 186

    (59) variables -> COMMA ID LEFTSQR CTE_INT . RIGHTSQR variables

    RIGHTSQR        shift and go to state 188


state 187

    (32) else -> ELSE LEFTBR statutes . RIGHTBR

    RIGHTBR         shift and go to state 189


state 188

    (59) variables -> COMMA ID LEFTSQR CTE_INT RIGHTSQR . variables
    (58) variables -> . COMMA ID variables
    (59) variables -> . COMMA ID LEFTSQR CTE_INT RIGHTSQR variables
    (60) variables -> . empty
    (77) empty -> .

    COMMA           shift and go to state 168
    SEMICOLON       reduce using rule 77 (empty -> .)

    variables                      shift and go to state 190
    empty                          shift and go to state 169

state 189

    (32) else -> ELSE LEFTBR statutes RIGHTBR .

    ID              reduce using rule 32 (else -> ELSE LEFTBR statutes RIGHTBR .)
    READ            reduce using rule 32 (else -> ELSE LEFTBR statutes RIGHTBR .)
    WRITE           reduce using rule 32 (else -> ELSE LEFTBR statutes RIGHTBR .)
    IF              reduce using rule 32 (else -> ELSE LEFTBR statutes RIGHTBR .)
    WHILE           reduce using rule 32 (else -> ELSE LEFTBR statutes RIGHTBR .)
    FOR             reduce using rule 32 (else -> ELSE LEFTBR statutes RIGHTBR .)
    RETURN          reduce using rule 32 (else -> ELSE LEFTBR statutes RIGHTBR .)
    RIGHTBR         reduce using rule 32 (else -> ELSE LEFTBR statutes RIGHTBR .)
    SEMICOLON       reduce using rule 32 (else -> ELSE LEFTBR statutes RIGHTBR .)


state 190

    (59) variables -> COMMA ID LEFTSQR CTE_INT RIGHTSQR variables .

    SEMICOLON       reduce using rule 59 (variables -> COMMA ID LEFTSQR CTE_INT RIGHTSQR variables .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RETURN in state 35 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 36 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 37 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 38 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 52 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 53 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 75 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 76 resolved as shift
WARNING: shift/reduce conflict for RIGHTSQR in state 119 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 131 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 138 resolved as shift
WARNING: reduce/reduce conflict in state 92 resolved using rule (writing2 -> CTE_INT)
WARNING: rejected rule (constants -> CTE_INT) in state 92
WARNING: reduce/reduce conflict in state 93 resolved using rule (writing2 -> CTE_FLOT)
WARNING: rejected rule (constants -> CTE_FLOT) in state 93
