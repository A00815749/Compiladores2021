Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    MODA
    VARIANZA
    REGRESIONSIMPLE
    PLOTXY
    SAME
    DOT
    QUOT
    nl

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMICOLON programprep program1
Rule 2     programprep -> <empty>
Rule 3     program1 -> vars mainquad functions jumpprogram principalaux
Rule 4     program1 -> vars mainquad functions
Rule 5     program1 -> principalaux
Rule 6     principalaux -> principal
Rule 7     principal -> PRINCIPAL LEFTPAR storefunct RIGHTPAR LEFTBR vars statutes RIGHTBR
Rule 8     mainquad -> <empty>
Rule 9     jumpprogram -> <empty>
Rule 10    statutes -> assign SEMICOLON statutes
Rule 11    statutes -> callFunction SEMICOLON statutes
Rule 12    statutes -> reading statutes SEMICOLON statutes
Rule 13    statutes -> writing statutes SEMICOLON statutes
Rule 14    statutes -> if statutes
Rule 15    statutes -> while statutes
Rule 16    statutes -> for statutes
Rule 17    statutes -> return statutes
Rule 18    statutes -> empty
Rule 19    assign -> ID idgetter EQUAL operatorhandler exp assignquad
Rule 20    assign -> ID idgetter array EQUAL operatorhandler exp assignquad
Rule 21    idgetter -> <empty>
Rule 22    idgetterarray -> <empty>
Rule 23    assignquad -> <empty>
Rule 24    callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
Rule 25    checkid -> <empty>
Rule 26    eraquad -> <empty>
Rule 27    paramexp -> exp paramquad paramaux
Rule 28    paramexp -> exp paramquad COMMA paramaux paramexp
Rule 29    paramexp -> empty
Rule 30    paramaux -> <empty>
Rule 31    paramquad -> <empty>
Rule 32    checkparam -> <empty>
Rule 33    quadgosub -> <empty>
Rule 34    reading -> READ auxreading LEFTPAR reading1 RIGHTPAR
Rule 35    reading1 -> reading2
Rule 36    reading1 -> empty
Rule 37    reading2 -> exp readingquad
Rule 38    reading2 -> exp readingquad COMMA auxreading reading2
Rule 39    auxreading -> <empty>
Rule 40    readingquad -> <empty>
Rule 41    writing -> WRITE auxwriting LEFTPAR writing1 RIGHTPAR
Rule 42    writing1 -> writing2
Rule 43    writing1 -> empty
Rule 44    writing2 -> exp writingquad
Rule 45    writing2 -> exp writingquad COMMA auxwriting writing2
Rule 46    auxwriting -> <empty>
Rule 47    writingquad -> <empty>
Rule 48    media -> MEDIA LEFTPAR array RIGHTPAR SEMICOLON
Rule 49    if -> IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif
Rule 50    else -> ELSE quadelse LEFTBR statutes RIGHTBR
Rule 51    else -> empty
Rule 52    quadif -> <empty>
Rule 53    endif -> <empty>
Rule 54    quadelse -> <empty>
Rule 55    endofloop -> <empty>
Rule 56    for -> FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop
Rule 57    auxfor -> <empty>
Rule 58    quadfor -> <empty>
Rule 59    while -> WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop
Rule 60    auxwhile -> <empty>
Rule 61    quadwhile -> <empty>
Rule 62    exp -> andexp quador
Rule 63    exp -> andexp quador OR operatorhandler andexp
Rule 64    quador -> <empty>
Rule 65    andexp -> boolexp quadand
Rule 66    andexp -> boolexp quadand AND operatorhandler boolexp
Rule 67    quadand -> <empty>
Rule 68    boolexp -> arithexp
Rule 69    boolexp -> boolexp1 arithexp
Rule 70    boolexp1 -> arithexp LESSER operatorhandler arithexp quadbool
Rule 71    boolexp1 -> arithexp LESSERAND operatorhandler arithexp quadbool
Rule 72    boolexp1 -> arithexp GREATER operatorhandler arithexp quadbool
Rule 73    boolexp1 -> arithexp GREATERAND operatorhandler arithexp quadbool
Rule 74    boolexp1 -> arithexp NOTSAME operatorhandler arithexp quadbool
Rule 75    quadbool -> <empty>
Rule 76    arithexp -> geoexp
Rule 77    arithexp -> geoexp PLUS operatorhandler geoexp quadarith
Rule 78    arithexp -> geoexp REST operatorhandler geoexp quadarith
Rule 79    quadarith -> <empty>
Rule 80    geoexp -> assignedexp
Rule 81    geoexp -> assignedexp TIMES operatorhandler assignedexp quadgeo
Rule 82    geoexp -> assignedexp DIVIDE operatorhandler assignedexp quadgeo
Rule 83    quadgeo -> <empty>
Rule 84    assignedexp -> ID idgetter
Rule 85    assignedexp -> CTEINT cteaux
Rule 86    assignedexp -> CTEFLOAT cteaux
Rule 87    assignedexp -> CTECHAR cteaux
Rule 88    assignedexp -> CTESTRING cteaux
Rule 89    assignedexp -> callFunction
Rule 90    assignedexp -> LEFTPAR exp RIGHTPAR
Rule 91    assignedexp -> ID array idgetterarray
Rule 92    assignedexp -> empty
Rule 93    cteaux -> <empty>
Rule 94    operatorhandler -> <empty>
Rule 95    vars -> vars0
Rule 96    vars -> empty
Rule 97    vars0 -> VARS vars1
Rule 98    vars1 -> vars1 typing COLON vars2 SEMICOLON addVar
Rule 99    vars1 -> empty
Rule 100   vars2 -> ID
Rule 101   vars2 -> ID array
Rule 102   vars2 -> ID COMMA vars2 addVar
Rule 103   vars2 -> ID array COMMA vars2 addVar
Rule 104   vars2 -> empty
Rule 105   addVar -> <empty>
Rule 106   typing -> INT saveTypeofVar
Rule 107   typing -> CHAR saveTypeofVar
Rule 108   typing -> FLOAT saveTypeofVar
Rule 109   saveTypeofVar -> <empty>
Rule 110   array -> LEFTSQR exp RIGHTSQR
Rule 111   array -> LEFTSQR CTEINT RIGHTSQR
Rule 112   functions -> FUNCTION VOID functions1 funcend functions
Rule 113   functions -> FUNCTION INT functions1 funcend functions
Rule 114   functions -> FUNCTION FLOAT functions1 funcend functions
Rule 115   functions -> FUNCTION CHAR functions1 funcend functions
Rule 116   functions -> empty
Rule 117   functions1 -> ID storefunct LEFTPAR args RIGHTPAR vars LEFTBR setaddstart statutes RIGHTBR
Rule 118   functions1 -> empty
Rule 119   setaddstart -> <empty>
Rule 120   args -> args1
Rule 121   args -> empty
Rule 122   args1 -> INT saveTypeofVar COLON ID mulParam nextParam
Rule 123   args1 -> FLOAT saveTypeofVar COLON ID mulParam nextParam
Rule 124   args1 -> CHAR saveTypeofVar COLON ID mulParam nextParam
Rule 125   nextParam -> COMMA args1
Rule 126   nextParam -> empty
Rule 127   mulParam -> <empty>
Rule 128   funcend -> <empty>
Rule 129   storefunct -> <empty>
Rule 130   return -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON
Rule 131   return -> RETURN LEFTPAR exp RIGHTPAR
Rule 132   empty -> <empty>

Terminals, with rules where they appear

AND                  : 66
CHAR                 : 107 115 124
COLON                : 98 122 123 124
COMMA                : 28 38 45 102 103 125
CTECHAR              : 87
CTEFLOAT             : 86
CTEINT               : 56 85 111
CTESTRING            : 88
DIVIDE               : 82
DO                   : 56 59
DOT                  : 
ELSE                 : 50
EQUAL                : 19 20
FLOAT                : 108 114 123
FOR                  : 56
FUNCTION             : 112 113 114 115
GREATER              : 72
GREATERAND           : 73
ID                   : 1 19 20 24 84 91 100 101 102 103 117 122 123 124
IF                   : 49
INT                  : 106 113 122
LEFTBR               : 7 49 50 56 59 117
LEFTPAR              : 7 24 34 41 48 49 59 90 117 130 131
LEFTSQR              : 110 111
LESSER               : 70
LESSERAND            : 71
MEDIA                : 48
MODA                 : 
NOTSAME              : 74
OR                   : 63
PLOTXY               : 
PLUS                 : 77
PRINCIPAL            : 7
PROGRAM              : 1
QUOT                 : 
READ                 : 34
REGRESIONSIMPLE      : 
REST                 : 78
RETURN               : 130 131
RIGHTBR              : 7 49 50 56 59 117
RIGHTPAR             : 7 24 34 41 48 49 59 90 117 130 131
RIGHTSQR             : 110 111
SAME                 : 
SEMICOLON            : 1 10 11 12 13 48 98 130
THEN                 : 49
TIMES                : 81
TO                   : 56
VARIANZA             : 
VARS                 : 97
VOID                 : 112
WHILE                : 59
WRITE                : 41
error                : 
nl                   : 

Nonterminals, with rules where they appear

addVar               : 98 102 103
andexp               : 62 63 63
args                 : 117
args1                : 120 125
arithexp             : 68 69 70 70 71 71 72 72 73 73 74 74
array                : 20 48 91 101 103
assign               : 10 56
assignedexp          : 80 81 81 82 82
assignquad           : 19 20
auxfor               : 56
auxreading           : 34 38
auxwhile             : 59
auxwriting           : 41 45
boolexp              : 65 66 66
boolexp1             : 69
callFunction         : 11 89
checkid              : 24
checkparam           : 24
cteaux               : 85 86 87 88
else                 : 49
empty                : 18 29 36 43 51 92 96 99 104 116 118 121 126
endif                : 49
endofloop            : 56 59
eraquad              : 24
exp                  : 19 20 27 28 37 38 44 45 49 59 90 110 130 131
for                  : 16
funcend              : 112 113 114 115
functions            : 3 4 112 113 114 115
functions1           : 112 113 114 115
geoexp               : 76 77 77 78 78
idgetter             : 19 20 84
idgetterarray        : 91
if                   : 14
jumpprogram          : 3
mainquad             : 3 4
media                : 
mulParam             : 122 123 124
nextParam            : 122 123 124
operatorhandler      : 19 20 63 66 70 71 72 73 74 77 78 81 82
paramaux             : 27 28
paramexp             : 24 28
paramquad            : 27 28
principal            : 6
principalaux         : 3 5
program              : 0
program1             : 1
programprep          : 1
quadand              : 65 66
quadarith            : 77 78
quadbool             : 70 71 72 73 74
quadelse             : 50
quadfor              : 56
quadgeo              : 81 82
quadgosub            : 24
quadif               : 49
quador               : 62 63
quadwhile            : 59
reading              : 12
reading1             : 34
reading2             : 35 38
readingquad          : 37 38
return               : 17
saveTypeofVar        : 106 107 108 122 123 124
setaddstart          : 117
statutes             : 7 10 11 12 12 13 13 14 15 16 17 49 50 56 59 117
storefunct           : 7 117
typing               : 98
vars                 : 3 4 7 117
vars0                : 95
vars1                : 97 98
vars2                : 98 102 103
while                : 15
writing              : 13
writing1             : 41
writing2             : 42 45
writingquad          : 44 45

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMICOLON programprep program1

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMICOLON programprep program1

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMICOLON programprep program1

    SEMICOLON       shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMICOLON . programprep program1
    (2) programprep -> .

    VARS            reduce using rule 2 (programprep -> .)
    PRINCIPAL       reduce using rule 2 (programprep -> .)
    FUNCTION        reduce using rule 2 (programprep -> .)
    $end            reduce using rule 2 (programprep -> .)

    programprep                    shift and go to state 5

state 5

    (1) program -> PROGRAM ID SEMICOLON programprep . program1
    (3) program1 -> . vars mainquad functions jumpprogram principalaux
    (4) program1 -> . vars mainquad functions
    (5) program1 -> . principalaux
    (95) vars -> . vars0
    (96) vars -> . empty
    (6) principalaux -> . principal
    (97) vars0 -> . VARS vars1
    (132) empty -> .
    (7) principal -> . PRINCIPAL LEFTPAR storefunct RIGHTPAR LEFTBR vars statutes RIGHTBR

  ! shift/reduce conflict for PRINCIPAL resolved as shift
    VARS            shift and go to state 12
    FUNCTION        reduce using rule 132 (empty -> .)
    $end            reduce using rule 132 (empty -> .)
    PRINCIPAL       shift and go to state 13

  ! PRINCIPAL       [ reduce using rule 132 (empty -> .) ]

    program1                       shift and go to state 6
    vars                           shift and go to state 7
    principalaux                   shift and go to state 8
    vars0                          shift and go to state 9
    empty                          shift and go to state 10
    principal                      shift and go to state 11

state 6

    (1) program -> PROGRAM ID SEMICOLON programprep program1 .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMICOLON programprep program1 .)


state 7

    (3) program1 -> vars . mainquad functions jumpprogram principalaux
    (4) program1 -> vars . mainquad functions
    (8) mainquad -> .

    FUNCTION        reduce using rule 8 (mainquad -> .)
    PRINCIPAL       reduce using rule 8 (mainquad -> .)
    $end            reduce using rule 8 (mainquad -> .)

    mainquad                       shift and go to state 14

state 8

    (5) program1 -> principalaux .

    $end            reduce using rule 5 (program1 -> principalaux .)


state 9

    (95) vars -> vars0 .

    FUNCTION        reduce using rule 95 (vars -> vars0 .)
    PRINCIPAL       reduce using rule 95 (vars -> vars0 .)
    $end            reduce using rule 95 (vars -> vars0 .)
    ID              reduce using rule 95 (vars -> vars0 .)
    READ            reduce using rule 95 (vars -> vars0 .)
    WRITE           reduce using rule 95 (vars -> vars0 .)
    IF              reduce using rule 95 (vars -> vars0 .)
    WHILE           reduce using rule 95 (vars -> vars0 .)
    FOR             reduce using rule 95 (vars -> vars0 .)
    RETURN          reduce using rule 95 (vars -> vars0 .)
    RIGHTBR         reduce using rule 95 (vars -> vars0 .)
    LEFTBR          reduce using rule 95 (vars -> vars0 .)


state 10

    (96) vars -> empty .

    FUNCTION        reduce using rule 96 (vars -> empty .)
    PRINCIPAL       reduce using rule 96 (vars -> empty .)
    $end            reduce using rule 96 (vars -> empty .)
    ID              reduce using rule 96 (vars -> empty .)
    READ            reduce using rule 96 (vars -> empty .)
    WRITE           reduce using rule 96 (vars -> empty .)
    IF              reduce using rule 96 (vars -> empty .)
    WHILE           reduce using rule 96 (vars -> empty .)
    FOR             reduce using rule 96 (vars -> empty .)
    RETURN          reduce using rule 96 (vars -> empty .)
    RIGHTBR         reduce using rule 96 (vars -> empty .)
    LEFTBR          reduce using rule 96 (vars -> empty .)


state 11

    (6) principalaux -> principal .

    $end            reduce using rule 6 (principalaux -> principal .)


state 12

    (97) vars0 -> VARS . vars1
    (98) vars1 -> . vars1 typing COLON vars2 SEMICOLON addVar
    (99) vars1 -> . empty
    (132) empty -> .

    INT             reduce using rule 132 (empty -> .)
    CHAR            reduce using rule 132 (empty -> .)
    FLOAT           reduce using rule 132 (empty -> .)
    FUNCTION        reduce using rule 132 (empty -> .)
    PRINCIPAL       reduce using rule 132 (empty -> .)
    $end            reduce using rule 132 (empty -> .)
    ID              reduce using rule 132 (empty -> .)
    READ            reduce using rule 132 (empty -> .)
    WRITE           reduce using rule 132 (empty -> .)
    IF              reduce using rule 132 (empty -> .)
    WHILE           reduce using rule 132 (empty -> .)
    FOR             reduce using rule 132 (empty -> .)
    RETURN          reduce using rule 132 (empty -> .)
    RIGHTBR         reduce using rule 132 (empty -> .)
    LEFTBR          reduce using rule 132 (empty -> .)

    vars1                          shift and go to state 15
    empty                          shift and go to state 16

state 13

    (7) principal -> PRINCIPAL . LEFTPAR storefunct RIGHTPAR LEFTBR vars statutes RIGHTBR

    LEFTPAR         shift and go to state 17


state 14

    (3) program1 -> vars mainquad . functions jumpprogram principalaux
    (4) program1 -> vars mainquad . functions
    (112) functions -> . FUNCTION VOID functions1 funcend functions
    (113) functions -> . FUNCTION INT functions1 funcend functions
    (114) functions -> . FUNCTION FLOAT functions1 funcend functions
    (115) functions -> . FUNCTION CHAR functions1 funcend functions
    (116) functions -> . empty
    (132) empty -> .

    FUNCTION        shift and go to state 19
    PRINCIPAL       reduce using rule 132 (empty -> .)
    $end            reduce using rule 132 (empty -> .)

    functions                      shift and go to state 18
    empty                          shift and go to state 20

state 15

    (97) vars0 -> VARS vars1 .
    (98) vars1 -> vars1 . typing COLON vars2 SEMICOLON addVar
    (106) typing -> . INT saveTypeofVar
    (107) typing -> . CHAR saveTypeofVar
    (108) typing -> . FLOAT saveTypeofVar

    FUNCTION        reduce using rule 97 (vars0 -> VARS vars1 .)
    PRINCIPAL       reduce using rule 97 (vars0 -> VARS vars1 .)
    $end            reduce using rule 97 (vars0 -> VARS vars1 .)
    ID              reduce using rule 97 (vars0 -> VARS vars1 .)
    READ            reduce using rule 97 (vars0 -> VARS vars1 .)
    WRITE           reduce using rule 97 (vars0 -> VARS vars1 .)
    IF              reduce using rule 97 (vars0 -> VARS vars1 .)
    WHILE           reduce using rule 97 (vars0 -> VARS vars1 .)
    FOR             reduce using rule 97 (vars0 -> VARS vars1 .)
    RETURN          reduce using rule 97 (vars0 -> VARS vars1 .)
    RIGHTBR         reduce using rule 97 (vars0 -> VARS vars1 .)
    LEFTBR          reduce using rule 97 (vars0 -> VARS vars1 .)
    INT             shift and go to state 22
    CHAR            shift and go to state 23
    FLOAT           shift and go to state 24

    typing                         shift and go to state 21

state 16

    (99) vars1 -> empty .

    INT             reduce using rule 99 (vars1 -> empty .)
    CHAR            reduce using rule 99 (vars1 -> empty .)
    FLOAT           reduce using rule 99 (vars1 -> empty .)
    FUNCTION        reduce using rule 99 (vars1 -> empty .)
    PRINCIPAL       reduce using rule 99 (vars1 -> empty .)
    $end            reduce using rule 99 (vars1 -> empty .)
    ID              reduce using rule 99 (vars1 -> empty .)
    READ            reduce using rule 99 (vars1 -> empty .)
    WRITE           reduce using rule 99 (vars1 -> empty .)
    IF              reduce using rule 99 (vars1 -> empty .)
    WHILE           reduce using rule 99 (vars1 -> empty .)
    FOR             reduce using rule 99 (vars1 -> empty .)
    RETURN          reduce using rule 99 (vars1 -> empty .)
    RIGHTBR         reduce using rule 99 (vars1 -> empty .)
    LEFTBR          reduce using rule 99 (vars1 -> empty .)


state 17

    (7) principal -> PRINCIPAL LEFTPAR . storefunct RIGHTPAR LEFTBR vars statutes RIGHTBR
    (129) storefunct -> .

    RIGHTPAR        reduce using rule 129 (storefunct -> .)

    storefunct                     shift and go to state 25

state 18

    (3) program1 -> vars mainquad functions . jumpprogram principalaux
    (4) program1 -> vars mainquad functions .
    (9) jumpprogram -> .

    $end            reduce using rule 4 (program1 -> vars mainquad functions .)
    PRINCIPAL       reduce using rule 9 (jumpprogram -> .)

    jumpprogram                    shift and go to state 26

state 19

    (112) functions -> FUNCTION . VOID functions1 funcend functions
    (113) functions -> FUNCTION . INT functions1 funcend functions
    (114) functions -> FUNCTION . FLOAT functions1 funcend functions
    (115) functions -> FUNCTION . CHAR functions1 funcend functions

    VOID            shift and go to state 27
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    CHAR            shift and go to state 30


state 20

    (116) functions -> empty .

    PRINCIPAL       reduce using rule 116 (functions -> empty .)
    $end            reduce using rule 116 (functions -> empty .)


state 21

    (98) vars1 -> vars1 typing . COLON vars2 SEMICOLON addVar

    COLON           shift and go to state 31


state 22

    (106) typing -> INT . saveTypeofVar
    (109) saveTypeofVar -> .

    COLON           reduce using rule 109 (saveTypeofVar -> .)

    saveTypeofVar                  shift and go to state 32

state 23

    (107) typing -> CHAR . saveTypeofVar
    (109) saveTypeofVar -> .

    COLON           reduce using rule 109 (saveTypeofVar -> .)

    saveTypeofVar                  shift and go to state 33

state 24

    (108) typing -> FLOAT . saveTypeofVar
    (109) saveTypeofVar -> .

    COLON           reduce using rule 109 (saveTypeofVar -> .)

    saveTypeofVar                  shift and go to state 34

state 25

    (7) principal -> PRINCIPAL LEFTPAR storefunct . RIGHTPAR LEFTBR vars statutes RIGHTBR

    RIGHTPAR        shift and go to state 35


state 26

    (3) program1 -> vars mainquad functions jumpprogram . principalaux
    (6) principalaux -> . principal
    (7) principal -> . PRINCIPAL LEFTPAR storefunct RIGHTPAR LEFTBR vars statutes RIGHTBR

    PRINCIPAL       shift and go to state 13

    principalaux                   shift and go to state 36
    principal                      shift and go to state 11

state 27

    (112) functions -> FUNCTION VOID . functions1 funcend functions
    (117) functions1 -> . ID storefunct LEFTPAR args RIGHTPAR vars LEFTBR setaddstart statutes RIGHTBR
    (118) functions1 -> . empty
    (132) empty -> .

    ID              shift and go to state 38
    FUNCTION        reduce using rule 132 (empty -> .)
    PRINCIPAL       reduce using rule 132 (empty -> .)
    $end            reduce using rule 132 (empty -> .)

    functions1                     shift and go to state 37
    empty                          shift and go to state 39

state 28

    (113) functions -> FUNCTION INT . functions1 funcend functions
    (117) functions1 -> . ID storefunct LEFTPAR args RIGHTPAR vars LEFTBR setaddstart statutes RIGHTBR
    (118) functions1 -> . empty
    (132) empty -> .

    ID              shift and go to state 38
    FUNCTION        reduce using rule 132 (empty -> .)
    PRINCIPAL       reduce using rule 132 (empty -> .)
    $end            reduce using rule 132 (empty -> .)

    functions1                     shift and go to state 40
    empty                          shift and go to state 39

state 29

    (114) functions -> FUNCTION FLOAT . functions1 funcend functions
    (117) functions1 -> . ID storefunct LEFTPAR args RIGHTPAR vars LEFTBR setaddstart statutes RIGHTBR
    (118) functions1 -> . empty
    (132) empty -> .

    ID              shift and go to state 38
    FUNCTION        reduce using rule 132 (empty -> .)
    PRINCIPAL       reduce using rule 132 (empty -> .)
    $end            reduce using rule 132 (empty -> .)

    functions1                     shift and go to state 41
    empty                          shift and go to state 39

state 30

    (115) functions -> FUNCTION CHAR . functions1 funcend functions
    (117) functions1 -> . ID storefunct LEFTPAR args RIGHTPAR vars LEFTBR setaddstart statutes RIGHTBR
    (118) functions1 -> . empty
    (132) empty -> .

    ID              shift and go to state 38
    FUNCTION        reduce using rule 132 (empty -> .)
    PRINCIPAL       reduce using rule 132 (empty -> .)
    $end            reduce using rule 132 (empty -> .)

    functions1                     shift and go to state 42
    empty                          shift and go to state 39

state 31

    (98) vars1 -> vars1 typing COLON . vars2 SEMICOLON addVar
    (100) vars2 -> . ID
    (101) vars2 -> . ID array
    (102) vars2 -> . ID COMMA vars2 addVar
    (103) vars2 -> . ID array COMMA vars2 addVar
    (104) vars2 -> . empty
    (132) empty -> .

    ID              shift and go to state 44
    SEMICOLON       reduce using rule 132 (empty -> .)

    vars2                          shift and go to state 43
    empty                          shift and go to state 45

state 32

    (106) typing -> INT saveTypeofVar .

    COLON           reduce using rule 106 (typing -> INT saveTypeofVar .)


state 33

    (107) typing -> CHAR saveTypeofVar .

    COLON           reduce using rule 107 (typing -> CHAR saveTypeofVar .)


state 34

    (108) typing -> FLOAT saveTypeofVar .

    COLON           reduce using rule 108 (typing -> FLOAT saveTypeofVar .)


state 35

    (7) principal -> PRINCIPAL LEFTPAR storefunct RIGHTPAR . LEFTBR vars statutes RIGHTBR

    LEFTBR          shift and go to state 46


state 36

    (3) program1 -> vars mainquad functions jumpprogram principalaux .

    $end            reduce using rule 3 (program1 -> vars mainquad functions jumpprogram principalaux .)


state 37

    (112) functions -> FUNCTION VOID functions1 . funcend functions
    (128) funcend -> .

    FUNCTION        reduce using rule 128 (funcend -> .)
    PRINCIPAL       reduce using rule 128 (funcend -> .)
    $end            reduce using rule 128 (funcend -> .)

    funcend                        shift and go to state 47

state 38

    (117) functions1 -> ID . storefunct LEFTPAR args RIGHTPAR vars LEFTBR setaddstart statutes RIGHTBR
    (129) storefunct -> .

    LEFTPAR         reduce using rule 129 (storefunct -> .)

    storefunct                     shift and go to state 48

state 39

    (118) functions1 -> empty .

    FUNCTION        reduce using rule 118 (functions1 -> empty .)
    PRINCIPAL       reduce using rule 118 (functions1 -> empty .)
    $end            reduce using rule 118 (functions1 -> empty .)


state 40

    (113) functions -> FUNCTION INT functions1 . funcend functions
    (128) funcend -> .

    FUNCTION        reduce using rule 128 (funcend -> .)
    PRINCIPAL       reduce using rule 128 (funcend -> .)
    $end            reduce using rule 128 (funcend -> .)

    funcend                        shift and go to state 49

state 41

    (114) functions -> FUNCTION FLOAT functions1 . funcend functions
    (128) funcend -> .

    FUNCTION        reduce using rule 128 (funcend -> .)
    PRINCIPAL       reduce using rule 128 (funcend -> .)
    $end            reduce using rule 128 (funcend -> .)

    funcend                        shift and go to state 50

state 42

    (115) functions -> FUNCTION CHAR functions1 . funcend functions
    (128) funcend -> .

    FUNCTION        reduce using rule 128 (funcend -> .)
    PRINCIPAL       reduce using rule 128 (funcend -> .)
    $end            reduce using rule 128 (funcend -> .)

    funcend                        shift and go to state 51

state 43

    (98) vars1 -> vars1 typing COLON vars2 . SEMICOLON addVar

    SEMICOLON       shift and go to state 52


state 44

    (100) vars2 -> ID .
    (101) vars2 -> ID . array
    (102) vars2 -> ID . COMMA vars2 addVar
    (103) vars2 -> ID . array COMMA vars2 addVar
    (110) array -> . LEFTSQR exp RIGHTSQR
    (111) array -> . LEFTSQR CTEINT RIGHTSQR

    SEMICOLON       reduce using rule 100 (vars2 -> ID .)
    COMMA           shift and go to state 54
    LEFTSQR         shift and go to state 55

    array                          shift and go to state 53

state 45

    (104) vars2 -> empty .

    SEMICOLON       reduce using rule 104 (vars2 -> empty .)


state 46

    (7) principal -> PRINCIPAL LEFTPAR storefunct RIGHTPAR LEFTBR . vars statutes RIGHTBR
    (95) vars -> . vars0
    (96) vars -> . empty
    (97) vars0 -> . VARS vars1
    (132) empty -> .

    VARS            shift and go to state 12
    ID              reduce using rule 132 (empty -> .)
    READ            reduce using rule 132 (empty -> .)
    WRITE           reduce using rule 132 (empty -> .)
    IF              reduce using rule 132 (empty -> .)
    WHILE           reduce using rule 132 (empty -> .)
    FOR             reduce using rule 132 (empty -> .)
    RETURN          reduce using rule 132 (empty -> .)
    RIGHTBR         reduce using rule 132 (empty -> .)

    vars                           shift and go to state 56
    vars0                          shift and go to state 9
    empty                          shift and go to state 10

state 47

    (112) functions -> FUNCTION VOID functions1 funcend . functions
    (112) functions -> . FUNCTION VOID functions1 funcend functions
    (113) functions -> . FUNCTION INT functions1 funcend functions
    (114) functions -> . FUNCTION FLOAT functions1 funcend functions
    (115) functions -> . FUNCTION CHAR functions1 funcend functions
    (116) functions -> . empty
    (132) empty -> .

    FUNCTION        shift and go to state 19
    PRINCIPAL       reduce using rule 132 (empty -> .)
    $end            reduce using rule 132 (empty -> .)

    functions                      shift and go to state 57
    empty                          shift and go to state 20

state 48

    (117) functions1 -> ID storefunct . LEFTPAR args RIGHTPAR vars LEFTBR setaddstart statutes RIGHTBR

    LEFTPAR         shift and go to state 58


state 49

    (113) functions -> FUNCTION INT functions1 funcend . functions
    (112) functions -> . FUNCTION VOID functions1 funcend functions
    (113) functions -> . FUNCTION INT functions1 funcend functions
    (114) functions -> . FUNCTION FLOAT functions1 funcend functions
    (115) functions -> . FUNCTION CHAR functions1 funcend functions
    (116) functions -> . empty
    (132) empty -> .

    FUNCTION        shift and go to state 19
    PRINCIPAL       reduce using rule 132 (empty -> .)
    $end            reduce using rule 132 (empty -> .)

    functions                      shift and go to state 59
    empty                          shift and go to state 20

state 50

    (114) functions -> FUNCTION FLOAT functions1 funcend . functions
    (112) functions -> . FUNCTION VOID functions1 funcend functions
    (113) functions -> . FUNCTION INT functions1 funcend functions
    (114) functions -> . FUNCTION FLOAT functions1 funcend functions
    (115) functions -> . FUNCTION CHAR functions1 funcend functions
    (116) functions -> . empty
    (132) empty -> .

    FUNCTION        shift and go to state 19
    PRINCIPAL       reduce using rule 132 (empty -> .)
    $end            reduce using rule 132 (empty -> .)

    functions                      shift and go to state 60
    empty                          shift and go to state 20

state 51

    (115) functions -> FUNCTION CHAR functions1 funcend . functions
    (112) functions -> . FUNCTION VOID functions1 funcend functions
    (113) functions -> . FUNCTION INT functions1 funcend functions
    (114) functions -> . FUNCTION FLOAT functions1 funcend functions
    (115) functions -> . FUNCTION CHAR functions1 funcend functions
    (116) functions -> . empty
    (132) empty -> .

    FUNCTION        shift and go to state 19
    PRINCIPAL       reduce using rule 132 (empty -> .)
    $end            reduce using rule 132 (empty -> .)

    functions                      shift and go to state 61
    empty                          shift and go to state 20

state 52

    (98) vars1 -> vars1 typing COLON vars2 SEMICOLON . addVar
    (105) addVar -> .

    INT             reduce using rule 105 (addVar -> .)
    CHAR            reduce using rule 105 (addVar -> .)
    FLOAT           reduce using rule 105 (addVar -> .)
    FUNCTION        reduce using rule 105 (addVar -> .)
    PRINCIPAL       reduce using rule 105 (addVar -> .)
    $end            reduce using rule 105 (addVar -> .)
    ID              reduce using rule 105 (addVar -> .)
    READ            reduce using rule 105 (addVar -> .)
    WRITE           reduce using rule 105 (addVar -> .)
    IF              reduce using rule 105 (addVar -> .)
    WHILE           reduce using rule 105 (addVar -> .)
    FOR             reduce using rule 105 (addVar -> .)
    RETURN          reduce using rule 105 (addVar -> .)
    RIGHTBR         reduce using rule 105 (addVar -> .)
    LEFTBR          reduce using rule 105 (addVar -> .)

    addVar                         shift and go to state 62

state 53

    (101) vars2 -> ID array .
    (103) vars2 -> ID array . COMMA vars2 addVar

    SEMICOLON       reduce using rule 101 (vars2 -> ID array .)
    COMMA           shift and go to state 63


state 54

    (102) vars2 -> ID COMMA . vars2 addVar
    (100) vars2 -> . ID
    (101) vars2 -> . ID array
    (102) vars2 -> . ID COMMA vars2 addVar
    (103) vars2 -> . ID array COMMA vars2 addVar
    (104) vars2 -> . empty
    (132) empty -> .

    ID              shift and go to state 44
    SEMICOLON       reduce using rule 132 (empty -> .)

    vars2                          shift and go to state 64
    empty                          shift and go to state 45

state 55

    (110) array -> LEFTSQR . exp RIGHTSQR
    (111) array -> LEFTSQR . CTEINT RIGHTSQR
    (62) exp -> . andexp quador
    (63) exp -> . andexp quador OR operatorhandler andexp
    (65) andexp -> . boolexp quadand
    (66) andexp -> . boolexp quadand AND operatorhandler boolexp
    (68) boolexp -> . arithexp
    (69) boolexp -> . boolexp1 arithexp
    (76) arithexp -> . geoexp
    (77) arithexp -> . geoexp PLUS operatorhandler geoexp quadarith
    (78) arithexp -> . geoexp REST operatorhandler geoexp quadarith
    (70) boolexp1 -> . arithexp LESSER operatorhandler arithexp quadbool
    (71) boolexp1 -> . arithexp LESSERAND operatorhandler arithexp quadbool
    (72) boolexp1 -> . arithexp GREATER operatorhandler arithexp quadbool
    (73) boolexp1 -> . arithexp GREATERAND operatorhandler arithexp quadbool
    (74) boolexp1 -> . arithexp NOTSAME operatorhandler arithexp quadbool
    (80) geoexp -> . assignedexp
    (81) geoexp -> . assignedexp TIMES operatorhandler assignedexp quadgeo
    (82) geoexp -> . assignedexp DIVIDE operatorhandler assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (132) empty -> .

    CTEINT          shift and go to state 66
    ID              shift and go to state 73
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)
    LESSER          reduce using rule 132 (empty -> .)
    LESSERAND       reduce using rule 132 (empty -> .)
    GREATER         reduce using rule 132 (empty -> .)
    GREATERAND      reduce using rule 132 (empty -> .)
    NOTSAME         reduce using rule 132 (empty -> .)
    AND             reduce using rule 132 (empty -> .)
    OR              reduce using rule 132 (empty -> .)
    RIGHTSQR        reduce using rule 132 (empty -> .)

    exp                            shift and go to state 65
    andexp                         shift and go to state 67
    boolexp                        shift and go to state 68
    arithexp                       shift and go to state 69
    boolexp1                       shift and go to state 70
    geoexp                         shift and go to state 71
    assignedexp                    shift and go to state 72
    callFunction                   shift and go to state 77
    empty                          shift and go to state 79

state 56

    (7) principal -> PRINCIPAL LEFTPAR storefunct RIGHTPAR LEFTBR vars . statutes RIGHTBR
    (10) statutes -> . assign SEMICOLON statutes
    (11) statutes -> . callFunction SEMICOLON statutes
    (12) statutes -> . reading statutes SEMICOLON statutes
    (13) statutes -> . writing statutes SEMICOLON statutes
    (14) statutes -> . if statutes
    (15) statutes -> . while statutes
    (16) statutes -> . for statutes
    (17) statutes -> . return statutes
    (18) statutes -> . empty
    (19) assign -> . ID idgetter EQUAL operatorhandler exp assignquad
    (20) assign -> . ID idgetter array EQUAL operatorhandler exp assignquad
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (34) reading -> . READ auxreading LEFTPAR reading1 RIGHTPAR
    (41) writing -> . WRITE auxwriting LEFTPAR writing1 RIGHTPAR
    (49) if -> . IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif
    (59) while -> . WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop
    (56) for -> . FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop
    (130) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (131) return -> . RETURN LEFTPAR exp RIGHTPAR
    (132) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    IF              shift and go to state 93
    WHILE           shift and go to state 94
    FOR             shift and go to state 95
    RETURN          shift and go to state 96
    RIGHTBR         reduce using rule 132 (empty -> .)

    statutes                       shift and go to state 80
    assign                         shift and go to state 81
    callFunction                   shift and go to state 82
    reading                        shift and go to state 83
    writing                        shift and go to state 84
    if                             shift and go to state 85
    while                          shift and go to state 86
    for                            shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 57

    (112) functions -> FUNCTION VOID functions1 funcend functions .

    PRINCIPAL       reduce using rule 112 (functions -> FUNCTION VOID functions1 funcend functions .)
    $end            reduce using rule 112 (functions -> FUNCTION VOID functions1 funcend functions .)


state 58

    (117) functions1 -> ID storefunct LEFTPAR . args RIGHTPAR vars LEFTBR setaddstart statutes RIGHTBR
    (120) args -> . args1
    (121) args -> . empty
    (122) args1 -> . INT saveTypeofVar COLON ID mulParam nextParam
    (123) args1 -> . FLOAT saveTypeofVar COLON ID mulParam nextParam
    (124) args1 -> . CHAR saveTypeofVar COLON ID mulParam nextParam
    (132) empty -> .

    INT             shift and go to state 100
    FLOAT           shift and go to state 101
    CHAR            shift and go to state 102
    RIGHTPAR        reduce using rule 132 (empty -> .)

    args                           shift and go to state 97
    args1                          shift and go to state 98
    empty                          shift and go to state 99

state 59

    (113) functions -> FUNCTION INT functions1 funcend functions .

    PRINCIPAL       reduce using rule 113 (functions -> FUNCTION INT functions1 funcend functions .)
    $end            reduce using rule 113 (functions -> FUNCTION INT functions1 funcend functions .)


state 60

    (114) functions -> FUNCTION FLOAT functions1 funcend functions .

    PRINCIPAL       reduce using rule 114 (functions -> FUNCTION FLOAT functions1 funcend functions .)
    $end            reduce using rule 114 (functions -> FUNCTION FLOAT functions1 funcend functions .)


state 61

    (115) functions -> FUNCTION CHAR functions1 funcend functions .

    PRINCIPAL       reduce using rule 115 (functions -> FUNCTION CHAR functions1 funcend functions .)
    $end            reduce using rule 115 (functions -> FUNCTION CHAR functions1 funcend functions .)


state 62

    (98) vars1 -> vars1 typing COLON vars2 SEMICOLON addVar .

    INT             reduce using rule 98 (vars1 -> vars1 typing COLON vars2 SEMICOLON addVar .)
    CHAR            reduce using rule 98 (vars1 -> vars1 typing COLON vars2 SEMICOLON addVar .)
    FLOAT           reduce using rule 98 (vars1 -> vars1 typing COLON vars2 SEMICOLON addVar .)
    FUNCTION        reduce using rule 98 (vars1 -> vars1 typing COLON vars2 SEMICOLON addVar .)
    PRINCIPAL       reduce using rule 98 (vars1 -> vars1 typing COLON vars2 SEMICOLON addVar .)
    $end            reduce using rule 98 (vars1 -> vars1 typing COLON vars2 SEMICOLON addVar .)
    ID              reduce using rule 98 (vars1 -> vars1 typing COLON vars2 SEMICOLON addVar .)
    READ            reduce using rule 98 (vars1 -> vars1 typing COLON vars2 SEMICOLON addVar .)
    WRITE           reduce using rule 98 (vars1 -> vars1 typing COLON vars2 SEMICOLON addVar .)
    IF              reduce using rule 98 (vars1 -> vars1 typing COLON vars2 SEMICOLON addVar .)
    WHILE           reduce using rule 98 (vars1 -> vars1 typing COLON vars2 SEMICOLON addVar .)
    FOR             reduce using rule 98 (vars1 -> vars1 typing COLON vars2 SEMICOLON addVar .)
    RETURN          reduce using rule 98 (vars1 -> vars1 typing COLON vars2 SEMICOLON addVar .)
    RIGHTBR         reduce using rule 98 (vars1 -> vars1 typing COLON vars2 SEMICOLON addVar .)
    LEFTBR          reduce using rule 98 (vars1 -> vars1 typing COLON vars2 SEMICOLON addVar .)


state 63

    (103) vars2 -> ID array COMMA . vars2 addVar
    (100) vars2 -> . ID
    (101) vars2 -> . ID array
    (102) vars2 -> . ID COMMA vars2 addVar
    (103) vars2 -> . ID array COMMA vars2 addVar
    (104) vars2 -> . empty
    (132) empty -> .

    ID              shift and go to state 44
    SEMICOLON       reduce using rule 132 (empty -> .)

    vars2                          shift and go to state 103
    empty                          shift and go to state 45

state 64

    (102) vars2 -> ID COMMA vars2 . addVar
    (105) addVar -> .

    SEMICOLON       reduce using rule 105 (addVar -> .)

    addVar                         shift and go to state 104

state 65

    (110) array -> LEFTSQR exp . RIGHTSQR

    RIGHTSQR        shift and go to state 105


state 66

    (111) array -> LEFTSQR CTEINT . RIGHTSQR
    (85) assignedexp -> CTEINT . cteaux
    (93) cteaux -> .

  ! shift/reduce conflict for RIGHTSQR resolved as shift
    RIGHTSQR        shift and go to state 106
    TIMES           reduce using rule 93 (cteaux -> .)
    DIVIDE          reduce using rule 93 (cteaux -> .)
    PLUS            reduce using rule 93 (cteaux -> .)
    REST            reduce using rule 93 (cteaux -> .)
    LESSER          reduce using rule 93 (cteaux -> .)
    LESSERAND       reduce using rule 93 (cteaux -> .)
    GREATER         reduce using rule 93 (cteaux -> .)
    GREATERAND      reduce using rule 93 (cteaux -> .)
    NOTSAME         reduce using rule 93 (cteaux -> .)
    AND             reduce using rule 93 (cteaux -> .)
    OR              reduce using rule 93 (cteaux -> .)

  ! RIGHTSQR        [ reduce using rule 93 (cteaux -> .) ]

    cteaux                         shift and go to state 107

state 67

    (62) exp -> andexp . quador
    (63) exp -> andexp . quador OR operatorhandler andexp
    (64) quador -> .

    OR              reduce using rule 64 (quador -> .)
    RIGHTSQR        reduce using rule 64 (quador -> .)
    RIGHTPAR        reduce using rule 64 (quador -> .)
    COMMA           reduce using rule 64 (quador -> .)
    SEMICOLON       reduce using rule 64 (quador -> .)
    TO              reduce using rule 64 (quador -> .)

    quador                         shift and go to state 108

state 68

    (65) andexp -> boolexp . quadand
    (66) andexp -> boolexp . quadand AND operatorhandler boolexp
    (67) quadand -> .

    AND             reduce using rule 67 (quadand -> .)
    OR              reduce using rule 67 (quadand -> .)
    RIGHTSQR        reduce using rule 67 (quadand -> .)
    RIGHTPAR        reduce using rule 67 (quadand -> .)
    COMMA           reduce using rule 67 (quadand -> .)
    SEMICOLON       reduce using rule 67 (quadand -> .)
    TO              reduce using rule 67 (quadand -> .)

    quadand                        shift and go to state 109

state 69

    (68) boolexp -> arithexp .
    (70) boolexp1 -> arithexp . LESSER operatorhandler arithexp quadbool
    (71) boolexp1 -> arithexp . LESSERAND operatorhandler arithexp quadbool
    (72) boolexp1 -> arithexp . GREATER operatorhandler arithexp quadbool
    (73) boolexp1 -> arithexp . GREATERAND operatorhandler arithexp quadbool
    (74) boolexp1 -> arithexp . NOTSAME operatorhandler arithexp quadbool

    AND             reduce using rule 68 (boolexp -> arithexp .)
    OR              reduce using rule 68 (boolexp -> arithexp .)
    RIGHTSQR        reduce using rule 68 (boolexp -> arithexp .)
    RIGHTPAR        reduce using rule 68 (boolexp -> arithexp .)
    COMMA           reduce using rule 68 (boolexp -> arithexp .)
    SEMICOLON       reduce using rule 68 (boolexp -> arithexp .)
    TO              reduce using rule 68 (boolexp -> arithexp .)
    LESSER          shift and go to state 110
    LESSERAND       shift and go to state 111
    GREATER         shift and go to state 112
    GREATERAND      shift and go to state 113
    NOTSAME         shift and go to state 114


state 70

    (69) boolexp -> boolexp1 . arithexp
    (76) arithexp -> . geoexp
    (77) arithexp -> . geoexp PLUS operatorhandler geoexp quadarith
    (78) arithexp -> . geoexp REST operatorhandler geoexp quadarith
    (80) geoexp -> . assignedexp
    (81) geoexp -> . assignedexp TIMES operatorhandler assignedexp quadgeo
    (82) geoexp -> . assignedexp DIVIDE operatorhandler assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (132) empty -> .

    ID              shift and go to state 73
    CTEINT          shift and go to state 116
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)
    AND             reduce using rule 132 (empty -> .)
    OR              reduce using rule 132 (empty -> .)
    RIGHTSQR        reduce using rule 132 (empty -> .)
    RIGHTPAR        reduce using rule 132 (empty -> .)
    COMMA           reduce using rule 132 (empty -> .)
    SEMICOLON       reduce using rule 132 (empty -> .)
    TO              reduce using rule 132 (empty -> .)

    arithexp                       shift and go to state 115
    geoexp                         shift and go to state 71
    assignedexp                    shift and go to state 72
    callFunction                   shift and go to state 77
    empty                          shift and go to state 79

state 71

    (76) arithexp -> geoexp .
    (77) arithexp -> geoexp . PLUS operatorhandler geoexp quadarith
    (78) arithexp -> geoexp . REST operatorhandler geoexp quadarith

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for REST resolved as shift
    LESSER          reduce using rule 76 (arithexp -> geoexp .)
    LESSERAND       reduce using rule 76 (arithexp -> geoexp .)
    GREATER         reduce using rule 76 (arithexp -> geoexp .)
    GREATERAND      reduce using rule 76 (arithexp -> geoexp .)
    NOTSAME         reduce using rule 76 (arithexp -> geoexp .)
    AND             reduce using rule 76 (arithexp -> geoexp .)
    OR              reduce using rule 76 (arithexp -> geoexp .)
    RIGHTSQR        reduce using rule 76 (arithexp -> geoexp .)
    RIGHTPAR        reduce using rule 76 (arithexp -> geoexp .)
    COMMA           reduce using rule 76 (arithexp -> geoexp .)
    SEMICOLON       reduce using rule 76 (arithexp -> geoexp .)
    TO              reduce using rule 76 (arithexp -> geoexp .)
    ID              reduce using rule 76 (arithexp -> geoexp .)
    CTEINT          reduce using rule 76 (arithexp -> geoexp .)
    CTEFLOAT        reduce using rule 76 (arithexp -> geoexp .)
    CTECHAR         reduce using rule 76 (arithexp -> geoexp .)
    CTESTRING       reduce using rule 76 (arithexp -> geoexp .)
    LEFTPAR         reduce using rule 76 (arithexp -> geoexp .)
    TIMES           reduce using rule 76 (arithexp -> geoexp .)
    DIVIDE          reduce using rule 76 (arithexp -> geoexp .)
    PLUS            shift and go to state 117
    REST            shift and go to state 118

  ! PLUS            [ reduce using rule 76 (arithexp -> geoexp .) ]
  ! REST            [ reduce using rule 76 (arithexp -> geoexp .) ]


state 72

    (80) geoexp -> assignedexp .
    (81) geoexp -> assignedexp . TIMES operatorhandler assignedexp quadgeo
    (82) geoexp -> assignedexp . DIVIDE operatorhandler assignedexp quadgeo

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    PLUS            reduce using rule 80 (geoexp -> assignedexp .)
    REST            reduce using rule 80 (geoexp -> assignedexp .)
    LESSER          reduce using rule 80 (geoexp -> assignedexp .)
    LESSERAND       reduce using rule 80 (geoexp -> assignedexp .)
    GREATER         reduce using rule 80 (geoexp -> assignedexp .)
    GREATERAND      reduce using rule 80 (geoexp -> assignedexp .)
    NOTSAME         reduce using rule 80 (geoexp -> assignedexp .)
    AND             reduce using rule 80 (geoexp -> assignedexp .)
    OR              reduce using rule 80 (geoexp -> assignedexp .)
    RIGHTSQR        reduce using rule 80 (geoexp -> assignedexp .)
    RIGHTPAR        reduce using rule 80 (geoexp -> assignedexp .)
    COMMA           reduce using rule 80 (geoexp -> assignedexp .)
    SEMICOLON       reduce using rule 80 (geoexp -> assignedexp .)
    TO              reduce using rule 80 (geoexp -> assignedexp .)
    ID              reduce using rule 80 (geoexp -> assignedexp .)
    CTEINT          reduce using rule 80 (geoexp -> assignedexp .)
    CTEFLOAT        reduce using rule 80 (geoexp -> assignedexp .)
    CTECHAR         reduce using rule 80 (geoexp -> assignedexp .)
    CTESTRING       reduce using rule 80 (geoexp -> assignedexp .)
    LEFTPAR         reduce using rule 80 (geoexp -> assignedexp .)
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120

  ! TIMES           [ reduce using rule 80 (geoexp -> assignedexp .) ]
  ! DIVIDE          [ reduce using rule 80 (geoexp -> assignedexp .) ]


state 73

    (84) assignedexp -> ID . idgetter
    (91) assignedexp -> ID . array idgetterarray
    (24) callFunction -> ID . checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (21) idgetter -> .
    (110) array -> . LEFTSQR exp RIGHTSQR
    (111) array -> . LEFTSQR CTEINT RIGHTSQR
    (25) checkid -> .

  ! reduce/reduce conflict for LEFTPAR resolved using rule 21 (idgetter -> .)
    TIMES           reduce using rule 21 (idgetter -> .)
    DIVIDE          reduce using rule 21 (idgetter -> .)
    PLUS            reduce using rule 21 (idgetter -> .)
    REST            reduce using rule 21 (idgetter -> .)
    LESSER          reduce using rule 21 (idgetter -> .)
    LESSERAND       reduce using rule 21 (idgetter -> .)
    GREATER         reduce using rule 21 (idgetter -> .)
    GREATERAND      reduce using rule 21 (idgetter -> .)
    NOTSAME         reduce using rule 21 (idgetter -> .)
    AND             reduce using rule 21 (idgetter -> .)
    OR              reduce using rule 21 (idgetter -> .)
    RIGHTSQR        reduce using rule 21 (idgetter -> .)
    RIGHTPAR        reduce using rule 21 (idgetter -> .)
    COMMA           reduce using rule 21 (idgetter -> .)
    SEMICOLON       reduce using rule 21 (idgetter -> .)
    TO              reduce using rule 21 (idgetter -> .)
    ID              reduce using rule 21 (idgetter -> .)
    CTEINT          reduce using rule 21 (idgetter -> .)
    CTEFLOAT        reduce using rule 21 (idgetter -> .)
    CTECHAR         reduce using rule 21 (idgetter -> .)
    CTESTRING       reduce using rule 21 (idgetter -> .)
    LEFTPAR         reduce using rule 21 (idgetter -> .)
    LEFTSQR         shift and go to state 55

  ! LEFTPAR         [ reduce using rule 25 (checkid -> .) ]

    idgetter                       shift and go to state 121
    array                          shift and go to state 122
    checkid                        shift and go to state 123

state 74

    (86) assignedexp -> CTEFLOAT . cteaux
    (93) cteaux -> .

    TIMES           reduce using rule 93 (cteaux -> .)
    DIVIDE          reduce using rule 93 (cteaux -> .)
    PLUS            reduce using rule 93 (cteaux -> .)
    REST            reduce using rule 93 (cteaux -> .)
    LESSER          reduce using rule 93 (cteaux -> .)
    LESSERAND       reduce using rule 93 (cteaux -> .)
    GREATER         reduce using rule 93 (cteaux -> .)
    GREATERAND      reduce using rule 93 (cteaux -> .)
    NOTSAME         reduce using rule 93 (cteaux -> .)
    AND             reduce using rule 93 (cteaux -> .)
    OR              reduce using rule 93 (cteaux -> .)
    RIGHTSQR        reduce using rule 93 (cteaux -> .)
    RIGHTPAR        reduce using rule 93 (cteaux -> .)
    COMMA           reduce using rule 93 (cteaux -> .)
    SEMICOLON       reduce using rule 93 (cteaux -> .)
    TO              reduce using rule 93 (cteaux -> .)
    ID              reduce using rule 93 (cteaux -> .)
    CTEINT          reduce using rule 93 (cteaux -> .)
    CTEFLOAT        reduce using rule 93 (cteaux -> .)
    CTECHAR         reduce using rule 93 (cteaux -> .)
    CTESTRING       reduce using rule 93 (cteaux -> .)
    LEFTPAR         reduce using rule 93 (cteaux -> .)

    cteaux                         shift and go to state 124

state 75

    (87) assignedexp -> CTECHAR . cteaux
    (93) cteaux -> .

    TIMES           reduce using rule 93 (cteaux -> .)
    DIVIDE          reduce using rule 93 (cteaux -> .)
    PLUS            reduce using rule 93 (cteaux -> .)
    REST            reduce using rule 93 (cteaux -> .)
    LESSER          reduce using rule 93 (cteaux -> .)
    LESSERAND       reduce using rule 93 (cteaux -> .)
    GREATER         reduce using rule 93 (cteaux -> .)
    GREATERAND      reduce using rule 93 (cteaux -> .)
    NOTSAME         reduce using rule 93 (cteaux -> .)
    AND             reduce using rule 93 (cteaux -> .)
    OR              reduce using rule 93 (cteaux -> .)
    RIGHTSQR        reduce using rule 93 (cteaux -> .)
    RIGHTPAR        reduce using rule 93 (cteaux -> .)
    COMMA           reduce using rule 93 (cteaux -> .)
    SEMICOLON       reduce using rule 93 (cteaux -> .)
    TO              reduce using rule 93 (cteaux -> .)
    ID              reduce using rule 93 (cteaux -> .)
    CTEINT          reduce using rule 93 (cteaux -> .)
    CTEFLOAT        reduce using rule 93 (cteaux -> .)
    CTECHAR         reduce using rule 93 (cteaux -> .)
    CTESTRING       reduce using rule 93 (cteaux -> .)
    LEFTPAR         reduce using rule 93 (cteaux -> .)

    cteaux                         shift and go to state 125

state 76

    (88) assignedexp -> CTESTRING . cteaux
    (93) cteaux -> .

    TIMES           reduce using rule 93 (cteaux -> .)
    DIVIDE          reduce using rule 93 (cteaux -> .)
    PLUS            reduce using rule 93 (cteaux -> .)
    REST            reduce using rule 93 (cteaux -> .)
    LESSER          reduce using rule 93 (cteaux -> .)
    LESSERAND       reduce using rule 93 (cteaux -> .)
    GREATER         reduce using rule 93 (cteaux -> .)
    GREATERAND      reduce using rule 93 (cteaux -> .)
    NOTSAME         reduce using rule 93 (cteaux -> .)
    AND             reduce using rule 93 (cteaux -> .)
    OR              reduce using rule 93 (cteaux -> .)
    RIGHTSQR        reduce using rule 93 (cteaux -> .)
    RIGHTPAR        reduce using rule 93 (cteaux -> .)
    COMMA           reduce using rule 93 (cteaux -> .)
    SEMICOLON       reduce using rule 93 (cteaux -> .)
    TO              reduce using rule 93 (cteaux -> .)
    ID              reduce using rule 93 (cteaux -> .)
    CTEINT          reduce using rule 93 (cteaux -> .)
    CTEFLOAT        reduce using rule 93 (cteaux -> .)
    CTECHAR         reduce using rule 93 (cteaux -> .)
    CTESTRING       reduce using rule 93 (cteaux -> .)
    LEFTPAR         reduce using rule 93 (cteaux -> .)

    cteaux                         shift and go to state 126

state 77

    (89) assignedexp -> callFunction .

    TIMES           reduce using rule 89 (assignedexp -> callFunction .)
    DIVIDE          reduce using rule 89 (assignedexp -> callFunction .)
    PLUS            reduce using rule 89 (assignedexp -> callFunction .)
    REST            reduce using rule 89 (assignedexp -> callFunction .)
    LESSER          reduce using rule 89 (assignedexp -> callFunction .)
    LESSERAND       reduce using rule 89 (assignedexp -> callFunction .)
    GREATER         reduce using rule 89 (assignedexp -> callFunction .)
    GREATERAND      reduce using rule 89 (assignedexp -> callFunction .)
    NOTSAME         reduce using rule 89 (assignedexp -> callFunction .)
    AND             reduce using rule 89 (assignedexp -> callFunction .)
    OR              reduce using rule 89 (assignedexp -> callFunction .)
    RIGHTSQR        reduce using rule 89 (assignedexp -> callFunction .)
    RIGHTPAR        reduce using rule 89 (assignedexp -> callFunction .)
    COMMA           reduce using rule 89 (assignedexp -> callFunction .)
    SEMICOLON       reduce using rule 89 (assignedexp -> callFunction .)
    TO              reduce using rule 89 (assignedexp -> callFunction .)
    ID              reduce using rule 89 (assignedexp -> callFunction .)
    CTEINT          reduce using rule 89 (assignedexp -> callFunction .)
    CTEFLOAT        reduce using rule 89 (assignedexp -> callFunction .)
    CTECHAR         reduce using rule 89 (assignedexp -> callFunction .)
    CTESTRING       reduce using rule 89 (assignedexp -> callFunction .)
    LEFTPAR         reduce using rule 89 (assignedexp -> callFunction .)


state 78

    (90) assignedexp -> LEFTPAR . exp RIGHTPAR
    (62) exp -> . andexp quador
    (63) exp -> . andexp quador OR operatorhandler andexp
    (65) andexp -> . boolexp quadand
    (66) andexp -> . boolexp quadand AND operatorhandler boolexp
    (68) boolexp -> . arithexp
    (69) boolexp -> . boolexp1 arithexp
    (76) arithexp -> . geoexp
    (77) arithexp -> . geoexp PLUS operatorhandler geoexp quadarith
    (78) arithexp -> . geoexp REST operatorhandler geoexp quadarith
    (70) boolexp1 -> . arithexp LESSER operatorhandler arithexp quadbool
    (71) boolexp1 -> . arithexp LESSERAND operatorhandler arithexp quadbool
    (72) boolexp1 -> . arithexp GREATER operatorhandler arithexp quadbool
    (73) boolexp1 -> . arithexp GREATERAND operatorhandler arithexp quadbool
    (74) boolexp1 -> . arithexp NOTSAME operatorhandler arithexp quadbool
    (80) geoexp -> . assignedexp
    (81) geoexp -> . assignedexp TIMES operatorhandler assignedexp quadgeo
    (82) geoexp -> . assignedexp DIVIDE operatorhandler assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (132) empty -> .

    ID              shift and go to state 73
    CTEINT          shift and go to state 116
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)
    LESSER          reduce using rule 132 (empty -> .)
    LESSERAND       reduce using rule 132 (empty -> .)
    GREATER         reduce using rule 132 (empty -> .)
    GREATERAND      reduce using rule 132 (empty -> .)
    NOTSAME         reduce using rule 132 (empty -> .)
    AND             reduce using rule 132 (empty -> .)
    OR              reduce using rule 132 (empty -> .)
    RIGHTPAR        reduce using rule 132 (empty -> .)

    exp                            shift and go to state 127
    andexp                         shift and go to state 67
    boolexp                        shift and go to state 68
    arithexp                       shift and go to state 69
    boolexp1                       shift and go to state 70
    geoexp                         shift and go to state 71
    assignedexp                    shift and go to state 72
    callFunction                   shift and go to state 77
    empty                          shift and go to state 79

state 79

    (92) assignedexp -> empty .

    TIMES           reduce using rule 92 (assignedexp -> empty .)
    DIVIDE          reduce using rule 92 (assignedexp -> empty .)
    PLUS            reduce using rule 92 (assignedexp -> empty .)
    REST            reduce using rule 92 (assignedexp -> empty .)
    LESSER          reduce using rule 92 (assignedexp -> empty .)
    LESSERAND       reduce using rule 92 (assignedexp -> empty .)
    GREATER         reduce using rule 92 (assignedexp -> empty .)
    GREATERAND      reduce using rule 92 (assignedexp -> empty .)
    NOTSAME         reduce using rule 92 (assignedexp -> empty .)
    AND             reduce using rule 92 (assignedexp -> empty .)
    OR              reduce using rule 92 (assignedexp -> empty .)
    RIGHTSQR        reduce using rule 92 (assignedexp -> empty .)
    RIGHTPAR        reduce using rule 92 (assignedexp -> empty .)
    COMMA           reduce using rule 92 (assignedexp -> empty .)
    SEMICOLON       reduce using rule 92 (assignedexp -> empty .)
    TO              reduce using rule 92 (assignedexp -> empty .)
    ID              reduce using rule 92 (assignedexp -> empty .)
    CTEINT          reduce using rule 92 (assignedexp -> empty .)
    CTEFLOAT        reduce using rule 92 (assignedexp -> empty .)
    CTECHAR         reduce using rule 92 (assignedexp -> empty .)
    CTESTRING       reduce using rule 92 (assignedexp -> empty .)
    LEFTPAR         reduce using rule 92 (assignedexp -> empty .)


state 80

    (7) principal -> PRINCIPAL LEFTPAR storefunct RIGHTPAR LEFTBR vars statutes . RIGHTBR

    RIGHTBR         shift and go to state 128


state 81

    (10) statutes -> assign . SEMICOLON statutes

    SEMICOLON       shift and go to state 129


state 82

    (11) statutes -> callFunction . SEMICOLON statutes

    SEMICOLON       shift and go to state 130


state 83

    (12) statutes -> reading . statutes SEMICOLON statutes
    (10) statutes -> . assign SEMICOLON statutes
    (11) statutes -> . callFunction SEMICOLON statutes
    (12) statutes -> . reading statutes SEMICOLON statutes
    (13) statutes -> . writing statutes SEMICOLON statutes
    (14) statutes -> . if statutes
    (15) statutes -> . while statutes
    (16) statutes -> . for statutes
    (17) statutes -> . return statutes
    (18) statutes -> . empty
    (19) assign -> . ID idgetter EQUAL operatorhandler exp assignquad
    (20) assign -> . ID idgetter array EQUAL operatorhandler exp assignquad
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (34) reading -> . READ auxreading LEFTPAR reading1 RIGHTPAR
    (41) writing -> . WRITE auxwriting LEFTPAR writing1 RIGHTPAR
    (49) if -> . IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif
    (59) while -> . WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop
    (56) for -> . FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop
    (130) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (131) return -> . RETURN LEFTPAR exp RIGHTPAR
    (132) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    IF              shift and go to state 93
    WHILE           shift and go to state 94
    FOR             shift and go to state 95
    RETURN          shift and go to state 96
    SEMICOLON       reduce using rule 132 (empty -> .)

    reading                        shift and go to state 83
    statutes                       shift and go to state 131
    assign                         shift and go to state 81
    callFunction                   shift and go to state 82
    writing                        shift and go to state 84
    if                             shift and go to state 85
    while                          shift and go to state 86
    for                            shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 84

    (13) statutes -> writing . statutes SEMICOLON statutes
    (10) statutes -> . assign SEMICOLON statutes
    (11) statutes -> . callFunction SEMICOLON statutes
    (12) statutes -> . reading statutes SEMICOLON statutes
    (13) statutes -> . writing statutes SEMICOLON statutes
    (14) statutes -> . if statutes
    (15) statutes -> . while statutes
    (16) statutes -> . for statutes
    (17) statutes -> . return statutes
    (18) statutes -> . empty
    (19) assign -> . ID idgetter EQUAL operatorhandler exp assignquad
    (20) assign -> . ID idgetter array EQUAL operatorhandler exp assignquad
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (34) reading -> . READ auxreading LEFTPAR reading1 RIGHTPAR
    (41) writing -> . WRITE auxwriting LEFTPAR writing1 RIGHTPAR
    (49) if -> . IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif
    (59) while -> . WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop
    (56) for -> . FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop
    (130) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (131) return -> . RETURN LEFTPAR exp RIGHTPAR
    (132) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    IF              shift and go to state 93
    WHILE           shift and go to state 94
    FOR             shift and go to state 95
    RETURN          shift and go to state 96
    SEMICOLON       reduce using rule 132 (empty -> .)

    writing                        shift and go to state 84
    statutes                       shift and go to state 132
    assign                         shift and go to state 81
    callFunction                   shift and go to state 82
    reading                        shift and go to state 83
    if                             shift and go to state 85
    while                          shift and go to state 86
    for                            shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 85

    (14) statutes -> if . statutes
    (10) statutes -> . assign SEMICOLON statutes
    (11) statutes -> . callFunction SEMICOLON statutes
    (12) statutes -> . reading statutes SEMICOLON statutes
    (13) statutes -> . writing statutes SEMICOLON statutes
    (14) statutes -> . if statutes
    (15) statutes -> . while statutes
    (16) statutes -> . for statutes
    (17) statutes -> . return statutes
    (18) statutes -> . empty
    (19) assign -> . ID idgetter EQUAL operatorhandler exp assignquad
    (20) assign -> . ID idgetter array EQUAL operatorhandler exp assignquad
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (34) reading -> . READ auxreading LEFTPAR reading1 RIGHTPAR
    (41) writing -> . WRITE auxwriting LEFTPAR writing1 RIGHTPAR
    (49) if -> . IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif
    (59) while -> . WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop
    (56) for -> . FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop
    (130) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (131) return -> . RETURN LEFTPAR exp RIGHTPAR
    (132) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    IF              shift and go to state 93
    WHILE           shift and go to state 94
    FOR             shift and go to state 95
    RETURN          shift and go to state 96
    RIGHTBR         reduce using rule 132 (empty -> .)
    SEMICOLON       reduce using rule 132 (empty -> .)

    if                             shift and go to state 85
    statutes                       shift and go to state 133
    assign                         shift and go to state 81
    callFunction                   shift and go to state 82
    reading                        shift and go to state 83
    writing                        shift and go to state 84
    while                          shift and go to state 86
    for                            shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 86

    (15) statutes -> while . statutes
    (10) statutes -> . assign SEMICOLON statutes
    (11) statutes -> . callFunction SEMICOLON statutes
    (12) statutes -> . reading statutes SEMICOLON statutes
    (13) statutes -> . writing statutes SEMICOLON statutes
    (14) statutes -> . if statutes
    (15) statutes -> . while statutes
    (16) statutes -> . for statutes
    (17) statutes -> . return statutes
    (18) statutes -> . empty
    (19) assign -> . ID idgetter EQUAL operatorhandler exp assignquad
    (20) assign -> . ID idgetter array EQUAL operatorhandler exp assignquad
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (34) reading -> . READ auxreading LEFTPAR reading1 RIGHTPAR
    (41) writing -> . WRITE auxwriting LEFTPAR writing1 RIGHTPAR
    (49) if -> . IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif
    (59) while -> . WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop
    (56) for -> . FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop
    (130) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (131) return -> . RETURN LEFTPAR exp RIGHTPAR
    (132) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    IF              shift and go to state 93
    WHILE           shift and go to state 94
    FOR             shift and go to state 95
    RETURN          shift and go to state 96
    RIGHTBR         reduce using rule 132 (empty -> .)
    SEMICOLON       reduce using rule 132 (empty -> .)

    while                          shift and go to state 86
    statutes                       shift and go to state 134
    assign                         shift and go to state 81
    callFunction                   shift and go to state 82
    reading                        shift and go to state 83
    writing                        shift and go to state 84
    if                             shift and go to state 85
    for                            shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 87

    (16) statutes -> for . statutes
    (10) statutes -> . assign SEMICOLON statutes
    (11) statutes -> . callFunction SEMICOLON statutes
    (12) statutes -> . reading statutes SEMICOLON statutes
    (13) statutes -> . writing statutes SEMICOLON statutes
    (14) statutes -> . if statutes
    (15) statutes -> . while statutes
    (16) statutes -> . for statutes
    (17) statutes -> . return statutes
    (18) statutes -> . empty
    (19) assign -> . ID idgetter EQUAL operatorhandler exp assignquad
    (20) assign -> . ID idgetter array EQUAL operatorhandler exp assignquad
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (34) reading -> . READ auxreading LEFTPAR reading1 RIGHTPAR
    (41) writing -> . WRITE auxwriting LEFTPAR writing1 RIGHTPAR
    (49) if -> . IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif
    (59) while -> . WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop
    (56) for -> . FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop
    (130) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (131) return -> . RETURN LEFTPAR exp RIGHTPAR
    (132) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    IF              shift and go to state 93
    WHILE           shift and go to state 94
    FOR             shift and go to state 95
    RETURN          shift and go to state 96
    RIGHTBR         reduce using rule 132 (empty -> .)
    SEMICOLON       reduce using rule 132 (empty -> .)

    for                            shift and go to state 87
    statutes                       shift and go to state 135
    assign                         shift and go to state 81
    callFunction                   shift and go to state 82
    reading                        shift and go to state 83
    writing                        shift and go to state 84
    if                             shift and go to state 85
    while                          shift and go to state 86
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 88

    (17) statutes -> return . statutes
    (10) statutes -> . assign SEMICOLON statutes
    (11) statutes -> . callFunction SEMICOLON statutes
    (12) statutes -> . reading statutes SEMICOLON statutes
    (13) statutes -> . writing statutes SEMICOLON statutes
    (14) statutes -> . if statutes
    (15) statutes -> . while statutes
    (16) statutes -> . for statutes
    (17) statutes -> . return statutes
    (18) statutes -> . empty
    (19) assign -> . ID idgetter EQUAL operatorhandler exp assignquad
    (20) assign -> . ID idgetter array EQUAL operatorhandler exp assignquad
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (34) reading -> . READ auxreading LEFTPAR reading1 RIGHTPAR
    (41) writing -> . WRITE auxwriting LEFTPAR writing1 RIGHTPAR
    (49) if -> . IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif
    (59) while -> . WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop
    (56) for -> . FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop
    (130) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (131) return -> . RETURN LEFTPAR exp RIGHTPAR
    (132) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    IF              shift and go to state 93
    WHILE           shift and go to state 94
    FOR             shift and go to state 95
    RETURN          shift and go to state 96
    RIGHTBR         reduce using rule 132 (empty -> .)
    SEMICOLON       reduce using rule 132 (empty -> .)

    return                         shift and go to state 88
    statutes                       shift and go to state 136
    assign                         shift and go to state 81
    callFunction                   shift and go to state 82
    reading                        shift and go to state 83
    writing                        shift and go to state 84
    if                             shift and go to state 85
    while                          shift and go to state 86
    for                            shift and go to state 87
    empty                          shift and go to state 89

state 89

    (18) statutes -> empty .

    RIGHTBR         reduce using rule 18 (statutes -> empty .)
    SEMICOLON       reduce using rule 18 (statutes -> empty .)


state 90

    (19) assign -> ID . idgetter EQUAL operatorhandler exp assignquad
    (20) assign -> ID . idgetter array EQUAL operatorhandler exp assignquad
    (24) callFunction -> ID . checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (21) idgetter -> .
    (25) checkid -> .

    EQUAL           reduce using rule 21 (idgetter -> .)
    LEFTSQR         reduce using rule 21 (idgetter -> .)
    LEFTPAR         reduce using rule 25 (checkid -> .)

    idgetter                       shift and go to state 137
    checkid                        shift and go to state 123

state 91

    (34) reading -> READ . auxreading LEFTPAR reading1 RIGHTPAR
    (39) auxreading -> .

    LEFTPAR         reduce using rule 39 (auxreading -> .)

    auxreading                     shift and go to state 138

state 92

    (41) writing -> WRITE . auxwriting LEFTPAR writing1 RIGHTPAR
    (46) auxwriting -> .

    LEFTPAR         reduce using rule 46 (auxwriting -> .)

    auxwriting                     shift and go to state 139

state 93

    (49) if -> IF . LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif

    LEFTPAR         shift and go to state 140


state 94

    (59) while -> WHILE . auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop
    (60) auxwhile -> .

    LEFTPAR         reduce using rule 60 (auxwhile -> .)

    auxwhile                       shift and go to state 141

state 95

    (56) for -> FOR . auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop
    (57) auxfor -> .

    ID              reduce using rule 57 (auxfor -> .)

    auxfor                         shift and go to state 142

state 96

    (130) return -> RETURN . LEFTPAR exp RIGHTPAR SEMICOLON
    (131) return -> RETURN . LEFTPAR exp RIGHTPAR

    LEFTPAR         shift and go to state 143


state 97

    (117) functions1 -> ID storefunct LEFTPAR args . RIGHTPAR vars LEFTBR setaddstart statutes RIGHTBR

    RIGHTPAR        shift and go to state 144


state 98

    (120) args -> args1 .

    RIGHTPAR        reduce using rule 120 (args -> args1 .)


state 99

    (121) args -> empty .

    RIGHTPAR        reduce using rule 121 (args -> empty .)


state 100

    (122) args1 -> INT . saveTypeofVar COLON ID mulParam nextParam
    (109) saveTypeofVar -> .

    COLON           reduce using rule 109 (saveTypeofVar -> .)

    saveTypeofVar                  shift and go to state 145

state 101

    (123) args1 -> FLOAT . saveTypeofVar COLON ID mulParam nextParam
    (109) saveTypeofVar -> .

    COLON           reduce using rule 109 (saveTypeofVar -> .)

    saveTypeofVar                  shift and go to state 146

state 102

    (124) args1 -> CHAR . saveTypeofVar COLON ID mulParam nextParam
    (109) saveTypeofVar -> .

    COLON           reduce using rule 109 (saveTypeofVar -> .)

    saveTypeofVar                  shift and go to state 147

state 103

    (103) vars2 -> ID array COMMA vars2 . addVar
    (105) addVar -> .

    SEMICOLON       reduce using rule 105 (addVar -> .)

    addVar                         shift and go to state 148

state 104

    (102) vars2 -> ID COMMA vars2 addVar .

    SEMICOLON       reduce using rule 102 (vars2 -> ID COMMA vars2 addVar .)


state 105

    (110) array -> LEFTSQR exp RIGHTSQR .

    COMMA           reduce using rule 110 (array -> LEFTSQR exp RIGHTSQR .)
    SEMICOLON       reduce using rule 110 (array -> LEFTSQR exp RIGHTSQR .)
    TIMES           reduce using rule 110 (array -> LEFTSQR exp RIGHTSQR .)
    DIVIDE          reduce using rule 110 (array -> LEFTSQR exp RIGHTSQR .)
    PLUS            reduce using rule 110 (array -> LEFTSQR exp RIGHTSQR .)
    REST            reduce using rule 110 (array -> LEFTSQR exp RIGHTSQR .)
    LESSER          reduce using rule 110 (array -> LEFTSQR exp RIGHTSQR .)
    LESSERAND       reduce using rule 110 (array -> LEFTSQR exp RIGHTSQR .)
    GREATER         reduce using rule 110 (array -> LEFTSQR exp RIGHTSQR .)
    GREATERAND      reduce using rule 110 (array -> LEFTSQR exp RIGHTSQR .)
    NOTSAME         reduce using rule 110 (array -> LEFTSQR exp RIGHTSQR .)
    AND             reduce using rule 110 (array -> LEFTSQR exp RIGHTSQR .)
    OR              reduce using rule 110 (array -> LEFTSQR exp RIGHTSQR .)
    RIGHTSQR        reduce using rule 110 (array -> LEFTSQR exp RIGHTSQR .)
    RIGHTPAR        reduce using rule 110 (array -> LEFTSQR exp RIGHTSQR .)
    TO              reduce using rule 110 (array -> LEFTSQR exp RIGHTSQR .)
    ID              reduce using rule 110 (array -> LEFTSQR exp RIGHTSQR .)
    CTEINT          reduce using rule 110 (array -> LEFTSQR exp RIGHTSQR .)
    CTEFLOAT        reduce using rule 110 (array -> LEFTSQR exp RIGHTSQR .)
    CTECHAR         reduce using rule 110 (array -> LEFTSQR exp RIGHTSQR .)
    CTESTRING       reduce using rule 110 (array -> LEFTSQR exp RIGHTSQR .)
    LEFTPAR         reduce using rule 110 (array -> LEFTSQR exp RIGHTSQR .)
    EQUAL           reduce using rule 110 (array -> LEFTSQR exp RIGHTSQR .)


state 106

    (111) array -> LEFTSQR CTEINT RIGHTSQR .

    COMMA           reduce using rule 111 (array -> LEFTSQR CTEINT RIGHTSQR .)
    SEMICOLON       reduce using rule 111 (array -> LEFTSQR CTEINT RIGHTSQR .)
    TIMES           reduce using rule 111 (array -> LEFTSQR CTEINT RIGHTSQR .)
    DIVIDE          reduce using rule 111 (array -> LEFTSQR CTEINT RIGHTSQR .)
    PLUS            reduce using rule 111 (array -> LEFTSQR CTEINT RIGHTSQR .)
    REST            reduce using rule 111 (array -> LEFTSQR CTEINT RIGHTSQR .)
    LESSER          reduce using rule 111 (array -> LEFTSQR CTEINT RIGHTSQR .)
    LESSERAND       reduce using rule 111 (array -> LEFTSQR CTEINT RIGHTSQR .)
    GREATER         reduce using rule 111 (array -> LEFTSQR CTEINT RIGHTSQR .)
    GREATERAND      reduce using rule 111 (array -> LEFTSQR CTEINT RIGHTSQR .)
    NOTSAME         reduce using rule 111 (array -> LEFTSQR CTEINT RIGHTSQR .)
    AND             reduce using rule 111 (array -> LEFTSQR CTEINT RIGHTSQR .)
    OR              reduce using rule 111 (array -> LEFTSQR CTEINT RIGHTSQR .)
    RIGHTSQR        reduce using rule 111 (array -> LEFTSQR CTEINT RIGHTSQR .)
    RIGHTPAR        reduce using rule 111 (array -> LEFTSQR CTEINT RIGHTSQR .)
    TO              reduce using rule 111 (array -> LEFTSQR CTEINT RIGHTSQR .)
    ID              reduce using rule 111 (array -> LEFTSQR CTEINT RIGHTSQR .)
    CTEINT          reduce using rule 111 (array -> LEFTSQR CTEINT RIGHTSQR .)
    CTEFLOAT        reduce using rule 111 (array -> LEFTSQR CTEINT RIGHTSQR .)
    CTECHAR         reduce using rule 111 (array -> LEFTSQR CTEINT RIGHTSQR .)
    CTESTRING       reduce using rule 111 (array -> LEFTSQR CTEINT RIGHTSQR .)
    LEFTPAR         reduce using rule 111 (array -> LEFTSQR CTEINT RIGHTSQR .)
    EQUAL           reduce using rule 111 (array -> LEFTSQR CTEINT RIGHTSQR .)


state 107

    (85) assignedexp -> CTEINT cteaux .

    TIMES           reduce using rule 85 (assignedexp -> CTEINT cteaux .)
    DIVIDE          reduce using rule 85 (assignedexp -> CTEINT cteaux .)
    PLUS            reduce using rule 85 (assignedexp -> CTEINT cteaux .)
    REST            reduce using rule 85 (assignedexp -> CTEINT cteaux .)
    LESSER          reduce using rule 85 (assignedexp -> CTEINT cteaux .)
    LESSERAND       reduce using rule 85 (assignedexp -> CTEINT cteaux .)
    GREATER         reduce using rule 85 (assignedexp -> CTEINT cteaux .)
    GREATERAND      reduce using rule 85 (assignedexp -> CTEINT cteaux .)
    NOTSAME         reduce using rule 85 (assignedexp -> CTEINT cteaux .)
    AND             reduce using rule 85 (assignedexp -> CTEINT cteaux .)
    OR              reduce using rule 85 (assignedexp -> CTEINT cteaux .)
    RIGHTSQR        reduce using rule 85 (assignedexp -> CTEINT cteaux .)
    RIGHTPAR        reduce using rule 85 (assignedexp -> CTEINT cteaux .)
    COMMA           reduce using rule 85 (assignedexp -> CTEINT cteaux .)
    SEMICOLON       reduce using rule 85 (assignedexp -> CTEINT cteaux .)
    TO              reduce using rule 85 (assignedexp -> CTEINT cteaux .)
    ID              reduce using rule 85 (assignedexp -> CTEINT cteaux .)
    CTEINT          reduce using rule 85 (assignedexp -> CTEINT cteaux .)
    CTEFLOAT        reduce using rule 85 (assignedexp -> CTEINT cteaux .)
    CTECHAR         reduce using rule 85 (assignedexp -> CTEINT cteaux .)
    CTESTRING       reduce using rule 85 (assignedexp -> CTEINT cteaux .)
    LEFTPAR         reduce using rule 85 (assignedexp -> CTEINT cteaux .)


state 108

    (62) exp -> andexp quador .
    (63) exp -> andexp quador . OR operatorhandler andexp

    RIGHTSQR        reduce using rule 62 (exp -> andexp quador .)
    RIGHTPAR        reduce using rule 62 (exp -> andexp quador .)
    COMMA           reduce using rule 62 (exp -> andexp quador .)
    SEMICOLON       reduce using rule 62 (exp -> andexp quador .)
    TO              reduce using rule 62 (exp -> andexp quador .)
    OR              shift and go to state 149


state 109

    (65) andexp -> boolexp quadand .
    (66) andexp -> boolexp quadand . AND operatorhandler boolexp

    OR              reduce using rule 65 (andexp -> boolexp quadand .)
    RIGHTSQR        reduce using rule 65 (andexp -> boolexp quadand .)
    RIGHTPAR        reduce using rule 65 (andexp -> boolexp quadand .)
    COMMA           reduce using rule 65 (andexp -> boolexp quadand .)
    SEMICOLON       reduce using rule 65 (andexp -> boolexp quadand .)
    TO              reduce using rule 65 (andexp -> boolexp quadand .)
    AND             shift and go to state 150


state 110

    (70) boolexp1 -> arithexp LESSER . operatorhandler arithexp quadbool
    (94) operatorhandler -> .

    ID              reduce using rule 94 (operatorhandler -> .)
    CTEINT          reduce using rule 94 (operatorhandler -> .)
    CTEFLOAT        reduce using rule 94 (operatorhandler -> .)
    CTECHAR         reduce using rule 94 (operatorhandler -> .)
    CTESTRING       reduce using rule 94 (operatorhandler -> .)
    LEFTPAR         reduce using rule 94 (operatorhandler -> .)
    PLUS            reduce using rule 94 (operatorhandler -> .)
    REST            reduce using rule 94 (operatorhandler -> .)
    TIMES           reduce using rule 94 (operatorhandler -> .)
    DIVIDE          reduce using rule 94 (operatorhandler -> .)
    AND             reduce using rule 94 (operatorhandler -> .)
    OR              reduce using rule 94 (operatorhandler -> .)
    RIGHTSQR        reduce using rule 94 (operatorhandler -> .)
    RIGHTPAR        reduce using rule 94 (operatorhandler -> .)
    COMMA           reduce using rule 94 (operatorhandler -> .)
    SEMICOLON       reduce using rule 94 (operatorhandler -> .)
    TO              reduce using rule 94 (operatorhandler -> .)

    operatorhandler                shift and go to state 151

state 111

    (71) boolexp1 -> arithexp LESSERAND . operatorhandler arithexp quadbool
    (94) operatorhandler -> .

    ID              reduce using rule 94 (operatorhandler -> .)
    CTEINT          reduce using rule 94 (operatorhandler -> .)
    CTEFLOAT        reduce using rule 94 (operatorhandler -> .)
    CTECHAR         reduce using rule 94 (operatorhandler -> .)
    CTESTRING       reduce using rule 94 (operatorhandler -> .)
    LEFTPAR         reduce using rule 94 (operatorhandler -> .)
    PLUS            reduce using rule 94 (operatorhandler -> .)
    REST            reduce using rule 94 (operatorhandler -> .)
    TIMES           reduce using rule 94 (operatorhandler -> .)
    DIVIDE          reduce using rule 94 (operatorhandler -> .)
    AND             reduce using rule 94 (operatorhandler -> .)
    OR              reduce using rule 94 (operatorhandler -> .)
    RIGHTSQR        reduce using rule 94 (operatorhandler -> .)
    RIGHTPAR        reduce using rule 94 (operatorhandler -> .)
    COMMA           reduce using rule 94 (operatorhandler -> .)
    SEMICOLON       reduce using rule 94 (operatorhandler -> .)
    TO              reduce using rule 94 (operatorhandler -> .)

    operatorhandler                shift and go to state 152

state 112

    (72) boolexp1 -> arithexp GREATER . operatorhandler arithexp quadbool
    (94) operatorhandler -> .

    ID              reduce using rule 94 (operatorhandler -> .)
    CTEINT          reduce using rule 94 (operatorhandler -> .)
    CTEFLOAT        reduce using rule 94 (operatorhandler -> .)
    CTECHAR         reduce using rule 94 (operatorhandler -> .)
    CTESTRING       reduce using rule 94 (operatorhandler -> .)
    LEFTPAR         reduce using rule 94 (operatorhandler -> .)
    PLUS            reduce using rule 94 (operatorhandler -> .)
    REST            reduce using rule 94 (operatorhandler -> .)
    TIMES           reduce using rule 94 (operatorhandler -> .)
    DIVIDE          reduce using rule 94 (operatorhandler -> .)
    AND             reduce using rule 94 (operatorhandler -> .)
    OR              reduce using rule 94 (operatorhandler -> .)
    RIGHTSQR        reduce using rule 94 (operatorhandler -> .)
    RIGHTPAR        reduce using rule 94 (operatorhandler -> .)
    COMMA           reduce using rule 94 (operatorhandler -> .)
    SEMICOLON       reduce using rule 94 (operatorhandler -> .)
    TO              reduce using rule 94 (operatorhandler -> .)

    operatorhandler                shift and go to state 153

state 113

    (73) boolexp1 -> arithexp GREATERAND . operatorhandler arithexp quadbool
    (94) operatorhandler -> .

    ID              reduce using rule 94 (operatorhandler -> .)
    CTEINT          reduce using rule 94 (operatorhandler -> .)
    CTEFLOAT        reduce using rule 94 (operatorhandler -> .)
    CTECHAR         reduce using rule 94 (operatorhandler -> .)
    CTESTRING       reduce using rule 94 (operatorhandler -> .)
    LEFTPAR         reduce using rule 94 (operatorhandler -> .)
    PLUS            reduce using rule 94 (operatorhandler -> .)
    REST            reduce using rule 94 (operatorhandler -> .)
    TIMES           reduce using rule 94 (operatorhandler -> .)
    DIVIDE          reduce using rule 94 (operatorhandler -> .)
    AND             reduce using rule 94 (operatorhandler -> .)
    OR              reduce using rule 94 (operatorhandler -> .)
    RIGHTSQR        reduce using rule 94 (operatorhandler -> .)
    RIGHTPAR        reduce using rule 94 (operatorhandler -> .)
    COMMA           reduce using rule 94 (operatorhandler -> .)
    SEMICOLON       reduce using rule 94 (operatorhandler -> .)
    TO              reduce using rule 94 (operatorhandler -> .)

    operatorhandler                shift and go to state 154

state 114

    (74) boolexp1 -> arithexp NOTSAME . operatorhandler arithexp quadbool
    (94) operatorhandler -> .

    ID              reduce using rule 94 (operatorhandler -> .)
    CTEINT          reduce using rule 94 (operatorhandler -> .)
    CTEFLOAT        reduce using rule 94 (operatorhandler -> .)
    CTECHAR         reduce using rule 94 (operatorhandler -> .)
    CTESTRING       reduce using rule 94 (operatorhandler -> .)
    LEFTPAR         reduce using rule 94 (operatorhandler -> .)
    PLUS            reduce using rule 94 (operatorhandler -> .)
    REST            reduce using rule 94 (operatorhandler -> .)
    TIMES           reduce using rule 94 (operatorhandler -> .)
    DIVIDE          reduce using rule 94 (operatorhandler -> .)
    AND             reduce using rule 94 (operatorhandler -> .)
    OR              reduce using rule 94 (operatorhandler -> .)
    RIGHTSQR        reduce using rule 94 (operatorhandler -> .)
    RIGHTPAR        reduce using rule 94 (operatorhandler -> .)
    COMMA           reduce using rule 94 (operatorhandler -> .)
    SEMICOLON       reduce using rule 94 (operatorhandler -> .)
    TO              reduce using rule 94 (operatorhandler -> .)

    operatorhandler                shift and go to state 155

state 115

    (69) boolexp -> boolexp1 arithexp .

    AND             reduce using rule 69 (boolexp -> boolexp1 arithexp .)
    OR              reduce using rule 69 (boolexp -> boolexp1 arithexp .)
    RIGHTSQR        reduce using rule 69 (boolexp -> boolexp1 arithexp .)
    RIGHTPAR        reduce using rule 69 (boolexp -> boolexp1 arithexp .)
    COMMA           reduce using rule 69 (boolexp -> boolexp1 arithexp .)
    SEMICOLON       reduce using rule 69 (boolexp -> boolexp1 arithexp .)
    TO              reduce using rule 69 (boolexp -> boolexp1 arithexp .)


state 116

    (85) assignedexp -> CTEINT . cteaux
    (93) cteaux -> .

    TIMES           reduce using rule 93 (cteaux -> .)
    DIVIDE          reduce using rule 93 (cteaux -> .)
    PLUS            reduce using rule 93 (cteaux -> .)
    REST            reduce using rule 93 (cteaux -> .)
    AND             reduce using rule 93 (cteaux -> .)
    OR              reduce using rule 93 (cteaux -> .)
    RIGHTSQR        reduce using rule 93 (cteaux -> .)
    RIGHTPAR        reduce using rule 93 (cteaux -> .)
    COMMA           reduce using rule 93 (cteaux -> .)
    SEMICOLON       reduce using rule 93 (cteaux -> .)
    TO              reduce using rule 93 (cteaux -> .)
    LESSER          reduce using rule 93 (cteaux -> .)
    LESSERAND       reduce using rule 93 (cteaux -> .)
    GREATER         reduce using rule 93 (cteaux -> .)
    GREATERAND      reduce using rule 93 (cteaux -> .)
    NOTSAME         reduce using rule 93 (cteaux -> .)
    ID              reduce using rule 93 (cteaux -> .)
    CTEINT          reduce using rule 93 (cteaux -> .)
    CTEFLOAT        reduce using rule 93 (cteaux -> .)
    CTECHAR         reduce using rule 93 (cteaux -> .)
    CTESTRING       reduce using rule 93 (cteaux -> .)
    LEFTPAR         reduce using rule 93 (cteaux -> .)

    cteaux                         shift and go to state 107

state 117

    (77) arithexp -> geoexp PLUS . operatorhandler geoexp quadarith
    (94) operatorhandler -> .

    ID              reduce using rule 94 (operatorhandler -> .)
    CTEINT          reduce using rule 94 (operatorhandler -> .)
    CTEFLOAT        reduce using rule 94 (operatorhandler -> .)
    CTECHAR         reduce using rule 94 (operatorhandler -> .)
    CTESTRING       reduce using rule 94 (operatorhandler -> .)
    LEFTPAR         reduce using rule 94 (operatorhandler -> .)
    TIMES           reduce using rule 94 (operatorhandler -> .)
    DIVIDE          reduce using rule 94 (operatorhandler -> .)
    LESSER          reduce using rule 94 (operatorhandler -> .)
    LESSERAND       reduce using rule 94 (operatorhandler -> .)
    GREATER         reduce using rule 94 (operatorhandler -> .)
    GREATERAND      reduce using rule 94 (operatorhandler -> .)
    NOTSAME         reduce using rule 94 (operatorhandler -> .)
    AND             reduce using rule 94 (operatorhandler -> .)
    OR              reduce using rule 94 (operatorhandler -> .)
    RIGHTSQR        reduce using rule 94 (operatorhandler -> .)
    RIGHTPAR        reduce using rule 94 (operatorhandler -> .)
    COMMA           reduce using rule 94 (operatorhandler -> .)
    SEMICOLON       reduce using rule 94 (operatorhandler -> .)
    TO              reduce using rule 94 (operatorhandler -> .)
    PLUS            reduce using rule 94 (operatorhandler -> .)
    REST            reduce using rule 94 (operatorhandler -> .)

    operatorhandler                shift and go to state 156

state 118

    (78) arithexp -> geoexp REST . operatorhandler geoexp quadarith
    (94) operatorhandler -> .

    ID              reduce using rule 94 (operatorhandler -> .)
    CTEINT          reduce using rule 94 (operatorhandler -> .)
    CTEFLOAT        reduce using rule 94 (operatorhandler -> .)
    CTECHAR         reduce using rule 94 (operatorhandler -> .)
    CTESTRING       reduce using rule 94 (operatorhandler -> .)
    LEFTPAR         reduce using rule 94 (operatorhandler -> .)
    TIMES           reduce using rule 94 (operatorhandler -> .)
    DIVIDE          reduce using rule 94 (operatorhandler -> .)
    LESSER          reduce using rule 94 (operatorhandler -> .)
    LESSERAND       reduce using rule 94 (operatorhandler -> .)
    GREATER         reduce using rule 94 (operatorhandler -> .)
    GREATERAND      reduce using rule 94 (operatorhandler -> .)
    NOTSAME         reduce using rule 94 (operatorhandler -> .)
    AND             reduce using rule 94 (operatorhandler -> .)
    OR              reduce using rule 94 (operatorhandler -> .)
    RIGHTSQR        reduce using rule 94 (operatorhandler -> .)
    RIGHTPAR        reduce using rule 94 (operatorhandler -> .)
    COMMA           reduce using rule 94 (operatorhandler -> .)
    SEMICOLON       reduce using rule 94 (operatorhandler -> .)
    TO              reduce using rule 94 (operatorhandler -> .)
    PLUS            reduce using rule 94 (operatorhandler -> .)
    REST            reduce using rule 94 (operatorhandler -> .)

    operatorhandler                shift and go to state 157

state 119

    (81) geoexp -> assignedexp TIMES . operatorhandler assignedexp quadgeo
    (94) operatorhandler -> .

    ID              reduce using rule 94 (operatorhandler -> .)
    CTEINT          reduce using rule 94 (operatorhandler -> .)
    CTEFLOAT        reduce using rule 94 (operatorhandler -> .)
    CTECHAR         reduce using rule 94 (operatorhandler -> .)
    CTESTRING       reduce using rule 94 (operatorhandler -> .)
    LEFTPAR         reduce using rule 94 (operatorhandler -> .)
    PLUS            reduce using rule 94 (operatorhandler -> .)
    REST            reduce using rule 94 (operatorhandler -> .)
    LESSER          reduce using rule 94 (operatorhandler -> .)
    LESSERAND       reduce using rule 94 (operatorhandler -> .)
    GREATER         reduce using rule 94 (operatorhandler -> .)
    GREATERAND      reduce using rule 94 (operatorhandler -> .)
    NOTSAME         reduce using rule 94 (operatorhandler -> .)
    AND             reduce using rule 94 (operatorhandler -> .)
    OR              reduce using rule 94 (operatorhandler -> .)
    RIGHTSQR        reduce using rule 94 (operatorhandler -> .)
    RIGHTPAR        reduce using rule 94 (operatorhandler -> .)
    COMMA           reduce using rule 94 (operatorhandler -> .)
    SEMICOLON       reduce using rule 94 (operatorhandler -> .)
    TO              reduce using rule 94 (operatorhandler -> .)
    TIMES           reduce using rule 94 (operatorhandler -> .)
    DIVIDE          reduce using rule 94 (operatorhandler -> .)

    operatorhandler                shift and go to state 158

state 120

    (82) geoexp -> assignedexp DIVIDE . operatorhandler assignedexp quadgeo
    (94) operatorhandler -> .

    ID              reduce using rule 94 (operatorhandler -> .)
    CTEINT          reduce using rule 94 (operatorhandler -> .)
    CTEFLOAT        reduce using rule 94 (operatorhandler -> .)
    CTECHAR         reduce using rule 94 (operatorhandler -> .)
    CTESTRING       reduce using rule 94 (operatorhandler -> .)
    LEFTPAR         reduce using rule 94 (operatorhandler -> .)
    PLUS            reduce using rule 94 (operatorhandler -> .)
    REST            reduce using rule 94 (operatorhandler -> .)
    LESSER          reduce using rule 94 (operatorhandler -> .)
    LESSERAND       reduce using rule 94 (operatorhandler -> .)
    GREATER         reduce using rule 94 (operatorhandler -> .)
    GREATERAND      reduce using rule 94 (operatorhandler -> .)
    NOTSAME         reduce using rule 94 (operatorhandler -> .)
    AND             reduce using rule 94 (operatorhandler -> .)
    OR              reduce using rule 94 (operatorhandler -> .)
    RIGHTSQR        reduce using rule 94 (operatorhandler -> .)
    RIGHTPAR        reduce using rule 94 (operatorhandler -> .)
    COMMA           reduce using rule 94 (operatorhandler -> .)
    SEMICOLON       reduce using rule 94 (operatorhandler -> .)
    TO              reduce using rule 94 (operatorhandler -> .)
    TIMES           reduce using rule 94 (operatorhandler -> .)
    DIVIDE          reduce using rule 94 (operatorhandler -> .)

    operatorhandler                shift and go to state 159

state 121

    (84) assignedexp -> ID idgetter .

    TIMES           reduce using rule 84 (assignedexp -> ID idgetter .)
    DIVIDE          reduce using rule 84 (assignedexp -> ID idgetter .)
    PLUS            reduce using rule 84 (assignedexp -> ID idgetter .)
    REST            reduce using rule 84 (assignedexp -> ID idgetter .)
    LESSER          reduce using rule 84 (assignedexp -> ID idgetter .)
    LESSERAND       reduce using rule 84 (assignedexp -> ID idgetter .)
    GREATER         reduce using rule 84 (assignedexp -> ID idgetter .)
    GREATERAND      reduce using rule 84 (assignedexp -> ID idgetter .)
    NOTSAME         reduce using rule 84 (assignedexp -> ID idgetter .)
    AND             reduce using rule 84 (assignedexp -> ID idgetter .)
    OR              reduce using rule 84 (assignedexp -> ID idgetter .)
    RIGHTSQR        reduce using rule 84 (assignedexp -> ID idgetter .)
    RIGHTPAR        reduce using rule 84 (assignedexp -> ID idgetter .)
    COMMA           reduce using rule 84 (assignedexp -> ID idgetter .)
    SEMICOLON       reduce using rule 84 (assignedexp -> ID idgetter .)
    TO              reduce using rule 84 (assignedexp -> ID idgetter .)
    ID              reduce using rule 84 (assignedexp -> ID idgetter .)
    CTEINT          reduce using rule 84 (assignedexp -> ID idgetter .)
    CTEFLOAT        reduce using rule 84 (assignedexp -> ID idgetter .)
    CTECHAR         reduce using rule 84 (assignedexp -> ID idgetter .)
    CTESTRING       reduce using rule 84 (assignedexp -> ID idgetter .)
    LEFTPAR         reduce using rule 84 (assignedexp -> ID idgetter .)


state 122

    (91) assignedexp -> ID array . idgetterarray
    (22) idgetterarray -> .

    TIMES           reduce using rule 22 (idgetterarray -> .)
    DIVIDE          reduce using rule 22 (idgetterarray -> .)
    PLUS            reduce using rule 22 (idgetterarray -> .)
    REST            reduce using rule 22 (idgetterarray -> .)
    LESSER          reduce using rule 22 (idgetterarray -> .)
    LESSERAND       reduce using rule 22 (idgetterarray -> .)
    GREATER         reduce using rule 22 (idgetterarray -> .)
    GREATERAND      reduce using rule 22 (idgetterarray -> .)
    NOTSAME         reduce using rule 22 (idgetterarray -> .)
    AND             reduce using rule 22 (idgetterarray -> .)
    OR              reduce using rule 22 (idgetterarray -> .)
    RIGHTSQR        reduce using rule 22 (idgetterarray -> .)
    RIGHTPAR        reduce using rule 22 (idgetterarray -> .)
    COMMA           reduce using rule 22 (idgetterarray -> .)
    SEMICOLON       reduce using rule 22 (idgetterarray -> .)
    TO              reduce using rule 22 (idgetterarray -> .)
    ID              reduce using rule 22 (idgetterarray -> .)
    CTEINT          reduce using rule 22 (idgetterarray -> .)
    CTEFLOAT        reduce using rule 22 (idgetterarray -> .)
    CTECHAR         reduce using rule 22 (idgetterarray -> .)
    CTESTRING       reduce using rule 22 (idgetterarray -> .)
    LEFTPAR         reduce using rule 22 (idgetterarray -> .)

    idgetterarray                  shift and go to state 160

state 123

    (24) callFunction -> ID checkid . eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (26) eraquad -> .

    LEFTPAR         reduce using rule 26 (eraquad -> .)

    eraquad                        shift and go to state 161

state 124

    (86) assignedexp -> CTEFLOAT cteaux .

    TIMES           reduce using rule 86 (assignedexp -> CTEFLOAT cteaux .)
    DIVIDE          reduce using rule 86 (assignedexp -> CTEFLOAT cteaux .)
    PLUS            reduce using rule 86 (assignedexp -> CTEFLOAT cteaux .)
    REST            reduce using rule 86 (assignedexp -> CTEFLOAT cteaux .)
    LESSER          reduce using rule 86 (assignedexp -> CTEFLOAT cteaux .)
    LESSERAND       reduce using rule 86 (assignedexp -> CTEFLOAT cteaux .)
    GREATER         reduce using rule 86 (assignedexp -> CTEFLOAT cteaux .)
    GREATERAND      reduce using rule 86 (assignedexp -> CTEFLOAT cteaux .)
    NOTSAME         reduce using rule 86 (assignedexp -> CTEFLOAT cteaux .)
    AND             reduce using rule 86 (assignedexp -> CTEFLOAT cteaux .)
    OR              reduce using rule 86 (assignedexp -> CTEFLOAT cteaux .)
    RIGHTSQR        reduce using rule 86 (assignedexp -> CTEFLOAT cteaux .)
    RIGHTPAR        reduce using rule 86 (assignedexp -> CTEFLOAT cteaux .)
    COMMA           reduce using rule 86 (assignedexp -> CTEFLOAT cteaux .)
    SEMICOLON       reduce using rule 86 (assignedexp -> CTEFLOAT cteaux .)
    TO              reduce using rule 86 (assignedexp -> CTEFLOAT cteaux .)
    ID              reduce using rule 86 (assignedexp -> CTEFLOAT cteaux .)
    CTEINT          reduce using rule 86 (assignedexp -> CTEFLOAT cteaux .)
    CTEFLOAT        reduce using rule 86 (assignedexp -> CTEFLOAT cteaux .)
    CTECHAR         reduce using rule 86 (assignedexp -> CTEFLOAT cteaux .)
    CTESTRING       reduce using rule 86 (assignedexp -> CTEFLOAT cteaux .)
    LEFTPAR         reduce using rule 86 (assignedexp -> CTEFLOAT cteaux .)


state 125

    (87) assignedexp -> CTECHAR cteaux .

    TIMES           reduce using rule 87 (assignedexp -> CTECHAR cteaux .)
    DIVIDE          reduce using rule 87 (assignedexp -> CTECHAR cteaux .)
    PLUS            reduce using rule 87 (assignedexp -> CTECHAR cteaux .)
    REST            reduce using rule 87 (assignedexp -> CTECHAR cteaux .)
    LESSER          reduce using rule 87 (assignedexp -> CTECHAR cteaux .)
    LESSERAND       reduce using rule 87 (assignedexp -> CTECHAR cteaux .)
    GREATER         reduce using rule 87 (assignedexp -> CTECHAR cteaux .)
    GREATERAND      reduce using rule 87 (assignedexp -> CTECHAR cteaux .)
    NOTSAME         reduce using rule 87 (assignedexp -> CTECHAR cteaux .)
    AND             reduce using rule 87 (assignedexp -> CTECHAR cteaux .)
    OR              reduce using rule 87 (assignedexp -> CTECHAR cteaux .)
    RIGHTSQR        reduce using rule 87 (assignedexp -> CTECHAR cteaux .)
    RIGHTPAR        reduce using rule 87 (assignedexp -> CTECHAR cteaux .)
    COMMA           reduce using rule 87 (assignedexp -> CTECHAR cteaux .)
    SEMICOLON       reduce using rule 87 (assignedexp -> CTECHAR cteaux .)
    TO              reduce using rule 87 (assignedexp -> CTECHAR cteaux .)
    ID              reduce using rule 87 (assignedexp -> CTECHAR cteaux .)
    CTEINT          reduce using rule 87 (assignedexp -> CTECHAR cteaux .)
    CTEFLOAT        reduce using rule 87 (assignedexp -> CTECHAR cteaux .)
    CTECHAR         reduce using rule 87 (assignedexp -> CTECHAR cteaux .)
    CTESTRING       reduce using rule 87 (assignedexp -> CTECHAR cteaux .)
    LEFTPAR         reduce using rule 87 (assignedexp -> CTECHAR cteaux .)


state 126

    (88) assignedexp -> CTESTRING cteaux .

    TIMES           reduce using rule 88 (assignedexp -> CTESTRING cteaux .)
    DIVIDE          reduce using rule 88 (assignedexp -> CTESTRING cteaux .)
    PLUS            reduce using rule 88 (assignedexp -> CTESTRING cteaux .)
    REST            reduce using rule 88 (assignedexp -> CTESTRING cteaux .)
    LESSER          reduce using rule 88 (assignedexp -> CTESTRING cteaux .)
    LESSERAND       reduce using rule 88 (assignedexp -> CTESTRING cteaux .)
    GREATER         reduce using rule 88 (assignedexp -> CTESTRING cteaux .)
    GREATERAND      reduce using rule 88 (assignedexp -> CTESTRING cteaux .)
    NOTSAME         reduce using rule 88 (assignedexp -> CTESTRING cteaux .)
    AND             reduce using rule 88 (assignedexp -> CTESTRING cteaux .)
    OR              reduce using rule 88 (assignedexp -> CTESTRING cteaux .)
    RIGHTSQR        reduce using rule 88 (assignedexp -> CTESTRING cteaux .)
    RIGHTPAR        reduce using rule 88 (assignedexp -> CTESTRING cteaux .)
    COMMA           reduce using rule 88 (assignedexp -> CTESTRING cteaux .)
    SEMICOLON       reduce using rule 88 (assignedexp -> CTESTRING cteaux .)
    TO              reduce using rule 88 (assignedexp -> CTESTRING cteaux .)
    ID              reduce using rule 88 (assignedexp -> CTESTRING cteaux .)
    CTEINT          reduce using rule 88 (assignedexp -> CTESTRING cteaux .)
    CTEFLOAT        reduce using rule 88 (assignedexp -> CTESTRING cteaux .)
    CTECHAR         reduce using rule 88 (assignedexp -> CTESTRING cteaux .)
    CTESTRING       reduce using rule 88 (assignedexp -> CTESTRING cteaux .)
    LEFTPAR         reduce using rule 88 (assignedexp -> CTESTRING cteaux .)


state 127

    (90) assignedexp -> LEFTPAR exp . RIGHTPAR

    RIGHTPAR        shift and go to state 162


state 128

    (7) principal -> PRINCIPAL LEFTPAR storefunct RIGHTPAR LEFTBR vars statutes RIGHTBR .

    $end            reduce using rule 7 (principal -> PRINCIPAL LEFTPAR storefunct RIGHTPAR LEFTBR vars statutes RIGHTBR .)


state 129

    (10) statutes -> assign SEMICOLON . statutes
    (10) statutes -> . assign SEMICOLON statutes
    (11) statutes -> . callFunction SEMICOLON statutes
    (12) statutes -> . reading statutes SEMICOLON statutes
    (13) statutes -> . writing statutes SEMICOLON statutes
    (14) statutes -> . if statutes
    (15) statutes -> . while statutes
    (16) statutes -> . for statutes
    (17) statutes -> . return statutes
    (18) statutes -> . empty
    (19) assign -> . ID idgetter EQUAL operatorhandler exp assignquad
    (20) assign -> . ID idgetter array EQUAL operatorhandler exp assignquad
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (34) reading -> . READ auxreading LEFTPAR reading1 RIGHTPAR
    (41) writing -> . WRITE auxwriting LEFTPAR writing1 RIGHTPAR
    (49) if -> . IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif
    (59) while -> . WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop
    (56) for -> . FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop
    (130) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (131) return -> . RETURN LEFTPAR exp RIGHTPAR
    (132) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    IF              shift and go to state 93
    WHILE           shift and go to state 94
    FOR             shift and go to state 95
    RETURN          shift and go to state 96
    RIGHTBR         reduce using rule 132 (empty -> .)
    SEMICOLON       reduce using rule 132 (empty -> .)

    assign                         shift and go to state 81
    statutes                       shift and go to state 163
    callFunction                   shift and go to state 82
    reading                        shift and go to state 83
    writing                        shift and go to state 84
    if                             shift and go to state 85
    while                          shift and go to state 86
    for                            shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 130

    (11) statutes -> callFunction SEMICOLON . statutes
    (10) statutes -> . assign SEMICOLON statutes
    (11) statutes -> . callFunction SEMICOLON statutes
    (12) statutes -> . reading statutes SEMICOLON statutes
    (13) statutes -> . writing statutes SEMICOLON statutes
    (14) statutes -> . if statutes
    (15) statutes -> . while statutes
    (16) statutes -> . for statutes
    (17) statutes -> . return statutes
    (18) statutes -> . empty
    (19) assign -> . ID idgetter EQUAL operatorhandler exp assignquad
    (20) assign -> . ID idgetter array EQUAL operatorhandler exp assignquad
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (34) reading -> . READ auxreading LEFTPAR reading1 RIGHTPAR
    (41) writing -> . WRITE auxwriting LEFTPAR writing1 RIGHTPAR
    (49) if -> . IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif
    (59) while -> . WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop
    (56) for -> . FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop
    (130) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (131) return -> . RETURN LEFTPAR exp RIGHTPAR
    (132) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    IF              shift and go to state 93
    WHILE           shift and go to state 94
    FOR             shift and go to state 95
    RETURN          shift and go to state 96
    RIGHTBR         reduce using rule 132 (empty -> .)
    SEMICOLON       reduce using rule 132 (empty -> .)

    callFunction                   shift and go to state 82
    statutes                       shift and go to state 164
    assign                         shift and go to state 81
    reading                        shift and go to state 83
    writing                        shift and go to state 84
    if                             shift and go to state 85
    while                          shift and go to state 86
    for                            shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 131

    (12) statutes -> reading statutes . SEMICOLON statutes

    SEMICOLON       shift and go to state 165


state 132

    (13) statutes -> writing statutes . SEMICOLON statutes

    SEMICOLON       shift and go to state 166


state 133

    (14) statutes -> if statutes .

    RIGHTBR         reduce using rule 14 (statutes -> if statutes .)
    SEMICOLON       reduce using rule 14 (statutes -> if statutes .)


state 134

    (15) statutes -> while statutes .

    RIGHTBR         reduce using rule 15 (statutes -> while statutes .)
    SEMICOLON       reduce using rule 15 (statutes -> while statutes .)


state 135

    (16) statutes -> for statutes .

    RIGHTBR         reduce using rule 16 (statutes -> for statutes .)
    SEMICOLON       reduce using rule 16 (statutes -> for statutes .)


state 136

    (17) statutes -> return statutes .

    RIGHTBR         reduce using rule 17 (statutes -> return statutes .)
    SEMICOLON       reduce using rule 17 (statutes -> return statutes .)


state 137

    (19) assign -> ID idgetter . EQUAL operatorhandler exp assignquad
    (20) assign -> ID idgetter . array EQUAL operatorhandler exp assignquad
    (110) array -> . LEFTSQR exp RIGHTSQR
    (111) array -> . LEFTSQR CTEINT RIGHTSQR

    EQUAL           shift and go to state 167
    LEFTSQR         shift and go to state 55

    array                          shift and go to state 168

state 138

    (34) reading -> READ auxreading . LEFTPAR reading1 RIGHTPAR

    LEFTPAR         shift and go to state 169


state 139

    (41) writing -> WRITE auxwriting . LEFTPAR writing1 RIGHTPAR

    LEFTPAR         shift and go to state 170


state 140

    (49) if -> IF LEFTPAR . exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif
    (62) exp -> . andexp quador
    (63) exp -> . andexp quador OR operatorhandler andexp
    (65) andexp -> . boolexp quadand
    (66) andexp -> . boolexp quadand AND operatorhandler boolexp
    (68) boolexp -> . arithexp
    (69) boolexp -> . boolexp1 arithexp
    (76) arithexp -> . geoexp
    (77) arithexp -> . geoexp PLUS operatorhandler geoexp quadarith
    (78) arithexp -> . geoexp REST operatorhandler geoexp quadarith
    (70) boolexp1 -> . arithexp LESSER operatorhandler arithexp quadbool
    (71) boolexp1 -> . arithexp LESSERAND operatorhandler arithexp quadbool
    (72) boolexp1 -> . arithexp GREATER operatorhandler arithexp quadbool
    (73) boolexp1 -> . arithexp GREATERAND operatorhandler arithexp quadbool
    (74) boolexp1 -> . arithexp NOTSAME operatorhandler arithexp quadbool
    (80) geoexp -> . assignedexp
    (81) geoexp -> . assignedexp TIMES operatorhandler assignedexp quadgeo
    (82) geoexp -> . assignedexp DIVIDE operatorhandler assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (132) empty -> .

    ID              shift and go to state 73
    CTEINT          shift and go to state 116
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)
    LESSER          reduce using rule 132 (empty -> .)
    LESSERAND       reduce using rule 132 (empty -> .)
    GREATER         reduce using rule 132 (empty -> .)
    GREATERAND      reduce using rule 132 (empty -> .)
    NOTSAME         reduce using rule 132 (empty -> .)
    AND             reduce using rule 132 (empty -> .)
    OR              reduce using rule 132 (empty -> .)
    RIGHTPAR        reduce using rule 132 (empty -> .)

    exp                            shift and go to state 171
    andexp                         shift and go to state 67
    boolexp                        shift and go to state 68
    arithexp                       shift and go to state 69
    boolexp1                       shift and go to state 70
    geoexp                         shift and go to state 71
    assignedexp                    shift and go to state 72
    callFunction                   shift and go to state 77
    empty                          shift and go to state 79

state 141

    (59) while -> WHILE auxwhile . LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop

    LEFTPAR         shift and go to state 172


state 142

    (56) for -> FOR auxfor . assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop
    (19) assign -> . ID idgetter EQUAL operatorhandler exp assignquad
    (20) assign -> . ID idgetter array EQUAL operatorhandler exp assignquad

    ID              shift and go to state 174

    assign                         shift and go to state 173

state 143

    (130) return -> RETURN LEFTPAR . exp RIGHTPAR SEMICOLON
    (131) return -> RETURN LEFTPAR . exp RIGHTPAR
    (62) exp -> . andexp quador
    (63) exp -> . andexp quador OR operatorhandler andexp
    (65) andexp -> . boolexp quadand
    (66) andexp -> . boolexp quadand AND operatorhandler boolexp
    (68) boolexp -> . arithexp
    (69) boolexp -> . boolexp1 arithexp
    (76) arithexp -> . geoexp
    (77) arithexp -> . geoexp PLUS operatorhandler geoexp quadarith
    (78) arithexp -> . geoexp REST operatorhandler geoexp quadarith
    (70) boolexp1 -> . arithexp LESSER operatorhandler arithexp quadbool
    (71) boolexp1 -> . arithexp LESSERAND operatorhandler arithexp quadbool
    (72) boolexp1 -> . arithexp GREATER operatorhandler arithexp quadbool
    (73) boolexp1 -> . arithexp GREATERAND operatorhandler arithexp quadbool
    (74) boolexp1 -> . arithexp NOTSAME operatorhandler arithexp quadbool
    (80) geoexp -> . assignedexp
    (81) geoexp -> . assignedexp TIMES operatorhandler assignedexp quadgeo
    (82) geoexp -> . assignedexp DIVIDE operatorhandler assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (132) empty -> .

    ID              shift and go to state 73
    CTEINT          shift and go to state 116
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)
    LESSER          reduce using rule 132 (empty -> .)
    LESSERAND       reduce using rule 132 (empty -> .)
    GREATER         reduce using rule 132 (empty -> .)
    GREATERAND      reduce using rule 132 (empty -> .)
    NOTSAME         reduce using rule 132 (empty -> .)
    AND             reduce using rule 132 (empty -> .)
    OR              reduce using rule 132 (empty -> .)
    RIGHTPAR        reduce using rule 132 (empty -> .)

    exp                            shift and go to state 175
    andexp                         shift and go to state 67
    boolexp                        shift and go to state 68
    arithexp                       shift and go to state 69
    boolexp1                       shift and go to state 70
    geoexp                         shift and go to state 71
    assignedexp                    shift and go to state 72
    callFunction                   shift and go to state 77
    empty                          shift and go to state 79

state 144

    (117) functions1 -> ID storefunct LEFTPAR args RIGHTPAR . vars LEFTBR setaddstart statutes RIGHTBR
    (95) vars -> . vars0
    (96) vars -> . empty
    (97) vars0 -> . VARS vars1
    (132) empty -> .

    VARS            shift and go to state 12
    LEFTBR          reduce using rule 132 (empty -> .)

    vars                           shift and go to state 176
    vars0                          shift and go to state 9
    empty                          shift and go to state 10

state 145

    (122) args1 -> INT saveTypeofVar . COLON ID mulParam nextParam

    COLON           shift and go to state 177


state 146

    (123) args1 -> FLOAT saveTypeofVar . COLON ID mulParam nextParam

    COLON           shift and go to state 178


state 147

    (124) args1 -> CHAR saveTypeofVar . COLON ID mulParam nextParam

    COLON           shift and go to state 179


state 148

    (103) vars2 -> ID array COMMA vars2 addVar .

    SEMICOLON       reduce using rule 103 (vars2 -> ID array COMMA vars2 addVar .)


state 149

    (63) exp -> andexp quador OR . operatorhandler andexp
    (94) operatorhandler -> .

    ID              reduce using rule 94 (operatorhandler -> .)
    CTEINT          reduce using rule 94 (operatorhandler -> .)
    CTEFLOAT        reduce using rule 94 (operatorhandler -> .)
    CTECHAR         reduce using rule 94 (operatorhandler -> .)
    CTESTRING       reduce using rule 94 (operatorhandler -> .)
    LEFTPAR         reduce using rule 94 (operatorhandler -> .)
    AND             reduce using rule 94 (operatorhandler -> .)
    LESSER          reduce using rule 94 (operatorhandler -> .)
    LESSERAND       reduce using rule 94 (operatorhandler -> .)
    GREATER         reduce using rule 94 (operatorhandler -> .)
    GREATERAND      reduce using rule 94 (operatorhandler -> .)
    NOTSAME         reduce using rule 94 (operatorhandler -> .)
    PLUS            reduce using rule 94 (operatorhandler -> .)
    REST            reduce using rule 94 (operatorhandler -> .)
    TIMES           reduce using rule 94 (operatorhandler -> .)
    DIVIDE          reduce using rule 94 (operatorhandler -> .)
    RIGHTSQR        reduce using rule 94 (operatorhandler -> .)
    RIGHTPAR        reduce using rule 94 (operatorhandler -> .)
    COMMA           reduce using rule 94 (operatorhandler -> .)
    SEMICOLON       reduce using rule 94 (operatorhandler -> .)
    TO              reduce using rule 94 (operatorhandler -> .)

    operatorhandler                shift and go to state 180

state 150

    (66) andexp -> boolexp quadand AND . operatorhandler boolexp
    (94) operatorhandler -> .

    ID              reduce using rule 94 (operatorhandler -> .)
    CTEINT          reduce using rule 94 (operatorhandler -> .)
    CTEFLOAT        reduce using rule 94 (operatorhandler -> .)
    CTECHAR         reduce using rule 94 (operatorhandler -> .)
    CTESTRING       reduce using rule 94 (operatorhandler -> .)
    LEFTPAR         reduce using rule 94 (operatorhandler -> .)
    LESSER          reduce using rule 94 (operatorhandler -> .)
    LESSERAND       reduce using rule 94 (operatorhandler -> .)
    GREATER         reduce using rule 94 (operatorhandler -> .)
    GREATERAND      reduce using rule 94 (operatorhandler -> .)
    NOTSAME         reduce using rule 94 (operatorhandler -> .)
    PLUS            reduce using rule 94 (operatorhandler -> .)
    REST            reduce using rule 94 (operatorhandler -> .)
    TIMES           reduce using rule 94 (operatorhandler -> .)
    DIVIDE          reduce using rule 94 (operatorhandler -> .)
    OR              reduce using rule 94 (operatorhandler -> .)
    RIGHTSQR        reduce using rule 94 (operatorhandler -> .)
    RIGHTPAR        reduce using rule 94 (operatorhandler -> .)
    COMMA           reduce using rule 94 (operatorhandler -> .)
    SEMICOLON       reduce using rule 94 (operatorhandler -> .)
    TO              reduce using rule 94 (operatorhandler -> .)

    operatorhandler                shift and go to state 181

state 151

    (70) boolexp1 -> arithexp LESSER operatorhandler . arithexp quadbool
    (76) arithexp -> . geoexp
    (77) arithexp -> . geoexp PLUS operatorhandler geoexp quadarith
    (78) arithexp -> . geoexp REST operatorhandler geoexp quadarith
    (80) geoexp -> . assignedexp
    (81) geoexp -> . assignedexp TIMES operatorhandler assignedexp quadgeo
    (82) geoexp -> . assignedexp DIVIDE operatorhandler assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (132) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
    ID              shift and go to state 73
    CTEINT          shift and go to state 116
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)
    AND             reduce using rule 132 (empty -> .)
    OR              reduce using rule 132 (empty -> .)
    RIGHTSQR        reduce using rule 132 (empty -> .)
    RIGHTPAR        reduce using rule 132 (empty -> .)
    COMMA           reduce using rule 132 (empty -> .)
    SEMICOLON       reduce using rule 132 (empty -> .)
    TO              reduce using rule 132 (empty -> .)

  ! ID              [ reduce using rule 132 (empty -> .) ]
  ! CTEINT          [ reduce using rule 132 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 132 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 132 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 132 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 132 (empty -> .) ]

    arithexp                       shift and go to state 182
    geoexp                         shift and go to state 71
    assignedexp                    shift and go to state 72
    callFunction                   shift and go to state 77
    empty                          shift and go to state 79

state 152

    (71) boolexp1 -> arithexp LESSERAND operatorhandler . arithexp quadbool
    (76) arithexp -> . geoexp
    (77) arithexp -> . geoexp PLUS operatorhandler geoexp quadarith
    (78) arithexp -> . geoexp REST operatorhandler geoexp quadarith
    (80) geoexp -> . assignedexp
    (81) geoexp -> . assignedexp TIMES operatorhandler assignedexp quadgeo
    (82) geoexp -> . assignedexp DIVIDE operatorhandler assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (132) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
    ID              shift and go to state 73
    CTEINT          shift and go to state 116
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)
    AND             reduce using rule 132 (empty -> .)
    OR              reduce using rule 132 (empty -> .)
    RIGHTSQR        reduce using rule 132 (empty -> .)
    RIGHTPAR        reduce using rule 132 (empty -> .)
    COMMA           reduce using rule 132 (empty -> .)
    SEMICOLON       reduce using rule 132 (empty -> .)
    TO              reduce using rule 132 (empty -> .)

  ! ID              [ reduce using rule 132 (empty -> .) ]
  ! CTEINT          [ reduce using rule 132 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 132 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 132 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 132 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 132 (empty -> .) ]

    arithexp                       shift and go to state 183
    geoexp                         shift and go to state 71
    assignedexp                    shift and go to state 72
    callFunction                   shift and go to state 77
    empty                          shift and go to state 79

state 153

    (72) boolexp1 -> arithexp GREATER operatorhandler . arithexp quadbool
    (76) arithexp -> . geoexp
    (77) arithexp -> . geoexp PLUS operatorhandler geoexp quadarith
    (78) arithexp -> . geoexp REST operatorhandler geoexp quadarith
    (80) geoexp -> . assignedexp
    (81) geoexp -> . assignedexp TIMES operatorhandler assignedexp quadgeo
    (82) geoexp -> . assignedexp DIVIDE operatorhandler assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (132) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
    ID              shift and go to state 73
    CTEINT          shift and go to state 116
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)
    AND             reduce using rule 132 (empty -> .)
    OR              reduce using rule 132 (empty -> .)
    RIGHTSQR        reduce using rule 132 (empty -> .)
    RIGHTPAR        reduce using rule 132 (empty -> .)
    COMMA           reduce using rule 132 (empty -> .)
    SEMICOLON       reduce using rule 132 (empty -> .)
    TO              reduce using rule 132 (empty -> .)

  ! ID              [ reduce using rule 132 (empty -> .) ]
  ! CTEINT          [ reduce using rule 132 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 132 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 132 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 132 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 132 (empty -> .) ]

    arithexp                       shift and go to state 184
    geoexp                         shift and go to state 71
    assignedexp                    shift and go to state 72
    callFunction                   shift and go to state 77
    empty                          shift and go to state 79

state 154

    (73) boolexp1 -> arithexp GREATERAND operatorhandler . arithexp quadbool
    (76) arithexp -> . geoexp
    (77) arithexp -> . geoexp PLUS operatorhandler geoexp quadarith
    (78) arithexp -> . geoexp REST operatorhandler geoexp quadarith
    (80) geoexp -> . assignedexp
    (81) geoexp -> . assignedexp TIMES operatorhandler assignedexp quadgeo
    (82) geoexp -> . assignedexp DIVIDE operatorhandler assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (132) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
    ID              shift and go to state 73
    CTEINT          shift and go to state 116
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)
    AND             reduce using rule 132 (empty -> .)
    OR              reduce using rule 132 (empty -> .)
    RIGHTSQR        reduce using rule 132 (empty -> .)
    RIGHTPAR        reduce using rule 132 (empty -> .)
    COMMA           reduce using rule 132 (empty -> .)
    SEMICOLON       reduce using rule 132 (empty -> .)
    TO              reduce using rule 132 (empty -> .)

  ! ID              [ reduce using rule 132 (empty -> .) ]
  ! CTEINT          [ reduce using rule 132 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 132 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 132 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 132 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 132 (empty -> .) ]

    arithexp                       shift and go to state 185
    geoexp                         shift and go to state 71
    assignedexp                    shift and go to state 72
    callFunction                   shift and go to state 77
    empty                          shift and go to state 79

state 155

    (74) boolexp1 -> arithexp NOTSAME operatorhandler . arithexp quadbool
    (76) arithexp -> . geoexp
    (77) arithexp -> . geoexp PLUS operatorhandler geoexp quadarith
    (78) arithexp -> . geoexp REST operatorhandler geoexp quadarith
    (80) geoexp -> . assignedexp
    (81) geoexp -> . assignedexp TIMES operatorhandler assignedexp quadgeo
    (82) geoexp -> . assignedexp DIVIDE operatorhandler assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (132) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
    ID              shift and go to state 73
    CTEINT          shift and go to state 116
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)
    AND             reduce using rule 132 (empty -> .)
    OR              reduce using rule 132 (empty -> .)
    RIGHTSQR        reduce using rule 132 (empty -> .)
    RIGHTPAR        reduce using rule 132 (empty -> .)
    COMMA           reduce using rule 132 (empty -> .)
    SEMICOLON       reduce using rule 132 (empty -> .)
    TO              reduce using rule 132 (empty -> .)

  ! ID              [ reduce using rule 132 (empty -> .) ]
  ! CTEINT          [ reduce using rule 132 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 132 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 132 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 132 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 132 (empty -> .) ]

    arithexp                       shift and go to state 186
    geoexp                         shift and go to state 71
    assignedexp                    shift and go to state 72
    callFunction                   shift and go to state 77
    empty                          shift and go to state 79

state 156

    (77) arithexp -> geoexp PLUS operatorhandler . geoexp quadarith
    (80) geoexp -> . assignedexp
    (81) geoexp -> . assignedexp TIMES operatorhandler assignedexp quadgeo
    (82) geoexp -> . assignedexp DIVIDE operatorhandler assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (132) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
    ID              shift and go to state 73
    CTEINT          shift and go to state 116
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)
    LESSER          reduce using rule 132 (empty -> .)
    LESSERAND       reduce using rule 132 (empty -> .)
    GREATER         reduce using rule 132 (empty -> .)
    GREATERAND      reduce using rule 132 (empty -> .)
    NOTSAME         reduce using rule 132 (empty -> .)
    AND             reduce using rule 132 (empty -> .)
    OR              reduce using rule 132 (empty -> .)
    RIGHTSQR        reduce using rule 132 (empty -> .)
    RIGHTPAR        reduce using rule 132 (empty -> .)
    COMMA           reduce using rule 132 (empty -> .)
    SEMICOLON       reduce using rule 132 (empty -> .)
    TO              reduce using rule 132 (empty -> .)
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)

  ! ID              [ reduce using rule 132 (empty -> .) ]
  ! CTEINT          [ reduce using rule 132 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 132 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 132 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 132 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 132 (empty -> .) ]

    geoexp                         shift and go to state 187
    assignedexp                    shift and go to state 72
    callFunction                   shift and go to state 77
    empty                          shift and go to state 79

state 157

    (78) arithexp -> geoexp REST operatorhandler . geoexp quadarith
    (80) geoexp -> . assignedexp
    (81) geoexp -> . assignedexp TIMES operatorhandler assignedexp quadgeo
    (82) geoexp -> . assignedexp DIVIDE operatorhandler assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (132) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
    ID              shift and go to state 73
    CTEINT          shift and go to state 116
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)
    LESSER          reduce using rule 132 (empty -> .)
    LESSERAND       reduce using rule 132 (empty -> .)
    GREATER         reduce using rule 132 (empty -> .)
    GREATERAND      reduce using rule 132 (empty -> .)
    NOTSAME         reduce using rule 132 (empty -> .)
    AND             reduce using rule 132 (empty -> .)
    OR              reduce using rule 132 (empty -> .)
    RIGHTSQR        reduce using rule 132 (empty -> .)
    RIGHTPAR        reduce using rule 132 (empty -> .)
    COMMA           reduce using rule 132 (empty -> .)
    SEMICOLON       reduce using rule 132 (empty -> .)
    TO              reduce using rule 132 (empty -> .)
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)

  ! ID              [ reduce using rule 132 (empty -> .) ]
  ! CTEINT          [ reduce using rule 132 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 132 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 132 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 132 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 132 (empty -> .) ]

    geoexp                         shift and go to state 188
    assignedexp                    shift and go to state 72
    callFunction                   shift and go to state 77
    empty                          shift and go to state 79

state 158

    (81) geoexp -> assignedexp TIMES operatorhandler . assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (132) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
    ID              shift and go to state 73
    CTEINT          shift and go to state 116
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)
    LESSER          reduce using rule 132 (empty -> .)
    LESSERAND       reduce using rule 132 (empty -> .)
    GREATER         reduce using rule 132 (empty -> .)
    GREATERAND      reduce using rule 132 (empty -> .)
    NOTSAME         reduce using rule 132 (empty -> .)
    AND             reduce using rule 132 (empty -> .)
    OR              reduce using rule 132 (empty -> .)
    RIGHTSQR        reduce using rule 132 (empty -> .)
    RIGHTPAR        reduce using rule 132 (empty -> .)
    COMMA           reduce using rule 132 (empty -> .)
    SEMICOLON       reduce using rule 132 (empty -> .)
    TO              reduce using rule 132 (empty -> .)
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)

  ! ID              [ reduce using rule 132 (empty -> .) ]
  ! CTEINT          [ reduce using rule 132 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 132 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 132 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 132 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 132 (empty -> .) ]

    assignedexp                    shift and go to state 189
    callFunction                   shift and go to state 77
    empty                          shift and go to state 79

state 159

    (82) geoexp -> assignedexp DIVIDE operatorhandler . assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (132) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEINT resolved as shift
  ! shift/reduce conflict for CTEFLOAT resolved as shift
  ! shift/reduce conflict for CTECHAR resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LEFTPAR resolved as shift
    ID              shift and go to state 73
    CTEINT          shift and go to state 116
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)
    LESSER          reduce using rule 132 (empty -> .)
    LESSERAND       reduce using rule 132 (empty -> .)
    GREATER         reduce using rule 132 (empty -> .)
    GREATERAND      reduce using rule 132 (empty -> .)
    NOTSAME         reduce using rule 132 (empty -> .)
    AND             reduce using rule 132 (empty -> .)
    OR              reduce using rule 132 (empty -> .)
    RIGHTSQR        reduce using rule 132 (empty -> .)
    RIGHTPAR        reduce using rule 132 (empty -> .)
    COMMA           reduce using rule 132 (empty -> .)
    SEMICOLON       reduce using rule 132 (empty -> .)
    TO              reduce using rule 132 (empty -> .)
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)

  ! ID              [ reduce using rule 132 (empty -> .) ]
  ! CTEINT          [ reduce using rule 132 (empty -> .) ]
  ! CTEFLOAT        [ reduce using rule 132 (empty -> .) ]
  ! CTECHAR         [ reduce using rule 132 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 132 (empty -> .) ]
  ! LEFTPAR         [ reduce using rule 132 (empty -> .) ]

    assignedexp                    shift and go to state 190
    callFunction                   shift and go to state 77
    empty                          shift and go to state 79

state 160

    (91) assignedexp -> ID array idgetterarray .

    TIMES           reduce using rule 91 (assignedexp -> ID array idgetterarray .)
    DIVIDE          reduce using rule 91 (assignedexp -> ID array idgetterarray .)
    PLUS            reduce using rule 91 (assignedexp -> ID array idgetterarray .)
    REST            reduce using rule 91 (assignedexp -> ID array idgetterarray .)
    LESSER          reduce using rule 91 (assignedexp -> ID array idgetterarray .)
    LESSERAND       reduce using rule 91 (assignedexp -> ID array idgetterarray .)
    GREATER         reduce using rule 91 (assignedexp -> ID array idgetterarray .)
    GREATERAND      reduce using rule 91 (assignedexp -> ID array idgetterarray .)
    NOTSAME         reduce using rule 91 (assignedexp -> ID array idgetterarray .)
    AND             reduce using rule 91 (assignedexp -> ID array idgetterarray .)
    OR              reduce using rule 91 (assignedexp -> ID array idgetterarray .)
    RIGHTSQR        reduce using rule 91 (assignedexp -> ID array idgetterarray .)
    RIGHTPAR        reduce using rule 91 (assignedexp -> ID array idgetterarray .)
    COMMA           reduce using rule 91 (assignedexp -> ID array idgetterarray .)
    SEMICOLON       reduce using rule 91 (assignedexp -> ID array idgetterarray .)
    TO              reduce using rule 91 (assignedexp -> ID array idgetterarray .)
    ID              reduce using rule 91 (assignedexp -> ID array idgetterarray .)
    CTEINT          reduce using rule 91 (assignedexp -> ID array idgetterarray .)
    CTEFLOAT        reduce using rule 91 (assignedexp -> ID array idgetterarray .)
    CTECHAR         reduce using rule 91 (assignedexp -> ID array idgetterarray .)
    CTESTRING       reduce using rule 91 (assignedexp -> ID array idgetterarray .)
    LEFTPAR         reduce using rule 91 (assignedexp -> ID array idgetterarray .)


state 161

    (24) callFunction -> ID checkid eraquad . LEFTPAR paramexp checkparam RIGHTPAR quadgosub

    LEFTPAR         shift and go to state 191


state 162

    (90) assignedexp -> LEFTPAR exp RIGHTPAR .

    TIMES           reduce using rule 90 (assignedexp -> LEFTPAR exp RIGHTPAR .)
    DIVIDE          reduce using rule 90 (assignedexp -> LEFTPAR exp RIGHTPAR .)
    PLUS            reduce using rule 90 (assignedexp -> LEFTPAR exp RIGHTPAR .)
    REST            reduce using rule 90 (assignedexp -> LEFTPAR exp RIGHTPAR .)
    LESSER          reduce using rule 90 (assignedexp -> LEFTPAR exp RIGHTPAR .)
    LESSERAND       reduce using rule 90 (assignedexp -> LEFTPAR exp RIGHTPAR .)
    GREATER         reduce using rule 90 (assignedexp -> LEFTPAR exp RIGHTPAR .)
    GREATERAND      reduce using rule 90 (assignedexp -> LEFTPAR exp RIGHTPAR .)
    NOTSAME         reduce using rule 90 (assignedexp -> LEFTPAR exp RIGHTPAR .)
    AND             reduce using rule 90 (assignedexp -> LEFTPAR exp RIGHTPAR .)
    OR              reduce using rule 90 (assignedexp -> LEFTPAR exp RIGHTPAR .)
    RIGHTSQR        reduce using rule 90 (assignedexp -> LEFTPAR exp RIGHTPAR .)
    RIGHTPAR        reduce using rule 90 (assignedexp -> LEFTPAR exp RIGHTPAR .)
    COMMA           reduce using rule 90 (assignedexp -> LEFTPAR exp RIGHTPAR .)
    SEMICOLON       reduce using rule 90 (assignedexp -> LEFTPAR exp RIGHTPAR .)
    TO              reduce using rule 90 (assignedexp -> LEFTPAR exp RIGHTPAR .)
    ID              reduce using rule 90 (assignedexp -> LEFTPAR exp RIGHTPAR .)
    CTEINT          reduce using rule 90 (assignedexp -> LEFTPAR exp RIGHTPAR .)
    CTEFLOAT        reduce using rule 90 (assignedexp -> LEFTPAR exp RIGHTPAR .)
    CTECHAR         reduce using rule 90 (assignedexp -> LEFTPAR exp RIGHTPAR .)
    CTESTRING       reduce using rule 90 (assignedexp -> LEFTPAR exp RIGHTPAR .)
    LEFTPAR         reduce using rule 90 (assignedexp -> LEFTPAR exp RIGHTPAR .)


state 163

    (10) statutes -> assign SEMICOLON statutes .

    RIGHTBR         reduce using rule 10 (statutes -> assign SEMICOLON statutes .)
    SEMICOLON       reduce using rule 10 (statutes -> assign SEMICOLON statutes .)


state 164

    (11) statutes -> callFunction SEMICOLON statutes .

    RIGHTBR         reduce using rule 11 (statutes -> callFunction SEMICOLON statutes .)
    SEMICOLON       reduce using rule 11 (statutes -> callFunction SEMICOLON statutes .)


state 165

    (12) statutes -> reading statutes SEMICOLON . statutes
    (10) statutes -> . assign SEMICOLON statutes
    (11) statutes -> . callFunction SEMICOLON statutes
    (12) statutes -> . reading statutes SEMICOLON statutes
    (13) statutes -> . writing statutes SEMICOLON statutes
    (14) statutes -> . if statutes
    (15) statutes -> . while statutes
    (16) statutes -> . for statutes
    (17) statutes -> . return statutes
    (18) statutes -> . empty
    (19) assign -> . ID idgetter EQUAL operatorhandler exp assignquad
    (20) assign -> . ID idgetter array EQUAL operatorhandler exp assignquad
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (34) reading -> . READ auxreading LEFTPAR reading1 RIGHTPAR
    (41) writing -> . WRITE auxwriting LEFTPAR writing1 RIGHTPAR
    (49) if -> . IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif
    (59) while -> . WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop
    (56) for -> . FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop
    (130) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (131) return -> . RETURN LEFTPAR exp RIGHTPAR
    (132) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    IF              shift and go to state 93
    WHILE           shift and go to state 94
    FOR             shift and go to state 95
    RETURN          shift and go to state 96
    RIGHTBR         reduce using rule 132 (empty -> .)
    SEMICOLON       reduce using rule 132 (empty -> .)

    reading                        shift and go to state 83
    statutes                       shift and go to state 192
    assign                         shift and go to state 81
    callFunction                   shift and go to state 82
    writing                        shift and go to state 84
    if                             shift and go to state 85
    while                          shift and go to state 86
    for                            shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 166

    (13) statutes -> writing statutes SEMICOLON . statutes
    (10) statutes -> . assign SEMICOLON statutes
    (11) statutes -> . callFunction SEMICOLON statutes
    (12) statutes -> . reading statutes SEMICOLON statutes
    (13) statutes -> . writing statutes SEMICOLON statutes
    (14) statutes -> . if statutes
    (15) statutes -> . while statutes
    (16) statutes -> . for statutes
    (17) statutes -> . return statutes
    (18) statutes -> . empty
    (19) assign -> . ID idgetter EQUAL operatorhandler exp assignquad
    (20) assign -> . ID idgetter array EQUAL operatorhandler exp assignquad
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (34) reading -> . READ auxreading LEFTPAR reading1 RIGHTPAR
    (41) writing -> . WRITE auxwriting LEFTPAR writing1 RIGHTPAR
    (49) if -> . IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif
    (59) while -> . WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop
    (56) for -> . FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop
    (130) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (131) return -> . RETURN LEFTPAR exp RIGHTPAR
    (132) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    IF              shift and go to state 93
    WHILE           shift and go to state 94
    FOR             shift and go to state 95
    RETURN          shift and go to state 96
    RIGHTBR         reduce using rule 132 (empty -> .)
    SEMICOLON       reduce using rule 132 (empty -> .)

    writing                        shift and go to state 84
    statutes                       shift and go to state 193
    assign                         shift and go to state 81
    callFunction                   shift and go to state 82
    reading                        shift and go to state 83
    if                             shift and go to state 85
    while                          shift and go to state 86
    for                            shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 167

    (19) assign -> ID idgetter EQUAL . operatorhandler exp assignquad
    (94) operatorhandler -> .

    ID              reduce using rule 94 (operatorhandler -> .)
    CTEINT          reduce using rule 94 (operatorhandler -> .)
    CTEFLOAT        reduce using rule 94 (operatorhandler -> .)
    CTECHAR         reduce using rule 94 (operatorhandler -> .)
    CTESTRING       reduce using rule 94 (operatorhandler -> .)
    LEFTPAR         reduce using rule 94 (operatorhandler -> .)
    OR              reduce using rule 94 (operatorhandler -> .)
    AND             reduce using rule 94 (operatorhandler -> .)
    LESSER          reduce using rule 94 (operatorhandler -> .)
    LESSERAND       reduce using rule 94 (operatorhandler -> .)
    GREATER         reduce using rule 94 (operatorhandler -> .)
    GREATERAND      reduce using rule 94 (operatorhandler -> .)
    NOTSAME         reduce using rule 94 (operatorhandler -> .)
    PLUS            reduce using rule 94 (operatorhandler -> .)
    REST            reduce using rule 94 (operatorhandler -> .)
    TIMES           reduce using rule 94 (operatorhandler -> .)
    DIVIDE          reduce using rule 94 (operatorhandler -> .)
    SEMICOLON       reduce using rule 94 (operatorhandler -> .)
    TO              reduce using rule 94 (operatorhandler -> .)

    operatorhandler                shift and go to state 194

state 168

    (20) assign -> ID idgetter array . EQUAL operatorhandler exp assignquad

    EQUAL           shift and go to state 195


state 169

    (34) reading -> READ auxreading LEFTPAR . reading1 RIGHTPAR
    (35) reading1 -> . reading2
    (36) reading1 -> . empty
    (37) reading2 -> . exp readingquad
    (38) reading2 -> . exp readingquad COMMA auxreading reading2
    (132) empty -> .
    (62) exp -> . andexp quador
    (63) exp -> . andexp quador OR operatorhandler andexp
    (65) andexp -> . boolexp quadand
    (66) andexp -> . boolexp quadand AND operatorhandler boolexp
    (68) boolexp -> . arithexp
    (69) boolexp -> . boolexp1 arithexp
    (76) arithexp -> . geoexp
    (77) arithexp -> . geoexp PLUS operatorhandler geoexp quadarith
    (78) arithexp -> . geoexp REST operatorhandler geoexp quadarith
    (70) boolexp1 -> . arithexp LESSER operatorhandler arithexp quadbool
    (71) boolexp1 -> . arithexp LESSERAND operatorhandler arithexp quadbool
    (72) boolexp1 -> . arithexp GREATER operatorhandler arithexp quadbool
    (73) boolexp1 -> . arithexp GREATERAND operatorhandler arithexp quadbool
    (74) boolexp1 -> . arithexp NOTSAME operatorhandler arithexp quadbool
    (80) geoexp -> . assignedexp
    (81) geoexp -> . assignedexp TIMES operatorhandler assignedexp quadgeo
    (82) geoexp -> . assignedexp DIVIDE operatorhandler assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub

    RIGHTPAR        reduce using rule 132 (empty -> .)
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)
    LESSER          reduce using rule 132 (empty -> .)
    LESSERAND       reduce using rule 132 (empty -> .)
    GREATER         reduce using rule 132 (empty -> .)
    GREATERAND      reduce using rule 132 (empty -> .)
    NOTSAME         reduce using rule 132 (empty -> .)
    AND             reduce using rule 132 (empty -> .)
    OR              reduce using rule 132 (empty -> .)
    COMMA           reduce using rule 132 (empty -> .)
    ID              shift and go to state 73
    CTEINT          shift and go to state 116
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78

    reading1                       shift and go to state 196
    reading2                       shift and go to state 197
    empty                          shift and go to state 198
    exp                            shift and go to state 199
    andexp                         shift and go to state 67
    boolexp                        shift and go to state 68
    arithexp                       shift and go to state 69
    boolexp1                       shift and go to state 70
    geoexp                         shift and go to state 71
    assignedexp                    shift and go to state 72
    callFunction                   shift and go to state 77

state 170

    (41) writing -> WRITE auxwriting LEFTPAR . writing1 RIGHTPAR
    (42) writing1 -> . writing2
    (43) writing1 -> . empty
    (44) writing2 -> . exp writingquad
    (45) writing2 -> . exp writingquad COMMA auxwriting writing2
    (132) empty -> .
    (62) exp -> . andexp quador
    (63) exp -> . andexp quador OR operatorhandler andexp
    (65) andexp -> . boolexp quadand
    (66) andexp -> . boolexp quadand AND operatorhandler boolexp
    (68) boolexp -> . arithexp
    (69) boolexp -> . boolexp1 arithexp
    (76) arithexp -> . geoexp
    (77) arithexp -> . geoexp PLUS operatorhandler geoexp quadarith
    (78) arithexp -> . geoexp REST operatorhandler geoexp quadarith
    (70) boolexp1 -> . arithexp LESSER operatorhandler arithexp quadbool
    (71) boolexp1 -> . arithexp LESSERAND operatorhandler arithexp quadbool
    (72) boolexp1 -> . arithexp GREATER operatorhandler arithexp quadbool
    (73) boolexp1 -> . arithexp GREATERAND operatorhandler arithexp quadbool
    (74) boolexp1 -> . arithexp NOTSAME operatorhandler arithexp quadbool
    (80) geoexp -> . assignedexp
    (81) geoexp -> . assignedexp TIMES operatorhandler assignedexp quadgeo
    (82) geoexp -> . assignedexp DIVIDE operatorhandler assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub

    RIGHTPAR        reduce using rule 132 (empty -> .)
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)
    LESSER          reduce using rule 132 (empty -> .)
    LESSERAND       reduce using rule 132 (empty -> .)
    GREATER         reduce using rule 132 (empty -> .)
    GREATERAND      reduce using rule 132 (empty -> .)
    NOTSAME         reduce using rule 132 (empty -> .)
    AND             reduce using rule 132 (empty -> .)
    OR              reduce using rule 132 (empty -> .)
    COMMA           reduce using rule 132 (empty -> .)
    ID              shift and go to state 73
    CTEINT          shift and go to state 116
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78

    writing1                       shift and go to state 200
    writing2                       shift and go to state 201
    empty                          shift and go to state 202
    exp                            shift and go to state 203
    andexp                         shift and go to state 67
    boolexp                        shift and go to state 68
    arithexp                       shift and go to state 69
    boolexp1                       shift and go to state 70
    geoexp                         shift and go to state 71
    assignedexp                    shift and go to state 72
    callFunction                   shift and go to state 77

state 171

    (49) if -> IF LEFTPAR exp . RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif

    RIGHTPAR        shift and go to state 204


state 172

    (59) while -> WHILE auxwhile LEFTPAR . exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop
    (62) exp -> . andexp quador
    (63) exp -> . andexp quador OR operatorhandler andexp
    (65) andexp -> . boolexp quadand
    (66) andexp -> . boolexp quadand AND operatorhandler boolexp
    (68) boolexp -> . arithexp
    (69) boolexp -> . boolexp1 arithexp
    (76) arithexp -> . geoexp
    (77) arithexp -> . geoexp PLUS operatorhandler geoexp quadarith
    (78) arithexp -> . geoexp REST operatorhandler geoexp quadarith
    (70) boolexp1 -> . arithexp LESSER operatorhandler arithexp quadbool
    (71) boolexp1 -> . arithexp LESSERAND operatorhandler arithexp quadbool
    (72) boolexp1 -> . arithexp GREATER operatorhandler arithexp quadbool
    (73) boolexp1 -> . arithexp GREATERAND operatorhandler arithexp quadbool
    (74) boolexp1 -> . arithexp NOTSAME operatorhandler arithexp quadbool
    (80) geoexp -> . assignedexp
    (81) geoexp -> . assignedexp TIMES operatorhandler assignedexp quadgeo
    (82) geoexp -> . assignedexp DIVIDE operatorhandler assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (132) empty -> .

    ID              shift and go to state 73
    CTEINT          shift and go to state 116
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)
    LESSER          reduce using rule 132 (empty -> .)
    LESSERAND       reduce using rule 132 (empty -> .)
    GREATER         reduce using rule 132 (empty -> .)
    GREATERAND      reduce using rule 132 (empty -> .)
    NOTSAME         reduce using rule 132 (empty -> .)
    AND             reduce using rule 132 (empty -> .)
    OR              reduce using rule 132 (empty -> .)
    RIGHTPAR        reduce using rule 132 (empty -> .)

    exp                            shift and go to state 205
    andexp                         shift and go to state 67
    boolexp                        shift and go to state 68
    arithexp                       shift and go to state 69
    boolexp1                       shift and go to state 70
    geoexp                         shift and go to state 71
    assignedexp                    shift and go to state 72
    callFunction                   shift and go to state 77
    empty                          shift and go to state 79

state 173

    (56) for -> FOR auxfor assign . TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop

    TO              shift and go to state 206


state 174

    (19) assign -> ID . idgetter EQUAL operatorhandler exp assignquad
    (20) assign -> ID . idgetter array EQUAL operatorhandler exp assignquad
    (21) idgetter -> .

    EQUAL           reduce using rule 21 (idgetter -> .)
    LEFTSQR         reduce using rule 21 (idgetter -> .)

    idgetter                       shift and go to state 137

state 175

    (130) return -> RETURN LEFTPAR exp . RIGHTPAR SEMICOLON
    (131) return -> RETURN LEFTPAR exp . RIGHTPAR

    RIGHTPAR        shift and go to state 207


state 176

    (117) functions1 -> ID storefunct LEFTPAR args RIGHTPAR vars . LEFTBR setaddstart statutes RIGHTBR

    LEFTBR          shift and go to state 208


state 177

    (122) args1 -> INT saveTypeofVar COLON . ID mulParam nextParam

    ID              shift and go to state 209


state 178

    (123) args1 -> FLOAT saveTypeofVar COLON . ID mulParam nextParam

    ID              shift and go to state 210


state 179

    (124) args1 -> CHAR saveTypeofVar COLON . ID mulParam nextParam

    ID              shift and go to state 211


state 180

    (63) exp -> andexp quador OR operatorhandler . andexp
    (65) andexp -> . boolexp quadand
    (66) andexp -> . boolexp quadand AND operatorhandler boolexp
    (68) boolexp -> . arithexp
    (69) boolexp -> . boolexp1 arithexp
    (76) arithexp -> . geoexp
    (77) arithexp -> . geoexp PLUS operatorhandler geoexp quadarith
    (78) arithexp -> . geoexp REST operatorhandler geoexp quadarith
    (70) boolexp1 -> . arithexp LESSER operatorhandler arithexp quadbool
    (71) boolexp1 -> . arithexp LESSERAND operatorhandler arithexp quadbool
    (72) boolexp1 -> . arithexp GREATER operatorhandler arithexp quadbool
    (73) boolexp1 -> . arithexp GREATERAND operatorhandler arithexp quadbool
    (74) boolexp1 -> . arithexp NOTSAME operatorhandler arithexp quadbool
    (80) geoexp -> . assignedexp
    (81) geoexp -> . assignedexp TIMES operatorhandler assignedexp quadgeo
    (82) geoexp -> . assignedexp DIVIDE operatorhandler assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (132) empty -> .

    ID              shift and go to state 73
    CTEINT          shift and go to state 116
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)
    LESSER          reduce using rule 132 (empty -> .)
    LESSERAND       reduce using rule 132 (empty -> .)
    GREATER         reduce using rule 132 (empty -> .)
    GREATERAND      reduce using rule 132 (empty -> .)
    NOTSAME         reduce using rule 132 (empty -> .)
    AND             reduce using rule 132 (empty -> .)
    RIGHTSQR        reduce using rule 132 (empty -> .)
    RIGHTPAR        reduce using rule 132 (empty -> .)
    COMMA           reduce using rule 132 (empty -> .)
    SEMICOLON       reduce using rule 132 (empty -> .)
    TO              reduce using rule 132 (empty -> .)

    andexp                         shift and go to state 212
    boolexp                        shift and go to state 68
    arithexp                       shift and go to state 69
    boolexp1                       shift and go to state 70
    geoexp                         shift and go to state 71
    assignedexp                    shift and go to state 72
    callFunction                   shift and go to state 77
    empty                          shift and go to state 79

state 181

    (66) andexp -> boolexp quadand AND operatorhandler . boolexp
    (68) boolexp -> . arithexp
    (69) boolexp -> . boolexp1 arithexp
    (76) arithexp -> . geoexp
    (77) arithexp -> . geoexp PLUS operatorhandler geoexp quadarith
    (78) arithexp -> . geoexp REST operatorhandler geoexp quadarith
    (70) boolexp1 -> . arithexp LESSER operatorhandler arithexp quadbool
    (71) boolexp1 -> . arithexp LESSERAND operatorhandler arithexp quadbool
    (72) boolexp1 -> . arithexp GREATER operatorhandler arithexp quadbool
    (73) boolexp1 -> . arithexp GREATERAND operatorhandler arithexp quadbool
    (74) boolexp1 -> . arithexp NOTSAME operatorhandler arithexp quadbool
    (80) geoexp -> . assignedexp
    (81) geoexp -> . assignedexp TIMES operatorhandler assignedexp quadgeo
    (82) geoexp -> . assignedexp DIVIDE operatorhandler assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (132) empty -> .

    ID              shift and go to state 73
    CTEINT          shift and go to state 116
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)
    LESSER          reduce using rule 132 (empty -> .)
    LESSERAND       reduce using rule 132 (empty -> .)
    GREATER         reduce using rule 132 (empty -> .)
    GREATERAND      reduce using rule 132 (empty -> .)
    NOTSAME         reduce using rule 132 (empty -> .)
    OR              reduce using rule 132 (empty -> .)
    RIGHTSQR        reduce using rule 132 (empty -> .)
    RIGHTPAR        reduce using rule 132 (empty -> .)
    COMMA           reduce using rule 132 (empty -> .)
    SEMICOLON       reduce using rule 132 (empty -> .)
    TO              reduce using rule 132 (empty -> .)

    boolexp                        shift and go to state 213
    arithexp                       shift and go to state 69
    boolexp1                       shift and go to state 70
    geoexp                         shift and go to state 71
    assignedexp                    shift and go to state 72
    callFunction                   shift and go to state 77
    empty                          shift and go to state 79

state 182

    (70) boolexp1 -> arithexp LESSER operatorhandler arithexp . quadbool
    (75) quadbool -> .

    ID              reduce using rule 75 (quadbool -> .)
    CTEINT          reduce using rule 75 (quadbool -> .)
    CTEFLOAT        reduce using rule 75 (quadbool -> .)
    CTECHAR         reduce using rule 75 (quadbool -> .)
    CTESTRING       reduce using rule 75 (quadbool -> .)
    LEFTPAR         reduce using rule 75 (quadbool -> .)
    PLUS            reduce using rule 75 (quadbool -> .)
    REST            reduce using rule 75 (quadbool -> .)
    TIMES           reduce using rule 75 (quadbool -> .)
    DIVIDE          reduce using rule 75 (quadbool -> .)
    AND             reduce using rule 75 (quadbool -> .)
    OR              reduce using rule 75 (quadbool -> .)
    RIGHTSQR        reduce using rule 75 (quadbool -> .)
    RIGHTPAR        reduce using rule 75 (quadbool -> .)
    COMMA           reduce using rule 75 (quadbool -> .)
    SEMICOLON       reduce using rule 75 (quadbool -> .)
    TO              reduce using rule 75 (quadbool -> .)

    quadbool                       shift and go to state 214

state 183

    (71) boolexp1 -> arithexp LESSERAND operatorhandler arithexp . quadbool
    (75) quadbool -> .

    ID              reduce using rule 75 (quadbool -> .)
    CTEINT          reduce using rule 75 (quadbool -> .)
    CTEFLOAT        reduce using rule 75 (quadbool -> .)
    CTECHAR         reduce using rule 75 (quadbool -> .)
    CTESTRING       reduce using rule 75 (quadbool -> .)
    LEFTPAR         reduce using rule 75 (quadbool -> .)
    PLUS            reduce using rule 75 (quadbool -> .)
    REST            reduce using rule 75 (quadbool -> .)
    TIMES           reduce using rule 75 (quadbool -> .)
    DIVIDE          reduce using rule 75 (quadbool -> .)
    AND             reduce using rule 75 (quadbool -> .)
    OR              reduce using rule 75 (quadbool -> .)
    RIGHTSQR        reduce using rule 75 (quadbool -> .)
    RIGHTPAR        reduce using rule 75 (quadbool -> .)
    COMMA           reduce using rule 75 (quadbool -> .)
    SEMICOLON       reduce using rule 75 (quadbool -> .)
    TO              reduce using rule 75 (quadbool -> .)

    quadbool                       shift and go to state 215

state 184

    (72) boolexp1 -> arithexp GREATER operatorhandler arithexp . quadbool
    (75) quadbool -> .

    ID              reduce using rule 75 (quadbool -> .)
    CTEINT          reduce using rule 75 (quadbool -> .)
    CTEFLOAT        reduce using rule 75 (quadbool -> .)
    CTECHAR         reduce using rule 75 (quadbool -> .)
    CTESTRING       reduce using rule 75 (quadbool -> .)
    LEFTPAR         reduce using rule 75 (quadbool -> .)
    PLUS            reduce using rule 75 (quadbool -> .)
    REST            reduce using rule 75 (quadbool -> .)
    TIMES           reduce using rule 75 (quadbool -> .)
    DIVIDE          reduce using rule 75 (quadbool -> .)
    AND             reduce using rule 75 (quadbool -> .)
    OR              reduce using rule 75 (quadbool -> .)
    RIGHTSQR        reduce using rule 75 (quadbool -> .)
    RIGHTPAR        reduce using rule 75 (quadbool -> .)
    COMMA           reduce using rule 75 (quadbool -> .)
    SEMICOLON       reduce using rule 75 (quadbool -> .)
    TO              reduce using rule 75 (quadbool -> .)

    quadbool                       shift and go to state 216

state 185

    (73) boolexp1 -> arithexp GREATERAND operatorhandler arithexp . quadbool
    (75) quadbool -> .

    ID              reduce using rule 75 (quadbool -> .)
    CTEINT          reduce using rule 75 (quadbool -> .)
    CTEFLOAT        reduce using rule 75 (quadbool -> .)
    CTECHAR         reduce using rule 75 (quadbool -> .)
    CTESTRING       reduce using rule 75 (quadbool -> .)
    LEFTPAR         reduce using rule 75 (quadbool -> .)
    PLUS            reduce using rule 75 (quadbool -> .)
    REST            reduce using rule 75 (quadbool -> .)
    TIMES           reduce using rule 75 (quadbool -> .)
    DIVIDE          reduce using rule 75 (quadbool -> .)
    AND             reduce using rule 75 (quadbool -> .)
    OR              reduce using rule 75 (quadbool -> .)
    RIGHTSQR        reduce using rule 75 (quadbool -> .)
    RIGHTPAR        reduce using rule 75 (quadbool -> .)
    COMMA           reduce using rule 75 (quadbool -> .)
    SEMICOLON       reduce using rule 75 (quadbool -> .)
    TO              reduce using rule 75 (quadbool -> .)

    quadbool                       shift and go to state 217

state 186

    (74) boolexp1 -> arithexp NOTSAME operatorhandler arithexp . quadbool
    (75) quadbool -> .

    ID              reduce using rule 75 (quadbool -> .)
    CTEINT          reduce using rule 75 (quadbool -> .)
    CTEFLOAT        reduce using rule 75 (quadbool -> .)
    CTECHAR         reduce using rule 75 (quadbool -> .)
    CTESTRING       reduce using rule 75 (quadbool -> .)
    LEFTPAR         reduce using rule 75 (quadbool -> .)
    PLUS            reduce using rule 75 (quadbool -> .)
    REST            reduce using rule 75 (quadbool -> .)
    TIMES           reduce using rule 75 (quadbool -> .)
    DIVIDE          reduce using rule 75 (quadbool -> .)
    AND             reduce using rule 75 (quadbool -> .)
    OR              reduce using rule 75 (quadbool -> .)
    RIGHTSQR        reduce using rule 75 (quadbool -> .)
    RIGHTPAR        reduce using rule 75 (quadbool -> .)
    COMMA           reduce using rule 75 (quadbool -> .)
    SEMICOLON       reduce using rule 75 (quadbool -> .)
    TO              reduce using rule 75 (quadbool -> .)

    quadbool                       shift and go to state 218

state 187

    (77) arithexp -> geoexp PLUS operatorhandler geoexp . quadarith
    (79) quadarith -> .

    LESSER          reduce using rule 79 (quadarith -> .)
    LESSERAND       reduce using rule 79 (quadarith -> .)
    GREATER         reduce using rule 79 (quadarith -> .)
    GREATERAND      reduce using rule 79 (quadarith -> .)
    NOTSAME         reduce using rule 79 (quadarith -> .)
    AND             reduce using rule 79 (quadarith -> .)
    OR              reduce using rule 79 (quadarith -> .)
    RIGHTSQR        reduce using rule 79 (quadarith -> .)
    RIGHTPAR        reduce using rule 79 (quadarith -> .)
    COMMA           reduce using rule 79 (quadarith -> .)
    SEMICOLON       reduce using rule 79 (quadarith -> .)
    TO              reduce using rule 79 (quadarith -> .)
    ID              reduce using rule 79 (quadarith -> .)
    CTEINT          reduce using rule 79 (quadarith -> .)
    CTEFLOAT        reduce using rule 79 (quadarith -> .)
    CTECHAR         reduce using rule 79 (quadarith -> .)
    CTESTRING       reduce using rule 79 (quadarith -> .)
    LEFTPAR         reduce using rule 79 (quadarith -> .)
    PLUS            reduce using rule 79 (quadarith -> .)
    REST            reduce using rule 79 (quadarith -> .)
    TIMES           reduce using rule 79 (quadarith -> .)
    DIVIDE          reduce using rule 79 (quadarith -> .)

    quadarith                      shift and go to state 219

state 188

    (78) arithexp -> geoexp REST operatorhandler geoexp . quadarith
    (79) quadarith -> .

    LESSER          reduce using rule 79 (quadarith -> .)
    LESSERAND       reduce using rule 79 (quadarith -> .)
    GREATER         reduce using rule 79 (quadarith -> .)
    GREATERAND      reduce using rule 79 (quadarith -> .)
    NOTSAME         reduce using rule 79 (quadarith -> .)
    AND             reduce using rule 79 (quadarith -> .)
    OR              reduce using rule 79 (quadarith -> .)
    RIGHTSQR        reduce using rule 79 (quadarith -> .)
    RIGHTPAR        reduce using rule 79 (quadarith -> .)
    COMMA           reduce using rule 79 (quadarith -> .)
    SEMICOLON       reduce using rule 79 (quadarith -> .)
    TO              reduce using rule 79 (quadarith -> .)
    ID              reduce using rule 79 (quadarith -> .)
    CTEINT          reduce using rule 79 (quadarith -> .)
    CTEFLOAT        reduce using rule 79 (quadarith -> .)
    CTECHAR         reduce using rule 79 (quadarith -> .)
    CTESTRING       reduce using rule 79 (quadarith -> .)
    LEFTPAR         reduce using rule 79 (quadarith -> .)
    PLUS            reduce using rule 79 (quadarith -> .)
    REST            reduce using rule 79 (quadarith -> .)
    TIMES           reduce using rule 79 (quadarith -> .)
    DIVIDE          reduce using rule 79 (quadarith -> .)

    quadarith                      shift and go to state 220

state 189

    (81) geoexp -> assignedexp TIMES operatorhandler assignedexp . quadgeo
    (83) quadgeo -> .

    PLUS            reduce using rule 83 (quadgeo -> .)
    REST            reduce using rule 83 (quadgeo -> .)
    LESSER          reduce using rule 83 (quadgeo -> .)
    LESSERAND       reduce using rule 83 (quadgeo -> .)
    GREATER         reduce using rule 83 (quadgeo -> .)
    GREATERAND      reduce using rule 83 (quadgeo -> .)
    NOTSAME         reduce using rule 83 (quadgeo -> .)
    AND             reduce using rule 83 (quadgeo -> .)
    OR              reduce using rule 83 (quadgeo -> .)
    RIGHTSQR        reduce using rule 83 (quadgeo -> .)
    RIGHTPAR        reduce using rule 83 (quadgeo -> .)
    COMMA           reduce using rule 83 (quadgeo -> .)
    SEMICOLON       reduce using rule 83 (quadgeo -> .)
    TO              reduce using rule 83 (quadgeo -> .)
    ID              reduce using rule 83 (quadgeo -> .)
    CTEINT          reduce using rule 83 (quadgeo -> .)
    CTEFLOAT        reduce using rule 83 (quadgeo -> .)
    CTECHAR         reduce using rule 83 (quadgeo -> .)
    CTESTRING       reduce using rule 83 (quadgeo -> .)
    LEFTPAR         reduce using rule 83 (quadgeo -> .)
    TIMES           reduce using rule 83 (quadgeo -> .)
    DIVIDE          reduce using rule 83 (quadgeo -> .)

    quadgeo                        shift and go to state 221

state 190

    (82) geoexp -> assignedexp DIVIDE operatorhandler assignedexp . quadgeo
    (83) quadgeo -> .

    PLUS            reduce using rule 83 (quadgeo -> .)
    REST            reduce using rule 83 (quadgeo -> .)
    LESSER          reduce using rule 83 (quadgeo -> .)
    LESSERAND       reduce using rule 83 (quadgeo -> .)
    GREATER         reduce using rule 83 (quadgeo -> .)
    GREATERAND      reduce using rule 83 (quadgeo -> .)
    NOTSAME         reduce using rule 83 (quadgeo -> .)
    AND             reduce using rule 83 (quadgeo -> .)
    OR              reduce using rule 83 (quadgeo -> .)
    RIGHTSQR        reduce using rule 83 (quadgeo -> .)
    RIGHTPAR        reduce using rule 83 (quadgeo -> .)
    COMMA           reduce using rule 83 (quadgeo -> .)
    SEMICOLON       reduce using rule 83 (quadgeo -> .)
    TO              reduce using rule 83 (quadgeo -> .)
    ID              reduce using rule 83 (quadgeo -> .)
    CTEINT          reduce using rule 83 (quadgeo -> .)
    CTEFLOAT        reduce using rule 83 (quadgeo -> .)
    CTECHAR         reduce using rule 83 (quadgeo -> .)
    CTESTRING       reduce using rule 83 (quadgeo -> .)
    LEFTPAR         reduce using rule 83 (quadgeo -> .)
    TIMES           reduce using rule 83 (quadgeo -> .)
    DIVIDE          reduce using rule 83 (quadgeo -> .)

    quadgeo                        shift and go to state 222

state 191

    (24) callFunction -> ID checkid eraquad LEFTPAR . paramexp checkparam RIGHTPAR quadgosub
    (27) paramexp -> . exp paramquad paramaux
    (28) paramexp -> . exp paramquad COMMA paramaux paramexp
    (29) paramexp -> . empty
    (62) exp -> . andexp quador
    (63) exp -> . andexp quador OR operatorhandler andexp
    (132) empty -> .
    (65) andexp -> . boolexp quadand
    (66) andexp -> . boolexp quadand AND operatorhandler boolexp
    (68) boolexp -> . arithexp
    (69) boolexp -> . boolexp1 arithexp
    (76) arithexp -> . geoexp
    (77) arithexp -> . geoexp PLUS operatorhandler geoexp quadarith
    (78) arithexp -> . geoexp REST operatorhandler geoexp quadarith
    (70) boolexp1 -> . arithexp LESSER operatorhandler arithexp quadbool
    (71) boolexp1 -> . arithexp LESSERAND operatorhandler arithexp quadbool
    (72) boolexp1 -> . arithexp GREATER operatorhandler arithexp quadbool
    (73) boolexp1 -> . arithexp GREATERAND operatorhandler arithexp quadbool
    (74) boolexp1 -> . arithexp NOTSAME operatorhandler arithexp quadbool
    (80) geoexp -> . assignedexp
    (81) geoexp -> . assignedexp TIMES operatorhandler assignedexp quadgeo
    (82) geoexp -> . assignedexp DIVIDE operatorhandler assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub

    RIGHTPAR        reduce using rule 132 (empty -> .)
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)
    LESSER          reduce using rule 132 (empty -> .)
    LESSERAND       reduce using rule 132 (empty -> .)
    GREATER         reduce using rule 132 (empty -> .)
    GREATERAND      reduce using rule 132 (empty -> .)
    NOTSAME         reduce using rule 132 (empty -> .)
    AND             reduce using rule 132 (empty -> .)
    OR              reduce using rule 132 (empty -> .)
    COMMA           reduce using rule 132 (empty -> .)
    ID              shift and go to state 73
    CTEINT          shift and go to state 116
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78

    paramexp                       shift and go to state 223
    exp                            shift and go to state 224
    empty                          shift and go to state 225
    andexp                         shift and go to state 67
    boolexp                        shift and go to state 68
    arithexp                       shift and go to state 69
    boolexp1                       shift and go to state 70
    geoexp                         shift and go to state 71
    assignedexp                    shift and go to state 72
    callFunction                   shift and go to state 77

state 192

    (12) statutes -> reading statutes SEMICOLON statutes .

    RIGHTBR         reduce using rule 12 (statutes -> reading statutes SEMICOLON statutes .)
    SEMICOLON       reduce using rule 12 (statutes -> reading statutes SEMICOLON statutes .)


state 193

    (13) statutes -> writing statutes SEMICOLON statutes .

    RIGHTBR         reduce using rule 13 (statutes -> writing statutes SEMICOLON statutes .)
    SEMICOLON       reduce using rule 13 (statutes -> writing statutes SEMICOLON statutes .)


state 194

    (19) assign -> ID idgetter EQUAL operatorhandler . exp assignquad
    (62) exp -> . andexp quador
    (63) exp -> . andexp quador OR operatorhandler andexp
    (65) andexp -> . boolexp quadand
    (66) andexp -> . boolexp quadand AND operatorhandler boolexp
    (68) boolexp -> . arithexp
    (69) boolexp -> . boolexp1 arithexp
    (76) arithexp -> . geoexp
    (77) arithexp -> . geoexp PLUS operatorhandler geoexp quadarith
    (78) arithexp -> . geoexp REST operatorhandler geoexp quadarith
    (70) boolexp1 -> . arithexp LESSER operatorhandler arithexp quadbool
    (71) boolexp1 -> . arithexp LESSERAND operatorhandler arithexp quadbool
    (72) boolexp1 -> . arithexp GREATER operatorhandler arithexp quadbool
    (73) boolexp1 -> . arithexp GREATERAND operatorhandler arithexp quadbool
    (74) boolexp1 -> . arithexp NOTSAME operatorhandler arithexp quadbool
    (80) geoexp -> . assignedexp
    (81) geoexp -> . assignedexp TIMES operatorhandler assignedexp quadgeo
    (82) geoexp -> . assignedexp DIVIDE operatorhandler assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (132) empty -> .

    ID              shift and go to state 73
    CTEINT          shift and go to state 116
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)
    LESSER          reduce using rule 132 (empty -> .)
    LESSERAND       reduce using rule 132 (empty -> .)
    GREATER         reduce using rule 132 (empty -> .)
    GREATERAND      reduce using rule 132 (empty -> .)
    NOTSAME         reduce using rule 132 (empty -> .)
    AND             reduce using rule 132 (empty -> .)
    OR              reduce using rule 132 (empty -> .)
    SEMICOLON       reduce using rule 132 (empty -> .)
    TO              reduce using rule 132 (empty -> .)

    exp                            shift and go to state 226
    andexp                         shift and go to state 67
    boolexp                        shift and go to state 68
    arithexp                       shift and go to state 69
    boolexp1                       shift and go to state 70
    geoexp                         shift and go to state 71
    assignedexp                    shift and go to state 72
    callFunction                   shift and go to state 77
    empty                          shift and go to state 79

state 195

    (20) assign -> ID idgetter array EQUAL . operatorhandler exp assignquad
    (94) operatorhandler -> .

    ID              reduce using rule 94 (operatorhandler -> .)
    CTEINT          reduce using rule 94 (operatorhandler -> .)
    CTEFLOAT        reduce using rule 94 (operatorhandler -> .)
    CTECHAR         reduce using rule 94 (operatorhandler -> .)
    CTESTRING       reduce using rule 94 (operatorhandler -> .)
    LEFTPAR         reduce using rule 94 (operatorhandler -> .)
    OR              reduce using rule 94 (operatorhandler -> .)
    AND             reduce using rule 94 (operatorhandler -> .)
    LESSER          reduce using rule 94 (operatorhandler -> .)
    LESSERAND       reduce using rule 94 (operatorhandler -> .)
    GREATER         reduce using rule 94 (operatorhandler -> .)
    GREATERAND      reduce using rule 94 (operatorhandler -> .)
    NOTSAME         reduce using rule 94 (operatorhandler -> .)
    PLUS            reduce using rule 94 (operatorhandler -> .)
    REST            reduce using rule 94 (operatorhandler -> .)
    TIMES           reduce using rule 94 (operatorhandler -> .)
    DIVIDE          reduce using rule 94 (operatorhandler -> .)
    SEMICOLON       reduce using rule 94 (operatorhandler -> .)
    TO              reduce using rule 94 (operatorhandler -> .)

    operatorhandler                shift and go to state 227

state 196

    (34) reading -> READ auxreading LEFTPAR reading1 . RIGHTPAR

    RIGHTPAR        shift and go to state 228


state 197

    (35) reading1 -> reading2 .

    RIGHTPAR        reduce using rule 35 (reading1 -> reading2 .)


state 198

    (36) reading1 -> empty .
    (92) assignedexp -> empty .

  ! reduce/reduce conflict for RIGHTPAR resolved using rule 36 (reading1 -> empty .)
    RIGHTPAR        reduce using rule 36 (reading1 -> empty .)
    TIMES           reduce using rule 92 (assignedexp -> empty .)
    DIVIDE          reduce using rule 92 (assignedexp -> empty .)
    PLUS            reduce using rule 92 (assignedexp -> empty .)
    REST            reduce using rule 92 (assignedexp -> empty .)
    LESSER          reduce using rule 92 (assignedexp -> empty .)
    LESSERAND       reduce using rule 92 (assignedexp -> empty .)
    GREATER         reduce using rule 92 (assignedexp -> empty .)
    GREATERAND      reduce using rule 92 (assignedexp -> empty .)
    NOTSAME         reduce using rule 92 (assignedexp -> empty .)
    AND             reduce using rule 92 (assignedexp -> empty .)
    OR              reduce using rule 92 (assignedexp -> empty .)
    COMMA           reduce using rule 92 (assignedexp -> empty .)

  ! RIGHTPAR        [ reduce using rule 92 (assignedexp -> empty .) ]


state 199

    (37) reading2 -> exp . readingquad
    (38) reading2 -> exp . readingquad COMMA auxreading reading2
    (40) readingquad -> .

    COMMA           reduce using rule 40 (readingquad -> .)
    RIGHTPAR        reduce using rule 40 (readingquad -> .)

    readingquad                    shift and go to state 229

state 200

    (41) writing -> WRITE auxwriting LEFTPAR writing1 . RIGHTPAR

    RIGHTPAR        shift and go to state 230


state 201

    (42) writing1 -> writing2 .

    RIGHTPAR        reduce using rule 42 (writing1 -> writing2 .)


state 202

    (43) writing1 -> empty .
    (92) assignedexp -> empty .

  ! reduce/reduce conflict for RIGHTPAR resolved using rule 43 (writing1 -> empty .)
    RIGHTPAR        reduce using rule 43 (writing1 -> empty .)
    TIMES           reduce using rule 92 (assignedexp -> empty .)
    DIVIDE          reduce using rule 92 (assignedexp -> empty .)
    PLUS            reduce using rule 92 (assignedexp -> empty .)
    REST            reduce using rule 92 (assignedexp -> empty .)
    LESSER          reduce using rule 92 (assignedexp -> empty .)
    LESSERAND       reduce using rule 92 (assignedexp -> empty .)
    GREATER         reduce using rule 92 (assignedexp -> empty .)
    GREATERAND      reduce using rule 92 (assignedexp -> empty .)
    NOTSAME         reduce using rule 92 (assignedexp -> empty .)
    AND             reduce using rule 92 (assignedexp -> empty .)
    OR              reduce using rule 92 (assignedexp -> empty .)
    COMMA           reduce using rule 92 (assignedexp -> empty .)

  ! RIGHTPAR        [ reduce using rule 92 (assignedexp -> empty .) ]


state 203

    (44) writing2 -> exp . writingquad
    (45) writing2 -> exp . writingquad COMMA auxwriting writing2
    (47) writingquad -> .

    COMMA           reduce using rule 47 (writingquad -> .)
    RIGHTPAR        reduce using rule 47 (writingquad -> .)

    writingquad                    shift and go to state 231

state 204

    (49) if -> IF LEFTPAR exp RIGHTPAR . quadif THEN LEFTBR statutes RIGHTBR else endif
    (52) quadif -> .

    THEN            reduce using rule 52 (quadif -> .)

    quadif                         shift and go to state 232

state 205

    (59) while -> WHILE auxwhile LEFTPAR exp . RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop

    RIGHTPAR        shift and go to state 233


state 206

    (56) for -> FOR auxfor assign TO . CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop

    CTEINT          shift and go to state 234


state 207

    (130) return -> RETURN LEFTPAR exp RIGHTPAR . SEMICOLON
    (131) return -> RETURN LEFTPAR exp RIGHTPAR .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 235
    ID              reduce using rule 131 (return -> RETURN LEFTPAR exp RIGHTPAR .)
    READ            reduce using rule 131 (return -> RETURN LEFTPAR exp RIGHTPAR .)
    WRITE           reduce using rule 131 (return -> RETURN LEFTPAR exp RIGHTPAR .)
    IF              reduce using rule 131 (return -> RETURN LEFTPAR exp RIGHTPAR .)
    WHILE           reduce using rule 131 (return -> RETURN LEFTPAR exp RIGHTPAR .)
    FOR             reduce using rule 131 (return -> RETURN LEFTPAR exp RIGHTPAR .)
    RETURN          reduce using rule 131 (return -> RETURN LEFTPAR exp RIGHTPAR .)
    RIGHTBR         reduce using rule 131 (return -> RETURN LEFTPAR exp RIGHTPAR .)

  ! SEMICOLON       [ reduce using rule 131 (return -> RETURN LEFTPAR exp RIGHTPAR .) ]


state 208

    (117) functions1 -> ID storefunct LEFTPAR args RIGHTPAR vars LEFTBR . setaddstart statutes RIGHTBR
    (119) setaddstart -> .

    ID              reduce using rule 119 (setaddstart -> .)
    READ            reduce using rule 119 (setaddstart -> .)
    WRITE           reduce using rule 119 (setaddstart -> .)
    IF              reduce using rule 119 (setaddstart -> .)
    WHILE           reduce using rule 119 (setaddstart -> .)
    FOR             reduce using rule 119 (setaddstart -> .)
    RETURN          reduce using rule 119 (setaddstart -> .)
    RIGHTBR         reduce using rule 119 (setaddstart -> .)

    setaddstart                    shift and go to state 236

state 209

    (122) args1 -> INT saveTypeofVar COLON ID . mulParam nextParam
    (127) mulParam -> .

    COMMA           reduce using rule 127 (mulParam -> .)
    RIGHTPAR        reduce using rule 127 (mulParam -> .)

    mulParam                       shift and go to state 237

state 210

    (123) args1 -> FLOAT saveTypeofVar COLON ID . mulParam nextParam
    (127) mulParam -> .

    COMMA           reduce using rule 127 (mulParam -> .)
    RIGHTPAR        reduce using rule 127 (mulParam -> .)

    mulParam                       shift and go to state 238

state 211

    (124) args1 -> CHAR saveTypeofVar COLON ID . mulParam nextParam
    (127) mulParam -> .

    COMMA           reduce using rule 127 (mulParam -> .)
    RIGHTPAR        reduce using rule 127 (mulParam -> .)

    mulParam                       shift and go to state 239

state 212

    (63) exp -> andexp quador OR operatorhandler andexp .

    RIGHTSQR        reduce using rule 63 (exp -> andexp quador OR operatorhandler andexp .)
    RIGHTPAR        reduce using rule 63 (exp -> andexp quador OR operatorhandler andexp .)
    COMMA           reduce using rule 63 (exp -> andexp quador OR operatorhandler andexp .)
    SEMICOLON       reduce using rule 63 (exp -> andexp quador OR operatorhandler andexp .)
    TO              reduce using rule 63 (exp -> andexp quador OR operatorhandler andexp .)


state 213

    (66) andexp -> boolexp quadand AND operatorhandler boolexp .

    OR              reduce using rule 66 (andexp -> boolexp quadand AND operatorhandler boolexp .)
    RIGHTSQR        reduce using rule 66 (andexp -> boolexp quadand AND operatorhandler boolexp .)
    RIGHTPAR        reduce using rule 66 (andexp -> boolexp quadand AND operatorhandler boolexp .)
    COMMA           reduce using rule 66 (andexp -> boolexp quadand AND operatorhandler boolexp .)
    SEMICOLON       reduce using rule 66 (andexp -> boolexp quadand AND operatorhandler boolexp .)
    TO              reduce using rule 66 (andexp -> boolexp quadand AND operatorhandler boolexp .)


state 214

    (70) boolexp1 -> arithexp LESSER operatorhandler arithexp quadbool .

    ID              reduce using rule 70 (boolexp1 -> arithexp LESSER operatorhandler arithexp quadbool .)
    CTEINT          reduce using rule 70 (boolexp1 -> arithexp LESSER operatorhandler arithexp quadbool .)
    CTEFLOAT        reduce using rule 70 (boolexp1 -> arithexp LESSER operatorhandler arithexp quadbool .)
    CTECHAR         reduce using rule 70 (boolexp1 -> arithexp LESSER operatorhandler arithexp quadbool .)
    CTESTRING       reduce using rule 70 (boolexp1 -> arithexp LESSER operatorhandler arithexp quadbool .)
    LEFTPAR         reduce using rule 70 (boolexp1 -> arithexp LESSER operatorhandler arithexp quadbool .)
    PLUS            reduce using rule 70 (boolexp1 -> arithexp LESSER operatorhandler arithexp quadbool .)
    REST            reduce using rule 70 (boolexp1 -> arithexp LESSER operatorhandler arithexp quadbool .)
    TIMES           reduce using rule 70 (boolexp1 -> arithexp LESSER operatorhandler arithexp quadbool .)
    DIVIDE          reduce using rule 70 (boolexp1 -> arithexp LESSER operatorhandler arithexp quadbool .)
    AND             reduce using rule 70 (boolexp1 -> arithexp LESSER operatorhandler arithexp quadbool .)
    OR              reduce using rule 70 (boolexp1 -> arithexp LESSER operatorhandler arithexp quadbool .)
    RIGHTSQR        reduce using rule 70 (boolexp1 -> arithexp LESSER operatorhandler arithexp quadbool .)
    RIGHTPAR        reduce using rule 70 (boolexp1 -> arithexp LESSER operatorhandler arithexp quadbool .)
    COMMA           reduce using rule 70 (boolexp1 -> arithexp LESSER operatorhandler arithexp quadbool .)
    SEMICOLON       reduce using rule 70 (boolexp1 -> arithexp LESSER operatorhandler arithexp quadbool .)
    TO              reduce using rule 70 (boolexp1 -> arithexp LESSER operatorhandler arithexp quadbool .)


state 215

    (71) boolexp1 -> arithexp LESSERAND operatorhandler arithexp quadbool .

    ID              reduce using rule 71 (boolexp1 -> arithexp LESSERAND operatorhandler arithexp quadbool .)
    CTEINT          reduce using rule 71 (boolexp1 -> arithexp LESSERAND operatorhandler arithexp quadbool .)
    CTEFLOAT        reduce using rule 71 (boolexp1 -> arithexp LESSERAND operatorhandler arithexp quadbool .)
    CTECHAR         reduce using rule 71 (boolexp1 -> arithexp LESSERAND operatorhandler arithexp quadbool .)
    CTESTRING       reduce using rule 71 (boolexp1 -> arithexp LESSERAND operatorhandler arithexp quadbool .)
    LEFTPAR         reduce using rule 71 (boolexp1 -> arithexp LESSERAND operatorhandler arithexp quadbool .)
    PLUS            reduce using rule 71 (boolexp1 -> arithexp LESSERAND operatorhandler arithexp quadbool .)
    REST            reduce using rule 71 (boolexp1 -> arithexp LESSERAND operatorhandler arithexp quadbool .)
    TIMES           reduce using rule 71 (boolexp1 -> arithexp LESSERAND operatorhandler arithexp quadbool .)
    DIVIDE          reduce using rule 71 (boolexp1 -> arithexp LESSERAND operatorhandler arithexp quadbool .)
    AND             reduce using rule 71 (boolexp1 -> arithexp LESSERAND operatorhandler arithexp quadbool .)
    OR              reduce using rule 71 (boolexp1 -> arithexp LESSERAND operatorhandler arithexp quadbool .)
    RIGHTSQR        reduce using rule 71 (boolexp1 -> arithexp LESSERAND operatorhandler arithexp quadbool .)
    RIGHTPAR        reduce using rule 71 (boolexp1 -> arithexp LESSERAND operatorhandler arithexp quadbool .)
    COMMA           reduce using rule 71 (boolexp1 -> arithexp LESSERAND operatorhandler arithexp quadbool .)
    SEMICOLON       reduce using rule 71 (boolexp1 -> arithexp LESSERAND operatorhandler arithexp quadbool .)
    TO              reduce using rule 71 (boolexp1 -> arithexp LESSERAND operatorhandler arithexp quadbool .)


state 216

    (72) boolexp1 -> arithexp GREATER operatorhandler arithexp quadbool .

    ID              reduce using rule 72 (boolexp1 -> arithexp GREATER operatorhandler arithexp quadbool .)
    CTEINT          reduce using rule 72 (boolexp1 -> arithexp GREATER operatorhandler arithexp quadbool .)
    CTEFLOAT        reduce using rule 72 (boolexp1 -> arithexp GREATER operatorhandler arithexp quadbool .)
    CTECHAR         reduce using rule 72 (boolexp1 -> arithexp GREATER operatorhandler arithexp quadbool .)
    CTESTRING       reduce using rule 72 (boolexp1 -> arithexp GREATER operatorhandler arithexp quadbool .)
    LEFTPAR         reduce using rule 72 (boolexp1 -> arithexp GREATER operatorhandler arithexp quadbool .)
    PLUS            reduce using rule 72 (boolexp1 -> arithexp GREATER operatorhandler arithexp quadbool .)
    REST            reduce using rule 72 (boolexp1 -> arithexp GREATER operatorhandler arithexp quadbool .)
    TIMES           reduce using rule 72 (boolexp1 -> arithexp GREATER operatorhandler arithexp quadbool .)
    DIVIDE          reduce using rule 72 (boolexp1 -> arithexp GREATER operatorhandler arithexp quadbool .)
    AND             reduce using rule 72 (boolexp1 -> arithexp GREATER operatorhandler arithexp quadbool .)
    OR              reduce using rule 72 (boolexp1 -> arithexp GREATER operatorhandler arithexp quadbool .)
    RIGHTSQR        reduce using rule 72 (boolexp1 -> arithexp GREATER operatorhandler arithexp quadbool .)
    RIGHTPAR        reduce using rule 72 (boolexp1 -> arithexp GREATER operatorhandler arithexp quadbool .)
    COMMA           reduce using rule 72 (boolexp1 -> arithexp GREATER operatorhandler arithexp quadbool .)
    SEMICOLON       reduce using rule 72 (boolexp1 -> arithexp GREATER operatorhandler arithexp quadbool .)
    TO              reduce using rule 72 (boolexp1 -> arithexp GREATER operatorhandler arithexp quadbool .)


state 217

    (73) boolexp1 -> arithexp GREATERAND operatorhandler arithexp quadbool .

    ID              reduce using rule 73 (boolexp1 -> arithexp GREATERAND operatorhandler arithexp quadbool .)
    CTEINT          reduce using rule 73 (boolexp1 -> arithexp GREATERAND operatorhandler arithexp quadbool .)
    CTEFLOAT        reduce using rule 73 (boolexp1 -> arithexp GREATERAND operatorhandler arithexp quadbool .)
    CTECHAR         reduce using rule 73 (boolexp1 -> arithexp GREATERAND operatorhandler arithexp quadbool .)
    CTESTRING       reduce using rule 73 (boolexp1 -> arithexp GREATERAND operatorhandler arithexp quadbool .)
    LEFTPAR         reduce using rule 73 (boolexp1 -> arithexp GREATERAND operatorhandler arithexp quadbool .)
    PLUS            reduce using rule 73 (boolexp1 -> arithexp GREATERAND operatorhandler arithexp quadbool .)
    REST            reduce using rule 73 (boolexp1 -> arithexp GREATERAND operatorhandler arithexp quadbool .)
    TIMES           reduce using rule 73 (boolexp1 -> arithexp GREATERAND operatorhandler arithexp quadbool .)
    DIVIDE          reduce using rule 73 (boolexp1 -> arithexp GREATERAND operatorhandler arithexp quadbool .)
    AND             reduce using rule 73 (boolexp1 -> arithexp GREATERAND operatorhandler arithexp quadbool .)
    OR              reduce using rule 73 (boolexp1 -> arithexp GREATERAND operatorhandler arithexp quadbool .)
    RIGHTSQR        reduce using rule 73 (boolexp1 -> arithexp GREATERAND operatorhandler arithexp quadbool .)
    RIGHTPAR        reduce using rule 73 (boolexp1 -> arithexp GREATERAND operatorhandler arithexp quadbool .)
    COMMA           reduce using rule 73 (boolexp1 -> arithexp GREATERAND operatorhandler arithexp quadbool .)
    SEMICOLON       reduce using rule 73 (boolexp1 -> arithexp GREATERAND operatorhandler arithexp quadbool .)
    TO              reduce using rule 73 (boolexp1 -> arithexp GREATERAND operatorhandler arithexp quadbool .)


state 218

    (74) boolexp1 -> arithexp NOTSAME operatorhandler arithexp quadbool .

    ID              reduce using rule 74 (boolexp1 -> arithexp NOTSAME operatorhandler arithexp quadbool .)
    CTEINT          reduce using rule 74 (boolexp1 -> arithexp NOTSAME operatorhandler arithexp quadbool .)
    CTEFLOAT        reduce using rule 74 (boolexp1 -> arithexp NOTSAME operatorhandler arithexp quadbool .)
    CTECHAR         reduce using rule 74 (boolexp1 -> arithexp NOTSAME operatorhandler arithexp quadbool .)
    CTESTRING       reduce using rule 74 (boolexp1 -> arithexp NOTSAME operatorhandler arithexp quadbool .)
    LEFTPAR         reduce using rule 74 (boolexp1 -> arithexp NOTSAME operatorhandler arithexp quadbool .)
    PLUS            reduce using rule 74 (boolexp1 -> arithexp NOTSAME operatorhandler arithexp quadbool .)
    REST            reduce using rule 74 (boolexp1 -> arithexp NOTSAME operatorhandler arithexp quadbool .)
    TIMES           reduce using rule 74 (boolexp1 -> arithexp NOTSAME operatorhandler arithexp quadbool .)
    DIVIDE          reduce using rule 74 (boolexp1 -> arithexp NOTSAME operatorhandler arithexp quadbool .)
    AND             reduce using rule 74 (boolexp1 -> arithexp NOTSAME operatorhandler arithexp quadbool .)
    OR              reduce using rule 74 (boolexp1 -> arithexp NOTSAME operatorhandler arithexp quadbool .)
    RIGHTSQR        reduce using rule 74 (boolexp1 -> arithexp NOTSAME operatorhandler arithexp quadbool .)
    RIGHTPAR        reduce using rule 74 (boolexp1 -> arithexp NOTSAME operatorhandler arithexp quadbool .)
    COMMA           reduce using rule 74 (boolexp1 -> arithexp NOTSAME operatorhandler arithexp quadbool .)
    SEMICOLON       reduce using rule 74 (boolexp1 -> arithexp NOTSAME operatorhandler arithexp quadbool .)
    TO              reduce using rule 74 (boolexp1 -> arithexp NOTSAME operatorhandler arithexp quadbool .)


state 219

    (77) arithexp -> geoexp PLUS operatorhandler geoexp quadarith .

    LESSER          reduce using rule 77 (arithexp -> geoexp PLUS operatorhandler geoexp quadarith .)
    LESSERAND       reduce using rule 77 (arithexp -> geoexp PLUS operatorhandler geoexp quadarith .)
    GREATER         reduce using rule 77 (arithexp -> geoexp PLUS operatorhandler geoexp quadarith .)
    GREATERAND      reduce using rule 77 (arithexp -> geoexp PLUS operatorhandler geoexp quadarith .)
    NOTSAME         reduce using rule 77 (arithexp -> geoexp PLUS operatorhandler geoexp quadarith .)
    AND             reduce using rule 77 (arithexp -> geoexp PLUS operatorhandler geoexp quadarith .)
    OR              reduce using rule 77 (arithexp -> geoexp PLUS operatorhandler geoexp quadarith .)
    RIGHTSQR        reduce using rule 77 (arithexp -> geoexp PLUS operatorhandler geoexp quadarith .)
    RIGHTPAR        reduce using rule 77 (arithexp -> geoexp PLUS operatorhandler geoexp quadarith .)
    COMMA           reduce using rule 77 (arithexp -> geoexp PLUS operatorhandler geoexp quadarith .)
    SEMICOLON       reduce using rule 77 (arithexp -> geoexp PLUS operatorhandler geoexp quadarith .)
    TO              reduce using rule 77 (arithexp -> geoexp PLUS operatorhandler geoexp quadarith .)
    ID              reduce using rule 77 (arithexp -> geoexp PLUS operatorhandler geoexp quadarith .)
    CTEINT          reduce using rule 77 (arithexp -> geoexp PLUS operatorhandler geoexp quadarith .)
    CTEFLOAT        reduce using rule 77 (arithexp -> geoexp PLUS operatorhandler geoexp quadarith .)
    CTECHAR         reduce using rule 77 (arithexp -> geoexp PLUS operatorhandler geoexp quadarith .)
    CTESTRING       reduce using rule 77 (arithexp -> geoexp PLUS operatorhandler geoexp quadarith .)
    LEFTPAR         reduce using rule 77 (arithexp -> geoexp PLUS operatorhandler geoexp quadarith .)
    PLUS            reduce using rule 77 (arithexp -> geoexp PLUS operatorhandler geoexp quadarith .)
    REST            reduce using rule 77 (arithexp -> geoexp PLUS operatorhandler geoexp quadarith .)
    TIMES           reduce using rule 77 (arithexp -> geoexp PLUS operatorhandler geoexp quadarith .)
    DIVIDE          reduce using rule 77 (arithexp -> geoexp PLUS operatorhandler geoexp quadarith .)


state 220

    (78) arithexp -> geoexp REST operatorhandler geoexp quadarith .

    LESSER          reduce using rule 78 (arithexp -> geoexp REST operatorhandler geoexp quadarith .)
    LESSERAND       reduce using rule 78 (arithexp -> geoexp REST operatorhandler geoexp quadarith .)
    GREATER         reduce using rule 78 (arithexp -> geoexp REST operatorhandler geoexp quadarith .)
    GREATERAND      reduce using rule 78 (arithexp -> geoexp REST operatorhandler geoexp quadarith .)
    NOTSAME         reduce using rule 78 (arithexp -> geoexp REST operatorhandler geoexp quadarith .)
    AND             reduce using rule 78 (arithexp -> geoexp REST operatorhandler geoexp quadarith .)
    OR              reduce using rule 78 (arithexp -> geoexp REST operatorhandler geoexp quadarith .)
    RIGHTSQR        reduce using rule 78 (arithexp -> geoexp REST operatorhandler geoexp quadarith .)
    RIGHTPAR        reduce using rule 78 (arithexp -> geoexp REST operatorhandler geoexp quadarith .)
    COMMA           reduce using rule 78 (arithexp -> geoexp REST operatorhandler geoexp quadarith .)
    SEMICOLON       reduce using rule 78 (arithexp -> geoexp REST operatorhandler geoexp quadarith .)
    TO              reduce using rule 78 (arithexp -> geoexp REST operatorhandler geoexp quadarith .)
    ID              reduce using rule 78 (arithexp -> geoexp REST operatorhandler geoexp quadarith .)
    CTEINT          reduce using rule 78 (arithexp -> geoexp REST operatorhandler geoexp quadarith .)
    CTEFLOAT        reduce using rule 78 (arithexp -> geoexp REST operatorhandler geoexp quadarith .)
    CTECHAR         reduce using rule 78 (arithexp -> geoexp REST operatorhandler geoexp quadarith .)
    CTESTRING       reduce using rule 78 (arithexp -> geoexp REST operatorhandler geoexp quadarith .)
    LEFTPAR         reduce using rule 78 (arithexp -> geoexp REST operatorhandler geoexp quadarith .)
    PLUS            reduce using rule 78 (arithexp -> geoexp REST operatorhandler geoexp quadarith .)
    REST            reduce using rule 78 (arithexp -> geoexp REST operatorhandler geoexp quadarith .)
    TIMES           reduce using rule 78 (arithexp -> geoexp REST operatorhandler geoexp quadarith .)
    DIVIDE          reduce using rule 78 (arithexp -> geoexp REST operatorhandler geoexp quadarith .)


state 221

    (81) geoexp -> assignedexp TIMES operatorhandler assignedexp quadgeo .

    PLUS            reduce using rule 81 (geoexp -> assignedexp TIMES operatorhandler assignedexp quadgeo .)
    REST            reduce using rule 81 (geoexp -> assignedexp TIMES operatorhandler assignedexp quadgeo .)
    LESSER          reduce using rule 81 (geoexp -> assignedexp TIMES operatorhandler assignedexp quadgeo .)
    LESSERAND       reduce using rule 81 (geoexp -> assignedexp TIMES operatorhandler assignedexp quadgeo .)
    GREATER         reduce using rule 81 (geoexp -> assignedexp TIMES operatorhandler assignedexp quadgeo .)
    GREATERAND      reduce using rule 81 (geoexp -> assignedexp TIMES operatorhandler assignedexp quadgeo .)
    NOTSAME         reduce using rule 81 (geoexp -> assignedexp TIMES operatorhandler assignedexp quadgeo .)
    AND             reduce using rule 81 (geoexp -> assignedexp TIMES operatorhandler assignedexp quadgeo .)
    OR              reduce using rule 81 (geoexp -> assignedexp TIMES operatorhandler assignedexp quadgeo .)
    RIGHTSQR        reduce using rule 81 (geoexp -> assignedexp TIMES operatorhandler assignedexp quadgeo .)
    RIGHTPAR        reduce using rule 81 (geoexp -> assignedexp TIMES operatorhandler assignedexp quadgeo .)
    COMMA           reduce using rule 81 (geoexp -> assignedexp TIMES operatorhandler assignedexp quadgeo .)
    SEMICOLON       reduce using rule 81 (geoexp -> assignedexp TIMES operatorhandler assignedexp quadgeo .)
    TO              reduce using rule 81 (geoexp -> assignedexp TIMES operatorhandler assignedexp quadgeo .)
    ID              reduce using rule 81 (geoexp -> assignedexp TIMES operatorhandler assignedexp quadgeo .)
    CTEINT          reduce using rule 81 (geoexp -> assignedexp TIMES operatorhandler assignedexp quadgeo .)
    CTEFLOAT        reduce using rule 81 (geoexp -> assignedexp TIMES operatorhandler assignedexp quadgeo .)
    CTECHAR         reduce using rule 81 (geoexp -> assignedexp TIMES operatorhandler assignedexp quadgeo .)
    CTESTRING       reduce using rule 81 (geoexp -> assignedexp TIMES operatorhandler assignedexp quadgeo .)
    LEFTPAR         reduce using rule 81 (geoexp -> assignedexp TIMES operatorhandler assignedexp quadgeo .)
    TIMES           reduce using rule 81 (geoexp -> assignedexp TIMES operatorhandler assignedexp quadgeo .)
    DIVIDE          reduce using rule 81 (geoexp -> assignedexp TIMES operatorhandler assignedexp quadgeo .)


state 222

    (82) geoexp -> assignedexp DIVIDE operatorhandler assignedexp quadgeo .

    PLUS            reduce using rule 82 (geoexp -> assignedexp DIVIDE operatorhandler assignedexp quadgeo .)
    REST            reduce using rule 82 (geoexp -> assignedexp DIVIDE operatorhandler assignedexp quadgeo .)
    LESSER          reduce using rule 82 (geoexp -> assignedexp DIVIDE operatorhandler assignedexp quadgeo .)
    LESSERAND       reduce using rule 82 (geoexp -> assignedexp DIVIDE operatorhandler assignedexp quadgeo .)
    GREATER         reduce using rule 82 (geoexp -> assignedexp DIVIDE operatorhandler assignedexp quadgeo .)
    GREATERAND      reduce using rule 82 (geoexp -> assignedexp DIVIDE operatorhandler assignedexp quadgeo .)
    NOTSAME         reduce using rule 82 (geoexp -> assignedexp DIVIDE operatorhandler assignedexp quadgeo .)
    AND             reduce using rule 82 (geoexp -> assignedexp DIVIDE operatorhandler assignedexp quadgeo .)
    OR              reduce using rule 82 (geoexp -> assignedexp DIVIDE operatorhandler assignedexp quadgeo .)
    RIGHTSQR        reduce using rule 82 (geoexp -> assignedexp DIVIDE operatorhandler assignedexp quadgeo .)
    RIGHTPAR        reduce using rule 82 (geoexp -> assignedexp DIVIDE operatorhandler assignedexp quadgeo .)
    COMMA           reduce using rule 82 (geoexp -> assignedexp DIVIDE operatorhandler assignedexp quadgeo .)
    SEMICOLON       reduce using rule 82 (geoexp -> assignedexp DIVIDE operatorhandler assignedexp quadgeo .)
    TO              reduce using rule 82 (geoexp -> assignedexp DIVIDE operatorhandler assignedexp quadgeo .)
    ID              reduce using rule 82 (geoexp -> assignedexp DIVIDE operatorhandler assignedexp quadgeo .)
    CTEINT          reduce using rule 82 (geoexp -> assignedexp DIVIDE operatorhandler assignedexp quadgeo .)
    CTEFLOAT        reduce using rule 82 (geoexp -> assignedexp DIVIDE operatorhandler assignedexp quadgeo .)
    CTECHAR         reduce using rule 82 (geoexp -> assignedexp DIVIDE operatorhandler assignedexp quadgeo .)
    CTESTRING       reduce using rule 82 (geoexp -> assignedexp DIVIDE operatorhandler assignedexp quadgeo .)
    LEFTPAR         reduce using rule 82 (geoexp -> assignedexp DIVIDE operatorhandler assignedexp quadgeo .)
    TIMES           reduce using rule 82 (geoexp -> assignedexp DIVIDE operatorhandler assignedexp quadgeo .)
    DIVIDE          reduce using rule 82 (geoexp -> assignedexp DIVIDE operatorhandler assignedexp quadgeo .)


state 223

    (24) callFunction -> ID checkid eraquad LEFTPAR paramexp . checkparam RIGHTPAR quadgosub
    (32) checkparam -> .

    RIGHTPAR        reduce using rule 32 (checkparam -> .)

    checkparam                     shift and go to state 240

state 224

    (27) paramexp -> exp . paramquad paramaux
    (28) paramexp -> exp . paramquad COMMA paramaux paramexp
    (31) paramquad -> .

    COMMA           reduce using rule 31 (paramquad -> .)
    RIGHTPAR        reduce using rule 31 (paramquad -> .)

    paramquad                      shift and go to state 241

state 225

    (29) paramexp -> empty .
    (92) assignedexp -> empty .

  ! reduce/reduce conflict for RIGHTPAR resolved using rule 29 (paramexp -> empty .)
    RIGHTPAR        reduce using rule 29 (paramexp -> empty .)
    TIMES           reduce using rule 92 (assignedexp -> empty .)
    DIVIDE          reduce using rule 92 (assignedexp -> empty .)
    PLUS            reduce using rule 92 (assignedexp -> empty .)
    REST            reduce using rule 92 (assignedexp -> empty .)
    LESSER          reduce using rule 92 (assignedexp -> empty .)
    LESSERAND       reduce using rule 92 (assignedexp -> empty .)
    GREATER         reduce using rule 92 (assignedexp -> empty .)
    GREATERAND      reduce using rule 92 (assignedexp -> empty .)
    NOTSAME         reduce using rule 92 (assignedexp -> empty .)
    AND             reduce using rule 92 (assignedexp -> empty .)
    OR              reduce using rule 92 (assignedexp -> empty .)
    COMMA           reduce using rule 92 (assignedexp -> empty .)

  ! RIGHTPAR        [ reduce using rule 92 (assignedexp -> empty .) ]


state 226

    (19) assign -> ID idgetter EQUAL operatorhandler exp . assignquad
    (23) assignquad -> .

    SEMICOLON       reduce using rule 23 (assignquad -> .)
    TO              reduce using rule 23 (assignquad -> .)

    assignquad                     shift and go to state 242

state 227

    (20) assign -> ID idgetter array EQUAL operatorhandler . exp assignquad
    (62) exp -> . andexp quador
    (63) exp -> . andexp quador OR operatorhandler andexp
    (65) andexp -> . boolexp quadand
    (66) andexp -> . boolexp quadand AND operatorhandler boolexp
    (68) boolexp -> . arithexp
    (69) boolexp -> . boolexp1 arithexp
    (76) arithexp -> . geoexp
    (77) arithexp -> . geoexp PLUS operatorhandler geoexp quadarith
    (78) arithexp -> . geoexp REST operatorhandler geoexp quadarith
    (70) boolexp1 -> . arithexp LESSER operatorhandler arithexp quadbool
    (71) boolexp1 -> . arithexp LESSERAND operatorhandler arithexp quadbool
    (72) boolexp1 -> . arithexp GREATER operatorhandler arithexp quadbool
    (73) boolexp1 -> . arithexp GREATERAND operatorhandler arithexp quadbool
    (74) boolexp1 -> . arithexp NOTSAME operatorhandler arithexp quadbool
    (80) geoexp -> . assignedexp
    (81) geoexp -> . assignedexp TIMES operatorhandler assignedexp quadgeo
    (82) geoexp -> . assignedexp DIVIDE operatorhandler assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (132) empty -> .

    ID              shift and go to state 73
    CTEINT          shift and go to state 116
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)
    LESSER          reduce using rule 132 (empty -> .)
    LESSERAND       reduce using rule 132 (empty -> .)
    GREATER         reduce using rule 132 (empty -> .)
    GREATERAND      reduce using rule 132 (empty -> .)
    NOTSAME         reduce using rule 132 (empty -> .)
    AND             reduce using rule 132 (empty -> .)
    OR              reduce using rule 132 (empty -> .)
    SEMICOLON       reduce using rule 132 (empty -> .)
    TO              reduce using rule 132 (empty -> .)

    exp                            shift and go to state 243
    andexp                         shift and go to state 67
    boolexp                        shift and go to state 68
    arithexp                       shift and go to state 69
    boolexp1                       shift and go to state 70
    geoexp                         shift and go to state 71
    assignedexp                    shift and go to state 72
    callFunction                   shift and go to state 77
    empty                          shift and go to state 79

state 228

    (34) reading -> READ auxreading LEFTPAR reading1 RIGHTPAR .

    ID              reduce using rule 34 (reading -> READ auxreading LEFTPAR reading1 RIGHTPAR .)
    READ            reduce using rule 34 (reading -> READ auxreading LEFTPAR reading1 RIGHTPAR .)
    WRITE           reduce using rule 34 (reading -> READ auxreading LEFTPAR reading1 RIGHTPAR .)
    IF              reduce using rule 34 (reading -> READ auxreading LEFTPAR reading1 RIGHTPAR .)
    WHILE           reduce using rule 34 (reading -> READ auxreading LEFTPAR reading1 RIGHTPAR .)
    FOR             reduce using rule 34 (reading -> READ auxreading LEFTPAR reading1 RIGHTPAR .)
    RETURN          reduce using rule 34 (reading -> READ auxreading LEFTPAR reading1 RIGHTPAR .)
    SEMICOLON       reduce using rule 34 (reading -> READ auxreading LEFTPAR reading1 RIGHTPAR .)


state 229

    (37) reading2 -> exp readingquad .
    (38) reading2 -> exp readingquad . COMMA auxreading reading2

    RIGHTPAR        reduce using rule 37 (reading2 -> exp readingquad .)
    COMMA           shift and go to state 244


state 230

    (41) writing -> WRITE auxwriting LEFTPAR writing1 RIGHTPAR .

    ID              reduce using rule 41 (writing -> WRITE auxwriting LEFTPAR writing1 RIGHTPAR .)
    READ            reduce using rule 41 (writing -> WRITE auxwriting LEFTPAR writing1 RIGHTPAR .)
    WRITE           reduce using rule 41 (writing -> WRITE auxwriting LEFTPAR writing1 RIGHTPAR .)
    IF              reduce using rule 41 (writing -> WRITE auxwriting LEFTPAR writing1 RIGHTPAR .)
    WHILE           reduce using rule 41 (writing -> WRITE auxwriting LEFTPAR writing1 RIGHTPAR .)
    FOR             reduce using rule 41 (writing -> WRITE auxwriting LEFTPAR writing1 RIGHTPAR .)
    RETURN          reduce using rule 41 (writing -> WRITE auxwriting LEFTPAR writing1 RIGHTPAR .)
    SEMICOLON       reduce using rule 41 (writing -> WRITE auxwriting LEFTPAR writing1 RIGHTPAR .)


state 231

    (44) writing2 -> exp writingquad .
    (45) writing2 -> exp writingquad . COMMA auxwriting writing2

    RIGHTPAR        reduce using rule 44 (writing2 -> exp writingquad .)
    COMMA           shift and go to state 245


state 232

    (49) if -> IF LEFTPAR exp RIGHTPAR quadif . THEN LEFTBR statutes RIGHTBR else endif

    THEN            shift and go to state 246


state 233

    (59) while -> WHILE auxwhile LEFTPAR exp RIGHTPAR . DO quadwhile LEFTBR statutes RIGHTBR endofloop

    DO              shift and go to state 247


state 234

    (56) for -> FOR auxfor assign TO CTEINT . DO quadfor LEFTBR statutes RIGHTBR endofloop

    DO              shift and go to state 248


state 235

    (130) return -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .

    ID              reduce using rule 130 (return -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    READ            reduce using rule 130 (return -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    WRITE           reduce using rule 130 (return -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    IF              reduce using rule 130 (return -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    WHILE           reduce using rule 130 (return -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    FOR             reduce using rule 130 (return -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    RETURN          reduce using rule 130 (return -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    RIGHTBR         reduce using rule 130 (return -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)
    SEMICOLON       reduce using rule 130 (return -> RETURN LEFTPAR exp RIGHTPAR SEMICOLON .)


state 236

    (117) functions1 -> ID storefunct LEFTPAR args RIGHTPAR vars LEFTBR setaddstart . statutes RIGHTBR
    (10) statutes -> . assign SEMICOLON statutes
    (11) statutes -> . callFunction SEMICOLON statutes
    (12) statutes -> . reading statutes SEMICOLON statutes
    (13) statutes -> . writing statutes SEMICOLON statutes
    (14) statutes -> . if statutes
    (15) statutes -> . while statutes
    (16) statutes -> . for statutes
    (17) statutes -> . return statutes
    (18) statutes -> . empty
    (19) assign -> . ID idgetter EQUAL operatorhandler exp assignquad
    (20) assign -> . ID idgetter array EQUAL operatorhandler exp assignquad
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (34) reading -> . READ auxreading LEFTPAR reading1 RIGHTPAR
    (41) writing -> . WRITE auxwriting LEFTPAR writing1 RIGHTPAR
    (49) if -> . IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif
    (59) while -> . WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop
    (56) for -> . FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop
    (130) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (131) return -> . RETURN LEFTPAR exp RIGHTPAR
    (132) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    IF              shift and go to state 93
    WHILE           shift and go to state 94
    FOR             shift and go to state 95
    RETURN          shift and go to state 96
    RIGHTBR         reduce using rule 132 (empty -> .)

    statutes                       shift and go to state 249
    assign                         shift and go to state 81
    callFunction                   shift and go to state 82
    reading                        shift and go to state 83
    writing                        shift and go to state 84
    if                             shift and go to state 85
    while                          shift and go to state 86
    for                            shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 237

    (122) args1 -> INT saveTypeofVar COLON ID mulParam . nextParam
    (125) nextParam -> . COMMA args1
    (126) nextParam -> . empty
    (132) empty -> .

    COMMA           shift and go to state 251
    RIGHTPAR        reduce using rule 132 (empty -> .)

    nextParam                      shift and go to state 250
    empty                          shift and go to state 252

state 238

    (123) args1 -> FLOAT saveTypeofVar COLON ID mulParam . nextParam
    (125) nextParam -> . COMMA args1
    (126) nextParam -> . empty
    (132) empty -> .

    COMMA           shift and go to state 251
    RIGHTPAR        reduce using rule 132 (empty -> .)

    nextParam                      shift and go to state 253
    empty                          shift and go to state 252

state 239

    (124) args1 -> CHAR saveTypeofVar COLON ID mulParam . nextParam
    (125) nextParam -> . COMMA args1
    (126) nextParam -> . empty
    (132) empty -> .

    COMMA           shift and go to state 251
    RIGHTPAR        reduce using rule 132 (empty -> .)

    nextParam                      shift and go to state 254
    empty                          shift and go to state 252

state 240

    (24) callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam . RIGHTPAR quadgosub

    RIGHTPAR        shift and go to state 255


state 241

    (27) paramexp -> exp paramquad . paramaux
    (28) paramexp -> exp paramquad . COMMA paramaux paramexp
    (30) paramaux -> .

    COMMA           shift and go to state 257
    RIGHTPAR        reduce using rule 30 (paramaux -> .)

    paramaux                       shift and go to state 256

state 242

    (19) assign -> ID idgetter EQUAL operatorhandler exp assignquad .

    SEMICOLON       reduce using rule 19 (assign -> ID idgetter EQUAL operatorhandler exp assignquad .)
    TO              reduce using rule 19 (assign -> ID idgetter EQUAL operatorhandler exp assignquad .)


state 243

    (20) assign -> ID idgetter array EQUAL operatorhandler exp . assignquad
    (23) assignquad -> .

    SEMICOLON       reduce using rule 23 (assignquad -> .)
    TO              reduce using rule 23 (assignquad -> .)

    assignquad                     shift and go to state 258

state 244

    (38) reading2 -> exp readingquad COMMA . auxreading reading2
    (39) auxreading -> .

    ID              reduce using rule 39 (auxreading -> .)
    CTEINT          reduce using rule 39 (auxreading -> .)
    CTEFLOAT        reduce using rule 39 (auxreading -> .)
    CTECHAR         reduce using rule 39 (auxreading -> .)
    CTESTRING       reduce using rule 39 (auxreading -> .)
    LEFTPAR         reduce using rule 39 (auxreading -> .)
    COMMA           reduce using rule 39 (auxreading -> .)
    OR              reduce using rule 39 (auxreading -> .)
    AND             reduce using rule 39 (auxreading -> .)
    LESSER          reduce using rule 39 (auxreading -> .)
    LESSERAND       reduce using rule 39 (auxreading -> .)
    GREATER         reduce using rule 39 (auxreading -> .)
    GREATERAND      reduce using rule 39 (auxreading -> .)
    NOTSAME         reduce using rule 39 (auxreading -> .)
    PLUS            reduce using rule 39 (auxreading -> .)
    REST            reduce using rule 39 (auxreading -> .)
    TIMES           reduce using rule 39 (auxreading -> .)
    DIVIDE          reduce using rule 39 (auxreading -> .)
    RIGHTPAR        reduce using rule 39 (auxreading -> .)

    auxreading                     shift and go to state 259

state 245

    (45) writing2 -> exp writingquad COMMA . auxwriting writing2
    (46) auxwriting -> .

    ID              reduce using rule 46 (auxwriting -> .)
    CTEINT          reduce using rule 46 (auxwriting -> .)
    CTEFLOAT        reduce using rule 46 (auxwriting -> .)
    CTECHAR         reduce using rule 46 (auxwriting -> .)
    CTESTRING       reduce using rule 46 (auxwriting -> .)
    LEFTPAR         reduce using rule 46 (auxwriting -> .)
    COMMA           reduce using rule 46 (auxwriting -> .)
    OR              reduce using rule 46 (auxwriting -> .)
    AND             reduce using rule 46 (auxwriting -> .)
    LESSER          reduce using rule 46 (auxwriting -> .)
    LESSERAND       reduce using rule 46 (auxwriting -> .)
    GREATER         reduce using rule 46 (auxwriting -> .)
    GREATERAND      reduce using rule 46 (auxwriting -> .)
    NOTSAME         reduce using rule 46 (auxwriting -> .)
    PLUS            reduce using rule 46 (auxwriting -> .)
    REST            reduce using rule 46 (auxwriting -> .)
    TIMES           reduce using rule 46 (auxwriting -> .)
    DIVIDE          reduce using rule 46 (auxwriting -> .)
    RIGHTPAR        reduce using rule 46 (auxwriting -> .)

    auxwriting                     shift and go to state 260

state 246

    (49) if -> IF LEFTPAR exp RIGHTPAR quadif THEN . LEFTBR statutes RIGHTBR else endif

    LEFTBR          shift and go to state 261


state 247

    (59) while -> WHILE auxwhile LEFTPAR exp RIGHTPAR DO . quadwhile LEFTBR statutes RIGHTBR endofloop
    (61) quadwhile -> .

    LEFTBR          reduce using rule 61 (quadwhile -> .)

    quadwhile                      shift and go to state 262

state 248

    (56) for -> FOR auxfor assign TO CTEINT DO . quadfor LEFTBR statutes RIGHTBR endofloop
    (58) quadfor -> .

    LEFTBR          reduce using rule 58 (quadfor -> .)

    quadfor                        shift and go to state 263

state 249

    (117) functions1 -> ID storefunct LEFTPAR args RIGHTPAR vars LEFTBR setaddstart statutes . RIGHTBR

    RIGHTBR         shift and go to state 264


state 250

    (122) args1 -> INT saveTypeofVar COLON ID mulParam nextParam .

    RIGHTPAR        reduce using rule 122 (args1 -> INT saveTypeofVar COLON ID mulParam nextParam .)


state 251

    (125) nextParam -> COMMA . args1
    (122) args1 -> . INT saveTypeofVar COLON ID mulParam nextParam
    (123) args1 -> . FLOAT saveTypeofVar COLON ID mulParam nextParam
    (124) args1 -> . CHAR saveTypeofVar COLON ID mulParam nextParam

    INT             shift and go to state 100
    FLOAT           shift and go to state 101
    CHAR            shift and go to state 102

    args1                          shift and go to state 265

state 252

    (126) nextParam -> empty .

    RIGHTPAR        reduce using rule 126 (nextParam -> empty .)


state 253

    (123) args1 -> FLOAT saveTypeofVar COLON ID mulParam nextParam .

    RIGHTPAR        reduce using rule 123 (args1 -> FLOAT saveTypeofVar COLON ID mulParam nextParam .)


state 254

    (124) args1 -> CHAR saveTypeofVar COLON ID mulParam nextParam .

    RIGHTPAR        reduce using rule 124 (args1 -> CHAR saveTypeofVar COLON ID mulParam nextParam .)


state 255

    (24) callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR . quadgosub
    (33) quadgosub -> .

    TIMES           reduce using rule 33 (quadgosub -> .)
    DIVIDE          reduce using rule 33 (quadgosub -> .)
    PLUS            reduce using rule 33 (quadgosub -> .)
    REST            reduce using rule 33 (quadgosub -> .)
    LESSER          reduce using rule 33 (quadgosub -> .)
    LESSERAND       reduce using rule 33 (quadgosub -> .)
    GREATER         reduce using rule 33 (quadgosub -> .)
    GREATERAND      reduce using rule 33 (quadgosub -> .)
    NOTSAME         reduce using rule 33 (quadgosub -> .)
    AND             reduce using rule 33 (quadgosub -> .)
    OR              reduce using rule 33 (quadgosub -> .)
    RIGHTSQR        reduce using rule 33 (quadgosub -> .)
    SEMICOLON       reduce using rule 33 (quadgosub -> .)
    RIGHTPAR        reduce using rule 33 (quadgosub -> .)
    COMMA           reduce using rule 33 (quadgosub -> .)
    TO              reduce using rule 33 (quadgosub -> .)
    ID              reduce using rule 33 (quadgosub -> .)
    CTEINT          reduce using rule 33 (quadgosub -> .)
    CTEFLOAT        reduce using rule 33 (quadgosub -> .)
    CTECHAR         reduce using rule 33 (quadgosub -> .)
    CTESTRING       reduce using rule 33 (quadgosub -> .)
    LEFTPAR         reduce using rule 33 (quadgosub -> .)

    quadgosub                      shift and go to state 266

state 256

    (27) paramexp -> exp paramquad paramaux .

    RIGHTPAR        reduce using rule 27 (paramexp -> exp paramquad paramaux .)


state 257

    (28) paramexp -> exp paramquad COMMA . paramaux paramexp
    (30) paramaux -> .

    ID              reduce using rule 30 (paramaux -> .)
    CTEINT          reduce using rule 30 (paramaux -> .)
    CTEFLOAT        reduce using rule 30 (paramaux -> .)
    CTECHAR         reduce using rule 30 (paramaux -> .)
    CTESTRING       reduce using rule 30 (paramaux -> .)
    LEFTPAR         reduce using rule 30 (paramaux -> .)
    COMMA           reduce using rule 30 (paramaux -> .)
    OR              reduce using rule 30 (paramaux -> .)
    AND             reduce using rule 30 (paramaux -> .)
    LESSER          reduce using rule 30 (paramaux -> .)
    LESSERAND       reduce using rule 30 (paramaux -> .)
    GREATER         reduce using rule 30 (paramaux -> .)
    GREATERAND      reduce using rule 30 (paramaux -> .)
    NOTSAME         reduce using rule 30 (paramaux -> .)
    PLUS            reduce using rule 30 (paramaux -> .)
    REST            reduce using rule 30 (paramaux -> .)
    TIMES           reduce using rule 30 (paramaux -> .)
    DIVIDE          reduce using rule 30 (paramaux -> .)
    RIGHTPAR        reduce using rule 30 (paramaux -> .)

    paramaux                       shift and go to state 267

state 258

    (20) assign -> ID idgetter array EQUAL operatorhandler exp assignquad .

    SEMICOLON       reduce using rule 20 (assign -> ID idgetter array EQUAL operatorhandler exp assignquad .)
    TO              reduce using rule 20 (assign -> ID idgetter array EQUAL operatorhandler exp assignquad .)


state 259

    (38) reading2 -> exp readingquad COMMA auxreading . reading2
    (37) reading2 -> . exp readingquad
    (38) reading2 -> . exp readingquad COMMA auxreading reading2
    (62) exp -> . andexp quador
    (63) exp -> . andexp quador OR operatorhandler andexp
    (65) andexp -> . boolexp quadand
    (66) andexp -> . boolexp quadand AND operatorhandler boolexp
    (68) boolexp -> . arithexp
    (69) boolexp -> . boolexp1 arithexp
    (76) arithexp -> . geoexp
    (77) arithexp -> . geoexp PLUS operatorhandler geoexp quadarith
    (78) arithexp -> . geoexp REST operatorhandler geoexp quadarith
    (70) boolexp1 -> . arithexp LESSER operatorhandler arithexp quadbool
    (71) boolexp1 -> . arithexp LESSERAND operatorhandler arithexp quadbool
    (72) boolexp1 -> . arithexp GREATER operatorhandler arithexp quadbool
    (73) boolexp1 -> . arithexp GREATERAND operatorhandler arithexp quadbool
    (74) boolexp1 -> . arithexp NOTSAME operatorhandler arithexp quadbool
    (80) geoexp -> . assignedexp
    (81) geoexp -> . assignedexp TIMES operatorhandler assignedexp quadgeo
    (82) geoexp -> . assignedexp DIVIDE operatorhandler assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (132) empty -> .

    ID              shift and go to state 73
    CTEINT          shift and go to state 116
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)
    LESSER          reduce using rule 132 (empty -> .)
    LESSERAND       reduce using rule 132 (empty -> .)
    GREATER         reduce using rule 132 (empty -> .)
    GREATERAND      reduce using rule 132 (empty -> .)
    NOTSAME         reduce using rule 132 (empty -> .)
    AND             reduce using rule 132 (empty -> .)
    OR              reduce using rule 132 (empty -> .)
    COMMA           reduce using rule 132 (empty -> .)
    RIGHTPAR        reduce using rule 132 (empty -> .)

    exp                            shift and go to state 199
    reading2                       shift and go to state 268
    andexp                         shift and go to state 67
    boolexp                        shift and go to state 68
    arithexp                       shift and go to state 69
    boolexp1                       shift and go to state 70
    geoexp                         shift and go to state 71
    assignedexp                    shift and go to state 72
    callFunction                   shift and go to state 77
    empty                          shift and go to state 79

state 260

    (45) writing2 -> exp writingquad COMMA auxwriting . writing2
    (44) writing2 -> . exp writingquad
    (45) writing2 -> . exp writingquad COMMA auxwriting writing2
    (62) exp -> . andexp quador
    (63) exp -> . andexp quador OR operatorhandler andexp
    (65) andexp -> . boolexp quadand
    (66) andexp -> . boolexp quadand AND operatorhandler boolexp
    (68) boolexp -> . arithexp
    (69) boolexp -> . boolexp1 arithexp
    (76) arithexp -> . geoexp
    (77) arithexp -> . geoexp PLUS operatorhandler geoexp quadarith
    (78) arithexp -> . geoexp REST operatorhandler geoexp quadarith
    (70) boolexp1 -> . arithexp LESSER operatorhandler arithexp quadbool
    (71) boolexp1 -> . arithexp LESSERAND operatorhandler arithexp quadbool
    (72) boolexp1 -> . arithexp GREATER operatorhandler arithexp quadbool
    (73) boolexp1 -> . arithexp GREATERAND operatorhandler arithexp quadbool
    (74) boolexp1 -> . arithexp NOTSAME operatorhandler arithexp quadbool
    (80) geoexp -> . assignedexp
    (81) geoexp -> . assignedexp TIMES operatorhandler assignedexp quadgeo
    (82) geoexp -> . assignedexp DIVIDE operatorhandler assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (132) empty -> .

    ID              shift and go to state 73
    CTEINT          shift and go to state 116
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)
    LESSER          reduce using rule 132 (empty -> .)
    LESSERAND       reduce using rule 132 (empty -> .)
    GREATER         reduce using rule 132 (empty -> .)
    GREATERAND      reduce using rule 132 (empty -> .)
    NOTSAME         reduce using rule 132 (empty -> .)
    AND             reduce using rule 132 (empty -> .)
    OR              reduce using rule 132 (empty -> .)
    COMMA           reduce using rule 132 (empty -> .)
    RIGHTPAR        reduce using rule 132 (empty -> .)

    exp                            shift and go to state 203
    writing2                       shift and go to state 269
    andexp                         shift and go to state 67
    boolexp                        shift and go to state 68
    arithexp                       shift and go to state 69
    boolexp1                       shift and go to state 70
    geoexp                         shift and go to state 71
    assignedexp                    shift and go to state 72
    callFunction                   shift and go to state 77
    empty                          shift and go to state 79

state 261

    (49) if -> IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR . statutes RIGHTBR else endif
    (10) statutes -> . assign SEMICOLON statutes
    (11) statutes -> . callFunction SEMICOLON statutes
    (12) statutes -> . reading statutes SEMICOLON statutes
    (13) statutes -> . writing statutes SEMICOLON statutes
    (14) statutes -> . if statutes
    (15) statutes -> . while statutes
    (16) statutes -> . for statutes
    (17) statutes -> . return statutes
    (18) statutes -> . empty
    (19) assign -> . ID idgetter EQUAL operatorhandler exp assignquad
    (20) assign -> . ID idgetter array EQUAL operatorhandler exp assignquad
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (34) reading -> . READ auxreading LEFTPAR reading1 RIGHTPAR
    (41) writing -> . WRITE auxwriting LEFTPAR writing1 RIGHTPAR
    (49) if -> . IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif
    (59) while -> . WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop
    (56) for -> . FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop
    (130) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (131) return -> . RETURN LEFTPAR exp RIGHTPAR
    (132) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    IF              shift and go to state 93
    WHILE           shift and go to state 94
    FOR             shift and go to state 95
    RETURN          shift and go to state 96
    RIGHTBR         reduce using rule 132 (empty -> .)

    statutes                       shift and go to state 270
    assign                         shift and go to state 81
    callFunction                   shift and go to state 82
    reading                        shift and go to state 83
    writing                        shift and go to state 84
    if                             shift and go to state 85
    while                          shift and go to state 86
    for                            shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 262

    (59) while -> WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile . LEFTBR statutes RIGHTBR endofloop

    LEFTBR          shift and go to state 271


state 263

    (56) for -> FOR auxfor assign TO CTEINT DO quadfor . LEFTBR statutes RIGHTBR endofloop

    LEFTBR          shift and go to state 272


state 264

    (117) functions1 -> ID storefunct LEFTPAR args RIGHTPAR vars LEFTBR setaddstart statutes RIGHTBR .

    FUNCTION        reduce using rule 117 (functions1 -> ID storefunct LEFTPAR args RIGHTPAR vars LEFTBR setaddstart statutes RIGHTBR .)
    PRINCIPAL       reduce using rule 117 (functions1 -> ID storefunct LEFTPAR args RIGHTPAR vars LEFTBR setaddstart statutes RIGHTBR .)
    $end            reduce using rule 117 (functions1 -> ID storefunct LEFTPAR args RIGHTPAR vars LEFTBR setaddstart statutes RIGHTBR .)


state 265

    (125) nextParam -> COMMA args1 .

    RIGHTPAR        reduce using rule 125 (nextParam -> COMMA args1 .)


state 266

    (24) callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub .

    TIMES           reduce using rule 24 (callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub .)
    DIVIDE          reduce using rule 24 (callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub .)
    PLUS            reduce using rule 24 (callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub .)
    REST            reduce using rule 24 (callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub .)
    LESSER          reduce using rule 24 (callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub .)
    LESSERAND       reduce using rule 24 (callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub .)
    GREATER         reduce using rule 24 (callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub .)
    GREATERAND      reduce using rule 24 (callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub .)
    NOTSAME         reduce using rule 24 (callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub .)
    AND             reduce using rule 24 (callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub .)
    OR              reduce using rule 24 (callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub .)
    RIGHTSQR        reduce using rule 24 (callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub .)
    SEMICOLON       reduce using rule 24 (callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub .)
    RIGHTPAR        reduce using rule 24 (callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub .)
    COMMA           reduce using rule 24 (callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub .)
    TO              reduce using rule 24 (callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub .)
    ID              reduce using rule 24 (callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub .)
    CTEINT          reduce using rule 24 (callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub .)
    CTEFLOAT        reduce using rule 24 (callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub .)
    CTECHAR         reduce using rule 24 (callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub .)
    CTESTRING       reduce using rule 24 (callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub .)
    LEFTPAR         reduce using rule 24 (callFunction -> ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub .)


state 267

    (28) paramexp -> exp paramquad COMMA paramaux . paramexp
    (27) paramexp -> . exp paramquad paramaux
    (28) paramexp -> . exp paramquad COMMA paramaux paramexp
    (29) paramexp -> . empty
    (62) exp -> . andexp quador
    (63) exp -> . andexp quador OR operatorhandler andexp
    (132) empty -> .
    (65) andexp -> . boolexp quadand
    (66) andexp -> . boolexp quadand AND operatorhandler boolexp
    (68) boolexp -> . arithexp
    (69) boolexp -> . boolexp1 arithexp
    (76) arithexp -> . geoexp
    (77) arithexp -> . geoexp PLUS operatorhandler geoexp quadarith
    (78) arithexp -> . geoexp REST operatorhandler geoexp quadarith
    (70) boolexp1 -> . arithexp LESSER operatorhandler arithexp quadbool
    (71) boolexp1 -> . arithexp LESSERAND operatorhandler arithexp quadbool
    (72) boolexp1 -> . arithexp GREATER operatorhandler arithexp quadbool
    (73) boolexp1 -> . arithexp GREATERAND operatorhandler arithexp quadbool
    (74) boolexp1 -> . arithexp NOTSAME operatorhandler arithexp quadbool
    (80) geoexp -> . assignedexp
    (81) geoexp -> . assignedexp TIMES operatorhandler assignedexp quadgeo
    (82) geoexp -> . assignedexp DIVIDE operatorhandler assignedexp quadgeo
    (84) assignedexp -> . ID idgetter
    (85) assignedexp -> . CTEINT cteaux
    (86) assignedexp -> . CTEFLOAT cteaux
    (87) assignedexp -> . CTECHAR cteaux
    (88) assignedexp -> . CTESTRING cteaux
    (89) assignedexp -> . callFunction
    (90) assignedexp -> . LEFTPAR exp RIGHTPAR
    (91) assignedexp -> . ID array idgetterarray
    (92) assignedexp -> . empty
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub

    RIGHTPAR        reduce using rule 132 (empty -> .)
    TIMES           reduce using rule 132 (empty -> .)
    DIVIDE          reduce using rule 132 (empty -> .)
    PLUS            reduce using rule 132 (empty -> .)
    REST            reduce using rule 132 (empty -> .)
    LESSER          reduce using rule 132 (empty -> .)
    LESSERAND       reduce using rule 132 (empty -> .)
    GREATER         reduce using rule 132 (empty -> .)
    GREATERAND      reduce using rule 132 (empty -> .)
    NOTSAME         reduce using rule 132 (empty -> .)
    AND             reduce using rule 132 (empty -> .)
    OR              reduce using rule 132 (empty -> .)
    COMMA           reduce using rule 132 (empty -> .)
    ID              shift and go to state 73
    CTEINT          shift and go to state 116
    CTEFLOAT        shift and go to state 74
    CTECHAR         shift and go to state 75
    CTESTRING       shift and go to state 76
    LEFTPAR         shift and go to state 78

    exp                            shift and go to state 224
    paramexp                       shift and go to state 273
    empty                          shift and go to state 225
    andexp                         shift and go to state 67
    boolexp                        shift and go to state 68
    arithexp                       shift and go to state 69
    boolexp1                       shift and go to state 70
    geoexp                         shift and go to state 71
    assignedexp                    shift and go to state 72
    callFunction                   shift and go to state 77

state 268

    (38) reading2 -> exp readingquad COMMA auxreading reading2 .

    RIGHTPAR        reduce using rule 38 (reading2 -> exp readingquad COMMA auxreading reading2 .)


state 269

    (45) writing2 -> exp writingquad COMMA auxwriting writing2 .

    RIGHTPAR        reduce using rule 45 (writing2 -> exp writingquad COMMA auxwriting writing2 .)


state 270

    (49) if -> IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes . RIGHTBR else endif

    RIGHTBR         shift and go to state 274


state 271

    (59) while -> WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR . statutes RIGHTBR endofloop
    (10) statutes -> . assign SEMICOLON statutes
    (11) statutes -> . callFunction SEMICOLON statutes
    (12) statutes -> . reading statutes SEMICOLON statutes
    (13) statutes -> . writing statutes SEMICOLON statutes
    (14) statutes -> . if statutes
    (15) statutes -> . while statutes
    (16) statutes -> . for statutes
    (17) statutes -> . return statutes
    (18) statutes -> . empty
    (19) assign -> . ID idgetter EQUAL operatorhandler exp assignquad
    (20) assign -> . ID idgetter array EQUAL operatorhandler exp assignquad
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (34) reading -> . READ auxreading LEFTPAR reading1 RIGHTPAR
    (41) writing -> . WRITE auxwriting LEFTPAR writing1 RIGHTPAR
    (49) if -> . IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif
    (59) while -> . WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop
    (56) for -> . FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop
    (130) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (131) return -> . RETURN LEFTPAR exp RIGHTPAR
    (132) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    IF              shift and go to state 93
    WHILE           shift and go to state 94
    FOR             shift and go to state 95
    RETURN          shift and go to state 96
    RIGHTBR         reduce using rule 132 (empty -> .)

    statutes                       shift and go to state 275
    assign                         shift and go to state 81
    callFunction                   shift and go to state 82
    reading                        shift and go to state 83
    writing                        shift and go to state 84
    if                             shift and go to state 85
    while                          shift and go to state 86
    for                            shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 272

    (56) for -> FOR auxfor assign TO CTEINT DO quadfor LEFTBR . statutes RIGHTBR endofloop
    (10) statutes -> . assign SEMICOLON statutes
    (11) statutes -> . callFunction SEMICOLON statutes
    (12) statutes -> . reading statutes SEMICOLON statutes
    (13) statutes -> . writing statutes SEMICOLON statutes
    (14) statutes -> . if statutes
    (15) statutes -> . while statutes
    (16) statutes -> . for statutes
    (17) statutes -> . return statutes
    (18) statutes -> . empty
    (19) assign -> . ID idgetter EQUAL operatorhandler exp assignquad
    (20) assign -> . ID idgetter array EQUAL operatorhandler exp assignquad
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (34) reading -> . READ auxreading LEFTPAR reading1 RIGHTPAR
    (41) writing -> . WRITE auxwriting LEFTPAR writing1 RIGHTPAR
    (49) if -> . IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif
    (59) while -> . WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop
    (56) for -> . FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop
    (130) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (131) return -> . RETURN LEFTPAR exp RIGHTPAR
    (132) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    IF              shift and go to state 93
    WHILE           shift and go to state 94
    FOR             shift and go to state 95
    RETURN          shift and go to state 96
    RIGHTBR         reduce using rule 132 (empty -> .)

    assign                         shift and go to state 81
    statutes                       shift and go to state 276
    callFunction                   shift and go to state 82
    reading                        shift and go to state 83
    writing                        shift and go to state 84
    if                             shift and go to state 85
    while                          shift and go to state 86
    for                            shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 273

    (28) paramexp -> exp paramquad COMMA paramaux paramexp .

    RIGHTPAR        reduce using rule 28 (paramexp -> exp paramquad COMMA paramaux paramexp .)


state 274

    (49) if -> IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR . else endif
    (50) else -> . ELSE quadelse LEFTBR statutes RIGHTBR
    (51) else -> . empty
    (132) empty -> .

    ELSE            shift and go to state 278
    ID              reduce using rule 132 (empty -> .)
    READ            reduce using rule 132 (empty -> .)
    WRITE           reduce using rule 132 (empty -> .)
    IF              reduce using rule 132 (empty -> .)
    WHILE           reduce using rule 132 (empty -> .)
    FOR             reduce using rule 132 (empty -> .)
    RETURN          reduce using rule 132 (empty -> .)
    RIGHTBR         reduce using rule 132 (empty -> .)
    SEMICOLON       reduce using rule 132 (empty -> .)

    else                           shift and go to state 277
    empty                          shift and go to state 279

state 275

    (59) while -> WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes . RIGHTBR endofloop

    RIGHTBR         shift and go to state 280


state 276

    (56) for -> FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes . RIGHTBR endofloop

    RIGHTBR         shift and go to state 281


state 277

    (49) if -> IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else . endif
    (53) endif -> .

    ID              reduce using rule 53 (endif -> .)
    READ            reduce using rule 53 (endif -> .)
    WRITE           reduce using rule 53 (endif -> .)
    IF              reduce using rule 53 (endif -> .)
    WHILE           reduce using rule 53 (endif -> .)
    FOR             reduce using rule 53 (endif -> .)
    RETURN          reduce using rule 53 (endif -> .)
    RIGHTBR         reduce using rule 53 (endif -> .)
    SEMICOLON       reduce using rule 53 (endif -> .)

    endif                          shift and go to state 282

state 278

    (50) else -> ELSE . quadelse LEFTBR statutes RIGHTBR
    (54) quadelse -> .

    LEFTBR          reduce using rule 54 (quadelse -> .)

    quadelse                       shift and go to state 283

state 279

    (51) else -> empty .

    ID              reduce using rule 51 (else -> empty .)
    READ            reduce using rule 51 (else -> empty .)
    WRITE           reduce using rule 51 (else -> empty .)
    IF              reduce using rule 51 (else -> empty .)
    WHILE           reduce using rule 51 (else -> empty .)
    FOR             reduce using rule 51 (else -> empty .)
    RETURN          reduce using rule 51 (else -> empty .)
    RIGHTBR         reduce using rule 51 (else -> empty .)
    SEMICOLON       reduce using rule 51 (else -> empty .)


state 280

    (59) while -> WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR . endofloop
    (55) endofloop -> .

    ID              reduce using rule 55 (endofloop -> .)
    READ            reduce using rule 55 (endofloop -> .)
    WRITE           reduce using rule 55 (endofloop -> .)
    IF              reduce using rule 55 (endofloop -> .)
    WHILE           reduce using rule 55 (endofloop -> .)
    FOR             reduce using rule 55 (endofloop -> .)
    RETURN          reduce using rule 55 (endofloop -> .)
    RIGHTBR         reduce using rule 55 (endofloop -> .)
    SEMICOLON       reduce using rule 55 (endofloop -> .)

    endofloop                      shift and go to state 284

state 281

    (56) for -> FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR . endofloop
    (55) endofloop -> .

    ID              reduce using rule 55 (endofloop -> .)
    READ            reduce using rule 55 (endofloop -> .)
    WRITE           reduce using rule 55 (endofloop -> .)
    IF              reduce using rule 55 (endofloop -> .)
    WHILE           reduce using rule 55 (endofloop -> .)
    FOR             reduce using rule 55 (endofloop -> .)
    RETURN          reduce using rule 55 (endofloop -> .)
    RIGHTBR         reduce using rule 55 (endofloop -> .)
    SEMICOLON       reduce using rule 55 (endofloop -> .)

    endofloop                      shift and go to state 285

state 282

    (49) if -> IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif .

    ID              reduce using rule 49 (if -> IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif .)
    READ            reduce using rule 49 (if -> IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif .)
    WRITE           reduce using rule 49 (if -> IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif .)
    IF              reduce using rule 49 (if -> IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif .)
    WHILE           reduce using rule 49 (if -> IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif .)
    FOR             reduce using rule 49 (if -> IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif .)
    RETURN          reduce using rule 49 (if -> IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif .)
    RIGHTBR         reduce using rule 49 (if -> IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif .)
    SEMICOLON       reduce using rule 49 (if -> IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif .)


state 283

    (50) else -> ELSE quadelse . LEFTBR statutes RIGHTBR

    LEFTBR          shift and go to state 286


state 284

    (59) while -> WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop .

    ID              reduce using rule 59 (while -> WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop .)
    READ            reduce using rule 59 (while -> WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop .)
    WRITE           reduce using rule 59 (while -> WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop .)
    IF              reduce using rule 59 (while -> WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop .)
    WHILE           reduce using rule 59 (while -> WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop .)
    FOR             reduce using rule 59 (while -> WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop .)
    RETURN          reduce using rule 59 (while -> WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop .)
    RIGHTBR         reduce using rule 59 (while -> WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop .)
    SEMICOLON       reduce using rule 59 (while -> WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop .)


state 285

    (56) for -> FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop .

    ID              reduce using rule 56 (for -> FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop .)
    READ            reduce using rule 56 (for -> FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop .)
    WRITE           reduce using rule 56 (for -> FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop .)
    IF              reduce using rule 56 (for -> FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop .)
    WHILE           reduce using rule 56 (for -> FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop .)
    FOR             reduce using rule 56 (for -> FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop .)
    RETURN          reduce using rule 56 (for -> FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop .)
    RIGHTBR         reduce using rule 56 (for -> FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop .)
    SEMICOLON       reduce using rule 56 (for -> FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop .)


state 286

    (50) else -> ELSE quadelse LEFTBR . statutes RIGHTBR
    (10) statutes -> . assign SEMICOLON statutes
    (11) statutes -> . callFunction SEMICOLON statutes
    (12) statutes -> . reading statutes SEMICOLON statutes
    (13) statutes -> . writing statutes SEMICOLON statutes
    (14) statutes -> . if statutes
    (15) statutes -> . while statutes
    (16) statutes -> . for statutes
    (17) statutes -> . return statutes
    (18) statutes -> . empty
    (19) assign -> . ID idgetter EQUAL operatorhandler exp assignquad
    (20) assign -> . ID idgetter array EQUAL operatorhandler exp assignquad
    (24) callFunction -> . ID checkid eraquad LEFTPAR paramexp checkparam RIGHTPAR quadgosub
    (34) reading -> . READ auxreading LEFTPAR reading1 RIGHTPAR
    (41) writing -> . WRITE auxwriting LEFTPAR writing1 RIGHTPAR
    (49) if -> . IF LEFTPAR exp RIGHTPAR quadif THEN LEFTBR statutes RIGHTBR else endif
    (59) while -> . WHILE auxwhile LEFTPAR exp RIGHTPAR DO quadwhile LEFTBR statutes RIGHTBR endofloop
    (56) for -> . FOR auxfor assign TO CTEINT DO quadfor LEFTBR statutes RIGHTBR endofloop
    (130) return -> . RETURN LEFTPAR exp RIGHTPAR SEMICOLON
    (131) return -> . RETURN LEFTPAR exp RIGHTPAR
    (132) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    IF              shift and go to state 93
    WHILE           shift and go to state 94
    FOR             shift and go to state 95
    RETURN          shift and go to state 96
    RIGHTBR         reduce using rule 132 (empty -> .)

    statutes                       shift and go to state 287
    assign                         shift and go to state 81
    callFunction                   shift and go to state 82
    reading                        shift and go to state 83
    writing                        shift and go to state 84
    if                             shift and go to state 85
    while                          shift and go to state 86
    for                            shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 287

    (50) else -> ELSE quadelse LEFTBR statutes . RIGHTBR

    RIGHTBR         shift and go to state 288


state 288

    (50) else -> ELSE quadelse LEFTBR statutes RIGHTBR .

    ID              reduce using rule 50 (else -> ELSE quadelse LEFTBR statutes RIGHTBR .)
    READ            reduce using rule 50 (else -> ELSE quadelse LEFTBR statutes RIGHTBR .)
    WRITE           reduce using rule 50 (else -> ELSE quadelse LEFTBR statutes RIGHTBR .)
    IF              reduce using rule 50 (else -> ELSE quadelse LEFTBR statutes RIGHTBR .)
    WHILE           reduce using rule 50 (else -> ELSE quadelse LEFTBR statutes RIGHTBR .)
    FOR             reduce using rule 50 (else -> ELSE quadelse LEFTBR statutes RIGHTBR .)
    RETURN          reduce using rule 50 (else -> ELSE quadelse LEFTBR statutes RIGHTBR .)
    RIGHTBR         reduce using rule 50 (else -> ELSE quadelse LEFTBR statutes RIGHTBR .)
    SEMICOLON       reduce using rule 50 (else -> ELSE quadelse LEFTBR statutes RIGHTBR .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PRINCIPAL in state 5 resolved as shift
WARNING: shift/reduce conflict for RIGHTSQR in state 66 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 71 resolved as shift
WARNING: shift/reduce conflict for REST in state 71 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 72 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 72 resolved as shift
WARNING: shift/reduce conflict for ID in state 151 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 151 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 151 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 151 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 151 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 151 resolved as shift
WARNING: shift/reduce conflict for ID in state 152 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 152 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 152 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 152 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 152 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 152 resolved as shift
WARNING: shift/reduce conflict for ID in state 153 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 153 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 153 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 153 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 153 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 153 resolved as shift
WARNING: shift/reduce conflict for ID in state 154 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 154 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 154 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 154 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 154 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 154 resolved as shift
WARNING: shift/reduce conflict for ID in state 155 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 155 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 155 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 155 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 155 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 155 resolved as shift
WARNING: shift/reduce conflict for ID in state 156 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 156 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 156 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 156 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 156 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 156 resolved as shift
WARNING: shift/reduce conflict for ID in state 157 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 157 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 157 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 157 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 157 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 157 resolved as shift
WARNING: shift/reduce conflict for ID in state 158 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 158 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 158 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 158 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 158 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 158 resolved as shift
WARNING: shift/reduce conflict for ID in state 159 resolved as shift
WARNING: shift/reduce conflict for CTEINT in state 159 resolved as shift
WARNING: shift/reduce conflict for CTEFLOAT in state 159 resolved as shift
WARNING: shift/reduce conflict for CTECHAR in state 159 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 159 resolved as shift
WARNING: shift/reduce conflict for LEFTPAR in state 159 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 207 resolved as shift
WARNING: reduce/reduce conflict in state 73 resolved using rule (idgetter -> <empty>)
WARNING: rejected rule (checkid -> <empty>) in state 73
WARNING: reduce/reduce conflict in state 198 resolved using rule (reading1 -> empty)
WARNING: rejected rule (assignedexp -> empty) in state 198
WARNING: reduce/reduce conflict in state 202 resolved using rule (writing1 -> empty)
WARNING: rejected rule (assignedexp -> empty) in state 202
WARNING: reduce/reduce conflict in state 225 resolved using rule (paramexp -> empty)
WARNING: rejected rule (assignedexp -> empty) in state 225
